<!-- Code generated by webkit; DO NOT EDIT. -->
# Agent Guidelines

This document provides guidelines for AI agents working on the WebKit codebase.

## Note For Humans

This is a living document that will improve as more people/agents use it over time. Every effort has
been made to keep the guidance in here as generic and reusable as possible. Please keep this in mind
with any future edits.

**Note**: Investigation summaries and debugging analysis should be displayed via UI only, not
committed to the repository.

## Updating Documentation

If you need to update developer guidelines, clone and edit the [ainsley.dev/website](https://github.com/ainsleydev/website) repository.
These guidelines are automatically synced from there.

## WebKit

WebKit is a Go-based CLI tool designed to streamline the lifecycle of web projects. It centralises
configuration in a single manifest file (`app.json`) and automatically generates surrounding
infrastructure, CI/CD pipelines, and environment scaffolding.

WebKit helps reduce repetitive setup work, improves consistency across deployments, and provides a
reliable foundation for infrastructure management.

**Key features**:

- Single source of truth via `app.json` manifest.
- Automatic generation of Docker configurations, GitHub workflows, and environment files.
- Infrastructure provisioning through Terraform.
- Secret management via SOPS.
- Template-based file generation with tracking.

# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this
repository.

## Overview

WebKit is a CLI tool written in Go that transforms a single `app.json` manifest into
production-ready infrastructure and CI/CD pipelines. It generates Terraform configurations, GitHub
Actions workflows, and project files without cluttering project repositories with infrastructure
code.

## Core Commands

### Development

```bash
# Initial setup - installs all dev dependencies
make setup

# Run webkit locally in development mode
pnpm webkit <args>

# Build and install webkit binary
pnpm build
```

### Testing

```bash
# Run all tests (Go + JS)
pnpm test

# Run Go tests only
pnpm test:go

# Run JS tests only (npm packages in packages/)
pnpm test:js

# Run single test
go test -run TestName ./path/to/package
```

### Linting and Formatting

```bash
# Format and lint everything
pnpm check

# Format Go code
pnpm format:go

# Format JS/TS code
pnpm format:js

# Lint Go code (uses golangci-lint)
pnpm lint:go

# Lint JS/TS code (uses biome)
pnpm lint:js
```

### Local Workflow Testing

```bash
# Test GitHub Actions workflows locally using act
pnpm act:lint
pnpm act:test
pnpm act:release  # dry-run only
```

### Generate Commands

```bash
# Generate documentation
pnpm generate:docs

# Generate agent prompts
pnpm generate:agents
```

## Architecture

### High-Level Flow

1. **app.json** → User defines apps, resources, and environments
2. **appdef** → Parses and validates the manifest
3. **scaffold** → Generates files from templates with tracking
4. **manifest** → Tracks generated files with hashes for drift detection
5. **infra** → Wraps Terraform to provision infrastructure
6. **cicd** → Generates GitHub Actions workflows
7. **secrets** → Handles SOPS/Age encryption for environment variables

### Key Packages

#### internal/appdef

Defines the structure of `app.json` and handles parsing/validation. Core types:

- `App`: Represents an application (type: payload, svelte-kit, golang)
- `Resource`: Represents infrastructure resources (postgres, s3, etc.)
- `Environment`: Environment-specific variables (dev, staging, production)
- `Project`: Top-level project metadata

Each app has:

- Build configuration (Dockerfile, port)
- Infrastructure configuration (provider, type, config)
- Environment variables (can reference resources, SOPS secrets, or plain values)
- Commands (build, lint, test, format) with sensible defaults per app type

#### internal/scaffold

Template rendering engine that:

- Generates files from Go templates embedded in `internal/templates/`
- Tracks all generated files in `.webkit/manifest.json`
- Supports two modes:
	- `ModeGenerate`: Always overwrites files
	- `ModeScaffold`: Only creates files if they don't exist
- Adds WebKit notices to generated files
- Tracks file hashes for drift detection

#### internal/manifest

Manages `.webkit/manifest.json` which tracks:

- All generated files and their paths
- What generated each file (e.g., "cicd.BackupWorkflow")
- What caused generation (e.g., "resource:postgres-prod")
- Content hashes (SHA256) for drift detection
- Whether files were scaffolded (user-editable) or generated (overwritable)

The manifest enables:

- Cleanup of orphaned files when manifest changes
- Drift detection via `webkit drift` command
- Idempotent updates (only regenerate changed files)

#### internal/infra

Terraform wrapper that:

- Generates `terraform.tfvars.json` from `app.json`
- Manages Terraform state via DigitalOcean Spaces backend
- Handles `plan`, `apply`, `destroy` commands
- Imports existing resources into Terraform state
- Converts app.json structure to Terraform variables

Key insight: Terraform modules live in `platform/terraform/` and are versioned separately. The CLI
references them via GitHub releases.

#### internal/secrets

SOPS/Age integration for secrets management:

- Encrypts/decrypts `.env.{environment}.enc` files
- Resolves environment variables at build time
- Supports three variable sources:
	- `value`: Plain text values
	- `sops`: Encrypted secrets from SOPS files
	- `resource`: Values from Terraform outputs (e.g., database URLs)

#### internal/cmd

CLI command implementations using urfave/cli/v3:

- `update`: Main command - regenerates all files from app.json
- `secrets`: Manage SOPS encryption
- `env`: Generate .env files for environments
- `infra`: Terraform operations (plan, apply, destroy, import)
- `cicd`: Generate GitHub Actions workflows
- `drift`: Detect files that have changed since generation
- `docs`: Generate documentation

### Terraform Module Structure

The `platform/terraform/` directory contains:

- `base/`: Base Terraform configuration
- `modules/`: Orchestration modules
	- `apps/`: Module for deploying applications
	- `resources/`: Module for provisioning resources
- `providers/`: Provider-specific implementations
	- `digital_ocean/`: DigitalOcean resources (app, droplet, postgres, bucket, domain_record)
	- `b2/`: Backblaze B2 storage

The CLI generates `terraform.tfvars.json` from `app.json`, which is consumed by these modules.

### Template System

Templates live in `internal/templates/` with the following structure:

- `.github/`: GitHub Actions workflow templates
- `docs/`: Documentation templates
- `terraform/`: Terraform configuration templates
- Various project file templates (.gitignore, package.json, etc.)

Templates use Go's `text/template` with custom functions defined in `internal/templates/funcs.go`.
Common template helpers:

- `toJSON`: Convert to JSON
- `kebabCase`: Convert string to kebab-case
- `snakeCase`: Convert string to snake_case
- `camelCase`: Convert string to camelCase

## Important Patterns

### Idempotent Updates

The `webkit update` command is designed to be run repeatedly. It:

1. Reads the old manifest from `.webkit/manifest.json`
2. Generates all files based on current `app.json`
3. Writes new manifest
4. Cleans up orphaned files (files in old manifest but not new manifest)

### File Tracking

Every generated file is tracked with:

- Generator name (for debugging)
- Source (what in app.json caused this)
- Content hash (for drift detection)
- Scaffold mode flag (determines if file should be overwritten)

Use `WithTracking()` option when calling scaffold methods:

```go
gen.Template(path, tpl, data,
    scaffold.WithTracking("cicd.DeployWorkflow", "app:web"),
    scaffold.WithMode(scaffold.ModeGenerate),
)
```

### Environment Variable Resolution

Variables can have three sources:

1. `value`: Static string (e.g., `"http://localhost:3000"`)
2. `sops`: Encrypted secret key (e.g., "PAYLOAD_SECRET")
3. `resource`: Terraform output path (e.g., "db.connection_url")

The resolution happens at different times:

- `value`: Resolved immediately
- `sops`: Resolved during `webkit env generate`
- `resource`: Resolved during Terraform apply and exposed as outputs

## Testing

Tests use standard Go testing with:

- `testify/assert` for assertions
- `spf13/afero` for filesystem mocking
- `go.uber.org/mock` for interface mocking (generated via `mockgen`)

When testing scaffold/manifest functionality, use `afero.NewMemMapFs()` to avoid touching real
filesystem.

## Release Process

1. Create and push a git tag using `pnpm tag` (interactive)
2. GitHub Actions triggers GoReleaser workflow
3. GoReleaser builds binaries for all platforms
4. Binaries are attached to GitHub release

For npm packages in `packages/`:

1. Use Changesets: `pnpm changeset`
2. Create PR with changeset
3. When merged, Changesets action creates release PR
4. Merge release PR to publish packages

## Key Files

- `app.json`: User's manifest file (not tracked in this repo, but lives in user projects)
- `.webkit/manifest.json`: Tracks all generated files
- `.env.{env}.enc`: SOPS-encrypted environment variables
- `go.mod`: Go 1.25.3, uses urfave/cli/v3, sprig for templates, terraform-exec
- `package.json`: pnpm workspace with scripts for dev workflow
- `Makefile`: Setup script for installing dependencies

## Working with Terraform

When modifying Terraform generation:

1. Update structs in `internal/infra/tf_vars.go`
2. Update corresponding Terraform variables in `platform/terraform/`
3. Test with playground app: `cd internal/playground && webkit update`
4. Verify generated `terraform.tfvars.json`

## Common Patterns

### Adding a New Command

1. Create package in `internal/cmd/yourcommand/`
2. Define `var Command = &cli.Command{...}`
3. Add to commands list in `internal/cmd/cli.go`
4. Add tests in `yourcommand_test.go`

### Adding a New Template

1. Add template file to `internal/templates/`
2. Update `internal/templates/embed.go` if needed
3. Create generator function in relevant cmd package
4. Use scaffold.WithTracking() to track generated file

### Adding a New Resource Type

1. Define type in `internal/appdef/resource.go`
2. Add provider implementation in `platform/terraform/providers/{provider}/{type}/`
3. Update `internal/infra/tf_vars.go` to generate correct tfvars
4. Add to resources module in `platform/terraform/modules/resources/`

## Content

### Language and style

Write all content in British English. Use British spellings and punctuation throughout the codebase:

- "colour" not "color"
- "organised" not "organized"
- "centre" not "center"

### Heading style

Headings should use sentence case (only the first word capitalised):

- Correct: "Setting up webhooks"
- Incorrect: "Setting Up Webhooks"
- Incorrect: "Setting up Webhooks"

## Markdown

- Use `-` for lists, not `*`.
- End list points with a full stop.
## HTML


### Validity

All HTML should be using the [Markup Validation Service](https://validator.w3.org/) before creating a pull request or
pushing to production. This will help avoid common mistakes such as closing tags, wrong attributes and many more.

By validating HTML it ensures that web pages are consistent across multiple devices and platforms and increases the
chance of search engines properly passing markup.

### Indentation

Use tabs instead of spaces for markup. Do not mix tabs with spaces and ensure it is properly formatted.

**Avoid**

```html
<ul>
	<li>List Item</li>
</ul>
```

**Prefer**

```html
<ul>
	<li>List Item</li>
</ul>
```

### Quotes

Always use double quotes around attribute values. Emitting quotes can prevent bad readability, despite HTML allowing for
attributes without quotes.

**Avoid**

```html
<button class="button button-grey">My Button</button>
```

**Prefer**

```html
<button class=button disabled>My Button</button>
```

### Line breaking

Break long lines when it exceeds the number of characters within the editor.

It is also recommended to ensure that the closing tag is on a new line. This helps to locate the closing tag and
improves readability.

**Avoid**

```html
<p>I'm baby blue bottle tilde godard, blog ennui pour-over craft beer. Pabst chartreuse iceland, bespoke next level
	migas hoodie lyft flannel. Kale chips literally chillwave, cred occupy tofu photo booth kitsch marxism before they
	sold out unicorn bicycle rights roof party. </p>
```

**Prefer**

```html
<p>
	I'm baby blue bottle tilde godard, blog ennui pour-over craft beer. Pabst chartreuse iceland, bespoke next level
	migas hoodie lyft flannel. Kale chips literally chillwave, cred occupy tofu photo booth kitsch marxism before they
	sold out unicorn bicycle rights roof party.
</p>
```

### Letter-casing

All attribute names, classes and IDs should be lower case and with a hyphen between two words (kebab case).

**Avoid**

```html
<h1 class="heading_Test"></h1>
<P Class="LEAD"></P>
```

**Prefer**

```html
<h1 class="hero-heading"></h1>
<p class="lead"></P>
```

### Self closing

All self closing elements should contain `/` at the end of the tag. Please
see [this](https://www.scaler.com/topics/self-closing-tags-in-html/) article for a definition of all HTML elements with
self closing elements.

**Avoid**

```html
<img src="my-image.jpg">
```

**Prefer**

```html
<img src="my-image.jpg"/>
```


## SCSS


### Directory Structure

Organise SCSS files into a clear hierarchy:

```text
scss/
├── abstracts/        # Variables, functions, mixins
│   ├── _colours.scss
│   ├── _breakpoints.scss
│   ├── _sizes.scss
│   ├── _tokens.scss
│   ├── _mixins.scss
│   └── _functions.scss
├── base/             # Global styles
│   ├── _reset.scss
│   ├── _root.scss
│   ├── _fonts.scss
│   ├── _global.scss
│   └── _typography.scss
├── components/       # Component styles
└── util/             # Utility styles
└── app.scss          # Entry point
```

### Key Patterns

- **Use `@use` instead of `@import`**: Import abstracts with aliases (e.g., `@use '../scss/abstracts' as a;`).
- **Variable naming**: Use kebab-case (e.g., `$section-75`, `$border-radius-4`).
- **CSS variable naming**: Use `--kebab-case` (e.g., `--token-text-heading`).
- **Parent selector**: Use `$self: &;` for compound selectors.
- **Nesting**: Nest related modifiers but avoid deep nesting (max 3 levels).

### Breakpoint Mixins

Use breakpoint mixins for responsive design:

```scss
@use '../abstracts' as a;

.component {
	font-size: 16px;

	@include a.mq(tab) {
		font-size: 18px;
	}

	@include a.mq(desk) {
		font-size: 20px;
	}
}
```

### Colour System

Define colours as maps and generate CSS variables:

```scss
$colours: (
	'red': (
		'50': #fef2f2,
		'500': #ef4444,
		'900': #7f1d1d,
	),
	'blue': (
		'50': #eff6ff,
		'500': #3b82f6,
		'900': #1e3a8a,
	),
)

// Used in :root as CSS variables
--colour-red-50: #fef2f2;
--colour-blue-500: #3b82f6;
```

### Scoped Component Styles

When using component-scoped SCSS in Svelte:

```svelte
<style lang="scss">
	@use '../scss/abstracts' as a;

	.btn-card {
		padding: a.$spacing-4;
		border-radius: a.$border-radius-2;

		&--dark-mode {
			background: var(--colour-grey-900);
			color: var(--colour-white);
		}
	}
</style>
```



### Component Styling Pattern

Use BEM-inspired modifiers with parent selector:

```scss
@use '../scss/abstracts' as a;

.section {
	$self: &;
	position: relative;

	&-padding {
		padding-block: a.$section-75;

		&#{$self}-small {
			padding-block: a.$section-50;
		}

		&#{$self}-large {
			padding-block: a.$section-100;
		}
	}

	&-padding-top {
		padding-top: a.$section-75;

		&#{$self}-small {
			padding-top: a.$section-50;
		}
	}
}
```


## Go


### Code Style

- **Formatting**: Use `gofmt` for standard Go formatting.
- **File naming**: snake_case for files, test files end with `_test.go`.
	- Integration tests use `_integration_test.go`
- **Generated files**: `*.gen.go` files are auto-generated - do not edit.
- **Error handling**: Always check and handle errors appropriately.
- **Imports**: Standard library, third-party, then internal imports.

### Interfaces and Abstraction

- Keep interfaces small and focused (single responsibility).
- Prefer returning concrete types unless abstraction is required for testing or swapping implementations.
- Document interface expectations explicitly (e.g. 'implementations must be thread-safe').

### Defining Types

- Keep structs small and cohesive; split if too many responsibilities.
- Prefer to use the `type` keyword once for multiple type declarations.

**Example**

```go
type (
	// Environment contains env-specific variable configurations.
	Environment struct {
		Dev        EnvVar `json:"dev,omitempty"`
		Staging    EnvVar `json:"staging,omitempty"`
		Production EnvVar `json:"production,omitempty"`
	}
	// EnvVar is a map of variable names to their configurations.
	EnvVar map[string]EnvValue
	// EnvValue represents a single env variable configuration
	EnvValue struct {
		Source EnvSource `json:"source"`          // See below
		Value  any       `json:"value,omitempty"` // Used for "value" and "resource" sources
		Path   string    `json:"path,omitempty"`  // Used for "sops" source (format: "key")
	}
)
```

### Naming Conventions

- **Integration tests**: End with `_integration_test.go`.
- **Generated files**: `*.gen.go` files are auto-generated - do not edit.
- **Interfaces**: Often end in `-er` suffix (e.g., `Reader`, `Writer`, `Store`).
- **Package names**: Short, lowercase, single-word names when possible.



- Document all exported types, functions and constants with Go doc comments.
- All comments must end with a full stop, including inline comments and multi-line comments.
- Within function bodies, only keep comments that explain _why_ something is done, not _what_ is
  done. The code itself should be clear enough to show what it does.
- Keep high-level comments that explain the flow or purpose of a section (e.g., 'Try loading
  template file first', 'Fallback to static markdown file').
- Remove obvious comments that just restate the code (e.g., "Load base template" before a
  `LoadTemplate()` call).

**Example:**

```go
// Generator handles file scaffolding operations for WebKit projects.
type Generator interface {
	// Bytes writes raw bytes to a file with optional configuration.
	//
	// Returns an error when  the file failed to write.
	Bytes(path string, data []byte, opts ...Option) error
}
```



### Context

Use `context.Context` as the first parameter for functions that perform I/O or can be cancelled.

**Example:**

```go
    func Run(ctx context.Context, cmd Command) (Result, error) {
	select {
		case <-ctx.Done():
			return Result{}, ctx.Err()
		default:
			// Execute command
	}
}
```



Constructors must validate all required dependencies using `enforce` helpers and return pointer
types. Only to be used in the context of when being called from a `cmd` package.
 ### New

- Prefer `NewX()` constructors over global initialisation unless, it's the only constructor in the package then it will
  be written as `New()`.

### Enforce

- Not nil values → `enforce.NotNil()`
- Boolean conditions → `enforce.True()`
- Equality / inequality → `enforce.Equal()` or `enforce.NotEqual()`
- Absence of error → `enforce.NoError()`

These helpers provide simple runtime guarantees and will exit the program with a helpful message if
a condition fails.

This package can be found in `github.com/ainsleydev/webkit/pkg`.

**Example:**

```go
func NewGenerator(fs afero.Fs, manifest *manifest.Tracker, printer *printer.Console) *FileGenerator {
	enforce.NotNil(fs, "file system is required")
	enforce.NotNil(manifest, "manifest is required")
	enforce.NotNil(printer, "printer is required")

	return &FileGenerator{
		Printer:  printer,
		fs:       fs,
		manifest: manifest,
	}
}
```

### Context

Use `context.Context` as the first parameter for functions that perform I/O or can be cancelled.

**Example:**

```go
    func Run(ctx context.Context, cmd Command) (Result, error) {
	select {
		case <-ctx.Done():
			return Result{}, ctx.Err()
		default:
			// Execute command
	}
}
```



### Maps Over Switch

Prefer using maps with function values over switch statements when dispatching based on string or integer keys. This
approach is more maintainable, extensible and testable.

**Prefer**

```go
type handlerFunc func (input Request) (Response, error)

var handlers = map[string]handlerFunc{
	"create": handleCreate,
	"update": handleUpdate,
	"delete": handleDelete,
}

func dispatch(action string, req Request) (Response, error) {
	handler, exists := handlers[action]
	if !exists {
		return Response{}, fmt.Errorf("unknown action: %s", action)
	}
	return handler(req)
}
```

**Avoid**

```go
func dispatch(action string, req Request) (Response, error) {
	switch action {
		case "create":
			return handleCreate(req)
		case "update":
			return handleUpdate(req)
		case "delete":
			return handleDelete(req)
		default:
			return Response{}, fmt.Errorf("unknown action: %s", action)
	}
}
```

### Exceptions

- Type switches (`switch v := value.(type)`) are appropriate for type assertions.
- Switch statements are acceptable when matching on complex conditions or ranges.
- Small, simple switches (2-3 cases) where a map would add unnecessary complexity.



- Always check errors, never ignore them with `_` unless absolutely necessary.
- If ignoring an error, add a comment explaining why.
- Return errors up the stack; don't just log and continue unless appropriate.
- Always prioritise clarity over depth of stack trace — add context that helps debugging, not repetition.

### Domain Error Types

Define custom errors to give context and allow type-based handling, rather than using generic `fmt.Errorf`. Use custom
errors only when it makes sense—for domain-specific cases where inspecting or handling by type is useful.

**Example:**

```go
type ErrInsufficientBalance struct {
    Amount float64
}

func (e ErrInsufficientBalance) Error() string {
    return fmt.Sprintf("insufficient balance: need %.2f", e.Amount)
}

// Usage
if balance < withdrawAmount {
    return ErrInsufficientBalance{Amount: withdrawAmount}
}
```

### Using errors.Wrap

Always use `errors.Wrap` from `github.com/pkg/errors` for adding context to errors. Use `fmt.Errorf`
if there is more than one argument that's not an error.

i.e. you can use `fmt.Errorf`, but only when needing to format.

**Example:**

```go
func LoadConfig(fs afero.Fs, path string) (*Config, error) {
	data, err := afero.ReadFile(fs, path)
	if err != nil {
		return nil, errors.Wrap(err, "reading config file")
	}
	return parseConfig(data)
}

func ValidatePort(port int) error {
	if port < 1024 || port > 65535 {
		return fmt.Errorf("invalid port %d: must be between 1024 and 65535", port)
	}
	return nil
}
```



All Go tests should be written in one of two ways:

1. As a test table, or
2. As individual `t.Run` subtests
   Use **test tables** for most cases.
   Use [**`t.Run`**](http://t.Run) **subtests** when:

- The number of input arguments in the test table exceeds **3**, or
- The complexity of assertions increases (we should **never** use `if` statements in test tables), or
- Individual test cases require unique setup logic that would need a setup function in the test
  table.

### General Rules

- Always call `t.Parallel()` at the top of every test function and within each subtest, unless:
	- It's an integration test (files ending in `_integration_test.go`).
	- It performs file I/O, shell commands, or interacts with SOPS or the OS files
	- Has the potential to fail with `--race` .
- Always use `t.Context()` when a `context.Context` is required in tests instead of
  `context.Background()`.
- All assertions should use the `assert` (and `require` when necessary) library.
- Prefer one assertion per test when possible.
- Never use `else` blocks — use assert logic instead.
- Never redeclare variables like `test := test` (variable shadowing).
- Use `got` as the variable name for actual results when comparing against expected values.
- Test names should:
	- Start with a capitalised first word,
	- Use spaces between words,
	- Not use the full title case (e.g., `"Payload default"`, `"GoLang explicit true"`).
- Always include all relevant test cases, even edge or error conditions.
- If 100% coverage is not possible, explain _why_ in a brief note above the test function (no inline
  comments).

### Test Organisation

- **One test function per exported function/method** — add new test cases as subtests within the
  existing test function rather than creating separate test functions.
- Only create a new test function if:
	- Testing a distinctly different aspect that warrants complete separation (e.g.,
	  `TestTracker_Add` vs `TestTracker_Save`).
	- The original test function would become unwieldy (>200 lines) with the addition.
- Group related test cases using descriptive subtest names that explain what's being tested.
- Aim for comprehensive coverage within each test function rather than fragmenting tests across
  multiple functions.

### Test Tables

The test should be:

- In a `map[string]struct{}` format. Where the string is the name of the test.
- The test loop should read: for `name, test := range tt` whereby the `name` of the test table
  variable is `tt`
- Use consistent field names:
	- `input` for inputs
	- `want` for expected outputs
	- `wantErr` if the function returns an error
- For error assertions, write:

```go
assert.Equal(t, test.wantErr, err != nil)
```

- Avoid `if`, `switch`, or branching logic inside the test loop.
- Don't add any code comments within the test unless explaining the why.

**Example:**

```go
func TestExample(t *testing.T) {
	t.Parallel()

	tt := map[string]struct {
		input string
		want  string
	}{
		"Example Case": {input: "foo", want: "bar"},
	}

	for name, test := range tt {
		t.Run(name, func (t *testing.T) {
			t.Parallel()
			got := DoSomething(test.input)
			assert.Equal(t, test.want, got)
		})
	}
}
```

### Subtests with `t.Run`

- Use `require` for preconditions (e.g. setup or function calls that must not fail).
- Use `assert` for validation of expected outputs.
- Use `t.Log()` to describe sections within a subtest instead of comments if assertions are bigger.
- Maintain **readability and determinism** — tests should clearly convey intent and run
  independently.
- Each test should be self-contained with no shared mutable state.

**Example:**

```go
func TestApp_OrderedCommands(t *testing.T) {
	t.Parallel()

	t.Run("Missing Skipped", func (t *testing.T) {
		t.Parallel()

		app := &App{Commands: map[Command]CommandSpec{}}
		commands := app.OrderedCommands()
		assert.Len(t, commands, 0)
	})

	t.Run("Default Populated", func (t *testing.T) {
		t.Parallel()

		app := &App{}
		err := app.applyDefaults()
		require.NoError(t, err)

		commands := app.OrderedCommands()
		require.Len(t, commands, 4)
		assert.Equal(t, "format", commands[0].Name)
	})
}
```

### Mocking

Mocks should only be introduced when a test depends on an **external interface** or system
boundary — for example, Terraform execution, encryption providers or file I/O wrappers.

- Prefer fakes or real in-memory types where possible.
- Place generated mocks under `internal/mocks/` and prefix them with `Mock` (e.g.
  `MockInfraManager`).
- Clean up with `defer ctrl.Finish()` and avoid over-mocking.
- Use [`gomock`](https://pkg.go.dev/go.uber.org/mock/gomock) for creating mocks.
- Generate mocks into the `internal/mocks/` directory using the example below.

**Example:**

```bash
go tool go.uber.org/mock/mockgen -source=gen.go -destination ../mocks/fs.go -package=mocks
```

### Setup Functions

- If a test contains repeated setup logic (e.g., creating `App` instances, default values, or common
  test data), scan for a `setup(t)` function.
- If no `setup(t)` function exists, **create one** to encapsulate reusable logic.
- The `setup(t)` function should:
	- Accept `t *testing.T` as an argument.
	- Return any values required by multiple subtests (e.g., test structs, default app objects).
	- Call `t.Helper()` at the start.
- Use `setup(t)` in subtests to maintain readability, avoid duplication and keep each test
  self-contained.

```go
func setup(t *testing.T) *App {
	t.Helper()

	app := &App{Name: "web", Type: AppTypeGoLang, Path: "./"}
	err := app.applyDefaults()
	require.NoError(t, err)

	return app
}

func TestApp_OrderedCommands(t *testing.T) {
	t.Parallel()

	t.Run("Default Populated", func (t *testing.T) {
		t.Parallel()

		app := setup(t)
		commands := app.OrderedCommands()
		require.Len(t, commands, 4)
		assert.Equal(t, "format", commands[0].Name)
	})
}


## JS


### Code Style

- Use `camelCase` for all field names and variables.
- Prefer named exports over default exports.
- Use TypeScript's strict mode.
- Place types co-located with implementation files.

### Naming Conventions

- **Types/Interfaces**: Use `PascalCase` (e.g., `UserService`, `ClientForm`).
- **Variables/Functions**: Use `camelCase` (e.g., `userService`, `getConfig`).
- **Constants**: Use `UPPER_SNAKE_CASE` or `camelCase` depending on export type.
- **Files**: Use `kebab-case` for directories, `PascalCase` for components/classes, `camelCase` for utilities.
- **React Components**: Use `PascalCase` (e.g., `ButtonCard.tsx`).
- **Test files**: End with `.test.ts` for unit tests, `.int.spec.ts` for integration tests.

### Type Imports

Use the `type` keyword for type-only imports to clearly distinguish types from values:

```typescript
import type { CollectionConfig, Config } from 'payload'
import { cacheHookCollections } from './plugin/hooks.js'
import type { PayloadHelperPluginConfig } from './types.js'
```

### Documentation

- Document all exported functions with JSDoc comments.
- Explain the purpose and parameters of functions.
- Use `@param` and `@returns` tags for clarity.

**Example:**

```typescript
/**
 * Generates an alphanumeric random string.
 * @param {number} length - The length of the string to generate
 * @returns {string} The generated random string
 */
export const generateRandomString = (length: number): string => {
	let result = ''
	while (result.length < length) {
		result += (Math.random() + 1).toString(36).substring(2)
	}
	return result.substring(0, length)
}
```

### Utility Functions

- Write pure functions with no side effects.
- Follow single responsibility principle.
- Always provide type annotations on parameters and return types.



### Test Framework

- Use **Vitest** for unit and integration tests.
- Use **Playwright** for end-to-end tests.
- Use **Testing Library** for component testing.

### Test Organisation

- Use `describe` blocks for test suites.
- Use descriptive test names that explain what's being tested.
- Follow Arrange-Act-Assert pattern.
- Group related tests together.

### Test Naming Convention

- `*.test.ts` - Unit tests
- `*.int.spec.ts` - Integration tests
- `*.e2e.spec.ts` - End-to-end tests

### Writing Tests

**Example:**

```typescript
import { describe, test, expect } from 'vitest'
import { ListingParams, SKIP_FILTER } from './ListingParams'

describe('ListingParams', () => {
	const params: ListingParamArgs = {
		manufacturers: [1],
		models: [10],
		parts: [99],
		eras: [2010],
		searchTerm: 'test-search',
	}

	test('serialises params to query string', () => {
		const qs = ListingParams.toSearchParams(params).toString()
		expect(qs).toContain('manufacturers=1')
		expect(qs).toContain('models=10')
	})

	test('parses query string back to params', () => {
		const qs = 'manufacturers=1&models=10&parts=99'
		const parsed = ListingParams.fromQueryString(qs)
		expect(parsed.manufacturers).toEqual([1])
	})

	test('round-trip with SKIP_FILTER values', () => {
		const original: ListingParamArgs = {
			manufacturers: [5],
			models: [SKIP_FILTER],
		}

		const qs = ListingParams.toSearchParams(original).toString()
		const parsed = ListingParams.fromQueryString(qs)

		expect(parsed.manufacturers).toEqual([5])
		expect(parsed.models).toEqual([SKIP_FILTER])
	})

	test('handles missing params gracefully', () => {
		const minimal: ListingParamArgs = { vehicleId: 1 }
		const qs = ListingParams.toSearchParams(minimal).toString()
		expect(qs).toContain('vehicle=1')
		expect(qs).not.toContain('models=')
	})
})
```

### Best Practices

- Test behaviour, not implementation details.
- Use meaningful test names.
- Keep tests simple and focused.
- Avoid test interdependencies.
- Test edge cases and error conditions.
- Use round-trip testing for serialisation/deserialisation logic.


## Git


Follow a conventional commit format with a type prefix and present tense gerund (doing words):

#### Format

```
<type>: <description>
```

#### Types

- `feat:` - Adding new features or functionality.
- `fix:` - Fixing bugs or issues.
- `chore:` - Updating dependencies, linting or other maintenance tasks.
- `style:` - Refactoring code or improving code style (no functional changes).
- `test:` - Adding or updating tests.
- `docs:` - Updating documentation.

#### Examples

```txt
feat: Adding SOPS encryption support
fix: Resolving Terraform state lock issue
chore: Updating Go dependencies
style: Refactoring manifest loader for clarity
test: Adding integration tests for scaffold command
docs: Updating README with installation steps
```



Before submitting changes, verify the following:

### Branch Workflow

- [ ] Never push directly to `main` - always create a new branch.
- [ ] Branch names should be descriptive (e.g., `feature/add-sops-validation`, `fix/terraform-state-bug`).

### Verification Steps

Before committing, **always** run the following checks:

#### For Go Projects

**Run all tests**:

```bash
go test ./...
```

**Run linting and formatting**:

```bash
go fmt ./...
```

If both pass, proceed with the commit. If either fails, fix the issues before committing.

#### For JS Projects

**Run all tests**:

```bash
pnpm test
```

**Run linting and formatting**:

```bash
pnpm format && pnpm lint:fix
```

### General Checks

- [ ] Commit message follows the conventional commit format.
- [ ] No sensitive information (passwords, API keys, etc.) in the commit history.
- [ ] No large files accidentally committed (+50 mb)
- [ ] All new files have appropriate copyright/licence headers (if required).


