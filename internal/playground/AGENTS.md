<!-- Code generated by webkit; DO NOT EDIT. -->
# Agent Guidelines

This document provides guidelines for AI agents working on the WebKit codebase.

## Note For Humans

This is a living document that will improve as more people/agents use it over time. Every effort has
been made to keep the guidance in here as generic and reusable as possible. Please keep this in mind
with any future edits.

**Note**: Investigation summaries and debugging analysis should be displayed via UI only, not
committed to the repository.

## Content

### Language and style

Write all content in British English. Use British spellings and punctuation throughout the codebase:

- "colour" not "color"
- "organised" not "organized"
- "centre" not "center"

### Heading style

Headings should use sentence case (only the first word capitalised):

- Correct: "Setting up webhooks"
- Incorrect: "Setting Up Webhooks"
- Incorrect: "Setting up Webhooks"

## Markdown

- Use `-` for lists, not `*`.
- End list points with a full stop.

## Go

### Code Style

- **Language**: Go 1.25.3
- **Formatting**: Use `gofmt` for standard Go formatting.
- **File naming**: snake_case for files, test files end with `_test.go`.
	- Integration tests use `_integration_test.go`
- **Generated files**: `*.gen.go` files are auto-generated - do not edit.
- **Error handling**: Always check and handle errors appropriately.
- **Imports**: Standard library, third-party, then internal imports.

### Context

Use `context.Context` as the first parameter for functions that perform I/O or can be cancelled.

```go
    func Run(ctx context.Context, cmd Command) (Result, error) {
	select {
		case <-ctx.Done():
			return Result{}, ctx.Err()
		default:
			// Execute command
	}
}
```

### Commentary

- Document all exported types, functions, and constants with Go doc comments.
- Ensure that the comments convey the meaning behind the code, not just the what.
- Within function bodies, only keep comments that explain _why_ something is done, not _what_ is
  done. The code itself should be clear enough to show what it does.
- Keep high-level comments that explain the flow or purpose of a section (e.g., "Try loading
  template file first", "Fallback to static markdown file").
- Remove obvious comments that just restate the code (e.g., "Load base template" before a
  `LoadTemplate()` call).

**Example:**

```go
// Generator handles file scaffolding operations for WebKit projects.
type Generator interface {
	// Bytes writes raw bytes to a file with optional configuration.
	//
	// Returns an error when  the file failed to write.
	Bytes(path string, data []byte, opts ...Option) error
}
```

### Constructors

Constructors must validate all required dependencies using `enforce` helpers and return pointer
types. Only to be used in the context of when being called from a `cmd` package.

- Not nil values -> `enforce.NotNil()`
- Boolean conditions -> `enforce.True()`
- Equality / inequality -> `enforce.Equal()` or `enforce.NotEqual()`
- Absence of error -> `enforce.NoError()`

These helpers provide simple runtime guarantees and will exit the program with a helpful message if
a condition fails.

**Example:**

```go
func NewGenerator(fs afero.Fs, manifest *manifest.Tracker, printer *printer.Console) *FileGenerator {
	enforce.NotNil(fs, "file system is required")
	enforce.NotNil(manifest, "manifest is required")
	enforce.NotNil(printer, "printer is required")

	return &FileGenerator{
		Printer:  printer,
		fs:       fs,
		manifest: manifest,
	}
}
```

### Errors

- Always check errors, never ignore them with `_` unless absolutely necessary.
- If ignoring an error, add a comment explaining why.
- Return errors up the stack; don't just log and continue unless appropriate.
- Aways prioritise clarity over depth of stack trace — add context that helps debugging, not
  repetition.

#### Using `errors.Wrap`

Always use `errors.Wrap` from `github.com/pkg/errors` for adding context to errors. Use `fmt.Errorf`
if there are more than one argument that's not an error.

I.e. you can use `fmt.Errorf`, but only when needing to format.

**Example:**

```go
func LoadConfig(fs afero.Fs, path string) (*Config, error) {
	data, err := afero.ReadFile(fs, path)
	if err != nil {
		return nil, errors.Wrap(err, "reading config file")
	}
	return parseConfig(data)
}

func ValidatePort(port int) error {
	if port < 1024 || port > 65535 {
		return fmt.Errorf("invalid port %d: must be between 1024 and 65535", port)
	}
	return nil
}
```

### Tests

All Go tests should be written in one of two ways:

1. As a test table, or
2. As individual `t.Run` subtests
   Use **test tables** for most cases.
   Use [**`t.Run`**](http://t.Run) **subtests** when:

- The number of input arguments in the test table exceeds **3**, or
- The complexity of assertions increases (we should **never** use `if` statements in test tables), or
- Individual test cases require unique setup logic that would need a setup function in the test
  table.

#### General Rules

- Always call `t.Parallel()` at the top of every test function and within each subtest, unless:
	- It's an integration test (files ending in `_integration_test.go`).
	- It performs file I/O, shell commands, or interacts with SOPS or the OS files
	- Has the potential to fail with `--race` .
- Always use `t.Context()` when a `context.Context` is required in tests instead of
  `context.Background()`.
- All assertions should use the `assert` (and `require` when necessary) library.
- Prefer one assertion per test when possible.
- Never use `else` blocks — use assert logic instead.
- Never redeclare variables like `test := test` (variable shadowing).
- Use `got` as the variable name for actual results when comparing against expected values.
- Test names should:
	- Start with a capitalised first word,
	- Use spaces between words,
	- Not use the full title case (e.g., `"Payload default"`, `"GoLang explicit true"`).
- Always include all relevant test cases, even edge or error conditions.
- If 100% coverage is not possible, explain _why_ in a brief note above the test function (no inline
  comments).

#### Test Tables

The test should be:

- In a `map[string]struct{}` format. Where the string is the name of the test.
- The test loop should read: for `name, test := range tt` whereby the `name` of the test table
  variable is `tt`
- Use consistent field names:
	- `input` for inputs
	- `want` for expected outputs
	- `wantErr` if the function returns an error
- For error assertions, write:

```go
assert.Equal(t, test.wantErr, err != nil)
```

- Avoid `if`, `switch`, or branching logic inside the test loop.
- Don't add any code comments within the test unless explaining the why.

**Example:**

```go
func TestExample(t *testing.T) {
	t.Parallel()

	tt := map[string]struct {
		input string
		want  string
	}{
		"Example Case": {input: "foo", want: "bar"},
	}

	for name, test := range tt {
		t.Run(name, func (t *testing.T) {
			t.Parallel()
			got := DoSomething(test.input)
			assert.Equal(t, test.want, got)
		})
	}
}
```

#### Subtests with `t.Run`

- Use `require` for preconditions (e.g. setup or function calls that must not fail).
- Use `assert` for validation of expected outputs.
- Use `t.Log()` to describe sections within a subtest instead of comments if assertions are bigger.
- Maintain **readability and determinism** — tests should clearly convey intent and run
  independently.
- Each test should be self-contained with no shared mutable state.

**Example:**

```go
func TestApp_OrderedCommands(t *testing.T) {
	t.Parallel()

	t.Run("Missing Skipped", func (t *testing.T) {
		t.Parallel()

		app := &App{Commands: map[Command]CommandSpec{}}
		commands := app.OrderedCommands()
		assert.Len(t, commands, 0)
	})

	t.Run("Default Populated", func (t *testing.T) {
		t.Parallel()

		app := &App{}
		err := app.applyDefaults()
		require.NoError(t, err)

		commands := app.OrderedCommands()
		require.Len(t, commands, 4)
		assert.Equal(t, "format", commands[0].Name)
	})
}
```

### Mocking

Mocks should only be introduced when a test depends on an **external interface** or system
boundary — for example, Terraform execution, encryption providers, or file I/O wrappers.

- Prefer fakes or real in-memory types where possible.
- Place generated mocks under `internal/mocks/` and prefix them with `Mock` (e.g.
  `MockInfraManager`).
- Clean up with `defer ctrl.Finish()` and avoid over-mocking.

#### General Rules

- Use [`gomock`](https://pkg.go.dev/go.uber.org/mock/gomock) for creating mocks.
- Generate mocks into the `internal/mocks/` directory using below's example.

**Example:**

```bash
go tool go.uber.org/mock/mockgen -source=gen.go -destination ../mocks/fs.go -package=mocks
```

#### Setup Functions

- If a test contains repeated setup logic (e.g., creating `App` instances, default values, or common
  test data), scan for a `setup(t)` function.
- If no `setup(t)` function exists, **create one** to encapsulate reusable logic.
- The `setup(t)` function should:
	- Accept `t *testing.T` as an argument.
	- Return any values required by multiple subtests (e.g., test structs, default app objects).
	- Call `t.Helper()` at the start.
- Use `setup(t)` in subtests to maintain readability, avoid duplication, and keep each test
  self-contained.

```go
func setup(t *testing.T) *App {
	t.Helper()

	app := &App{Name: "web", Type: AppTypeGoLang, Path: "./"}
	err := app.applyDefaults()
	require.NoError(t, err)

	return app
}

func TestApp_OrderedCommands(t *testing.T) {
	t.Parallel()

	t.Run("Default Populated", func (t *testing.T) {
		t.Parallel()

		app := setup(t)
		commands := app.OrderedCommands()
		require.Len(t, commands, 4)
		assert.Equal(t, "format", commands[0].Name)
	})
}
```

## Typescript

- Use `camelCase` for all field names and variables.
- Prefer named exports over default exports.
- Use TypeScript's strict mode.
- Place types co-located with implementation files.

## Libraries

### Payload

- Use `camelCase` for all field names.
- Always include `admin.description` for Payload collections and fields.
- Collection slugs should be lowercase with hyphens (e.g., `'media'`, `'form-submissions'`).
- Use `type: 'point'` for focal point fields on images.
- Leverage helper functions from `payload-helper` package for common patterns.

### SvelteKit

- Follow SvelteKit's file-based routing conventions.

## Git

### Commit Messages

Follow a conventional commit format with a type prefix and present tense gerund (doing words):

#### Format

```
<type>: <description>
```

#### Types

- `feat:` - Adding new features or functionality.
- `fix:` - Fixing bugs or issues.
- `chore:` - Updating dependencies, linting, or other maintenance tasks.
- `style:` - Refactoring code or improving code style (no functional changes).
- `test:` - Adding or updating tests.
- `docs:` - Updating documentation.

#### Examples

```
feat: Adding SOPS encryption support
fix: Resolving Terraform state lock issue
chore: Updating Go dependencies
style: Refactoring manifest loader for clarity
test: Adding integration tests for scaffold command
docs: Updating README with installation steps
```

#### Guidelines

- Use present tense gerunds: "Adding", "Fixing", "Updating" (not "Add", "Fixed", "Updates").
- Keep the description concise and descriptive.
- Start the description with a capital letter.
- No full stop at the end of the message.
- Focus on what the commit does, not how it does it.

### Pre-Commit Checklist

Before submitting changes, agents should verify the following:

#### Branch workflow

- [ ] Never push directly to `main` - always create a new branch.
- [ ] Branch names should be descriptive (e.g., `feature/add-sops-validation`,
  `fix/terraform-state-bug`).

#### Verification steps

- [ ] All tests pass locally (run `go test ./...`).
- [ ] Code is properly formatted with `go fmt`.
- [ ] Generated files (`.gen.go`, manifest tracked files) were not manually edited.
- [ ] New exported types, functions, and constants have Go doc comments.
- [ ] Tests follow the test table or `t.Run` patterns described above.
- [ ] If adding new dependencies, ensure they're necessary and well-maintained.
