package manifest

import (
	"bytes"
	"testing"

	"github.com/spf13/afero"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/ainsleydev/webkit/internal/printer"
)

func TestCleanup(t *testing.T) {
	t.Parallel()

	t.Run("Scaffold Files Skipped", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()
		var buf bytes.Buffer
		console := printer.New(&buf)

		err := afero.WriteFile(fs, "user.env", []byte("content"), 0644)
		require.NoError(t, err)

		old := &Manifest{
			Files: map[string]FileEntry{
				"user.env": {
					ScaffoldMode: true,
				},
			},
		}

		mani := &Manifest{Files: map[string]FileEntry{}}

		err = Cleanup(fs, old, mani, console)
		assert.NoError(t, err)

		exists, err := afero.Exists(fs, "user.env")
		require.NoError(t, err)
		assert.True(t, exists, "scaffold mode files should not be removed")
	})

	t.Run("File Exists In New Manifest - Skip", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()
		var buf bytes.Buffer
		console := printer.New(&buf)

		err := afero.WriteFile(fs, "keep.txt", []byte("content"), 0644)
		require.NoError(t, err)

		old := &Manifest{
			Files: map[string]FileEntry{
				"keep.txt": {ScaffoldMode: false},
			},
		}

		mani := &Manifest{
			Files: map[string]FileEntry{
				"keep.txt": {ScaffoldMode: false},
			},
		}

		err = Cleanup(fs, old, mani, console)
		assert.NoError(t, err)

		exists, err := afero.Exists(fs, "keep.txt")
		require.NoError(t, err)
		assert.True(t, exists, "files in new manifest should not be removed")
	})

	t.Run("Remove Error", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()
		var buf bytes.Buffer
		console := printer.New(&buf)
		err := afero.WriteFile(fs, "orphaned.txt", []byte("old"), 0644)
		require.NoError(t, err)
		old := &Manifest{
			Files: map[string]FileEntry{
				"orphaned.txt": {ScaffoldMode: false},
			},
		}
		mani := &Manifest{Files: map[string]FileEntry{}}

		readOnlyFs := afero.NewReadOnlyFs(fs)

		err = Cleanup(readOnlyFs, old, mani, console)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "removing orphaned.txt")
	})

	t.Run("Remove Orphaned Files", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()
		var buf bytes.Buffer
		console := printer.New(&buf)

		err := afero.WriteFile(fs, "orphaned.txt", []byte("old"), 0644)
		require.NoError(t, err)

		old := &Manifest{
			Files: map[string]FileEntry{
				"orphaned.txt": {ScaffoldMode: false},
			},
		}

		mani := &Manifest{Files: map[string]FileEntry{}}

		err = Cleanup(fs, old, mani, console)
		assert.NoError(t, err)

		exists, err := afero.Exists(fs, "orphaned.txt")
		require.NoError(t, err)
		assert.False(t, exists, "orphaned files should be removed")

		output := buf.String()
		assert.Contains(t, output, "Removing orphaned: orphaned.txt")
		assert.Contains(t, output, "Removed: orphaned.txt")
	})
}

func TestDetectDrift(t *testing.T) {
	t.Parallel()

	t.Run("Scaffold Files Skipped", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()

		userFile1 := []byte("user managed file 1")
		userFile2 := []byte("user managed file 2")

		err := afero.WriteFile(fs, "user1.env", userFile1, 0644)
		require.NoError(t, err)
		err = afero.WriteFile(fs, "user2.env", userFile2, 0644)
		require.NoError(t, err)

		manifest := &Manifest{
			Files: map[string]FileEntry{
				"user1.env": {
					Hash:         HashContent(userFile1),
					ScaffoldMode: true,
				},
				"user2.env": {
					Hash:         HashContent(userFile2),
					ScaffoldMode: true,
				},
			},
		}

		// User modifies both files
		err = afero.WriteFile(fs, "user1.env", []byte("user modified content 1"), 0644)
		require.NoError(t, err)
		err = afero.WriteFile(fs, "user2.env", []byte("user modified content 2"), 0644)
		require.NoError(t, err)

		drifted := DetectDrift(fs, manifest)
		assert.Empty(t, drifted)
	})

	t.Run("FS Error", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()

		manifest := &Manifest{
			Files: map[string]FileEntry{
				"missing.txt": {
					Hash:         HashContent([]byte("content")),
					ScaffoldMode: false,
				},
				"deleted.txt": {
					Hash:         HashContent([]byte("deleted content")),
					ScaffoldMode: false,
				},
			},
		}

		drifted := DetectDrift(fs, manifest)
		assert.Empty(t, drifted)
	})

	t.Run("Mixed Drift Scenarios", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()

		// Setup various file types and states
		unchangedGenerated := []byte("# Generated by WebKit\npackage.json content")
		modifiedGenerated := []byte("# Generated by WebKit\noriginal terraform")
		unchangedScaffold := []byte("# User managed\nuser config")
		deletedGenerated := []byte("old generated file")

		// Create existing files
		err := afero.WriteFile(fs, ".github/workflows/ci.yml", unchangedGenerated, 0644)
		require.NoError(t, err)
		err = afero.WriteFile(fs, "infra/main.tf", modifiedGenerated, 0644)
		require.NoError(t, err)
		err = afero.WriteFile(fs, ".env.development", unchangedScaffold, 0644)
		require.NoError(t, err)
		// Note: deleted.txt is NOT created

		manifest := &Manifest{
			Files: map[string]FileEntry{
				".github/workflows/ci.yml": {
					Hash:         HashContent(unchangedGenerated),
					ScaffoldMode: false,
				},
				"infra/main.tf": {
					Hash:         HashContent(modifiedGenerated),
					ScaffoldMode: false,
				},
				".env.development": {
					Hash:         HashContent(unchangedScaffold),
					ScaffoldMode: true,
				},
				"deleted.txt": {
					Hash:         HashContent(deletedGenerated),
					ScaffoldMode: false,
				},
			},
		}

		// User modifies the terraform file.
		err = afero.WriteFile(fs, "infra/main.tf", []byte("# Generated by WebKit\nuser modified terraform"), 0644)
		require.NoError(t, err)

		// User modifies the scaffold file (should be ignored).
		err = afero.WriteFile(fs, "package.json", []byte("{ my-package.json }"), 0644)
		require.NoError(t, err)

		drifted := DetectDrift(fs, manifest)

		assert.Len(t, drifted, 1)
		assert.Contains(t, drifted, "infra/main.tf")
		assert.NotContains(t, drifted, ".github/workflows/ci.yml")
		assert.NotContains(t, drifted, "package.json")
		assert.NotContains(t, drifted, "deleted.txt")
	})
}

func TestHashContent(t *testing.T) {
	t.Parallel()

	t.Run("Empty Content", func(t *testing.T) {
		t.Parallel()

		got := HashContent([]byte{})
		assert.Equal(t, "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855", got)
	})

	t.Run("Consistent Hashing", func(t *testing.T) {
		t.Parallel()

		data := []byte("test content")
		hash1 := HashContent(data)
		hash2 := HashContent(data)

		assert.Equal(t, hash1, hash2)
	})

	t.Run("Different Content Different Hash", func(t *testing.T) {
		t.Parallel()

		hash1 := HashContent([]byte("content1"))
		hash2 := HashContent([]byte("content2"))
		assert.NotEqual(t, hash1, hash2)
	})

	t.Run("Known Hash Value", func(t *testing.T) {
		t.Parallel()

		data := []byte("hello world")
		got := HashContent(data)
		want := "b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9"
		assert.Equal(t, want, got)
	})
}
