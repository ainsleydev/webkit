package manifest

import (
	"testing"

	"github.com/spf13/afero"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestDriftReason_String(t *testing.T) {
	t.Parallel()

	tt := map[string]struct {
		input DriftReason
		want  string
	}{
		"Modified": {DriftReasonModified, "modified"},
		"Deleted":  {DriftReasonDeleted, "deleted"},
		"Unknown":  {DriftReason(999), "unknown"},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			t.Parallel()

			got := test.input.String()
			assert.Equal(t, test.want, got)
			assert.IsType(t, "", got)
		})
	}
}

func TestDetectDrift(t *testing.T) {
	t.Parallel()

	t.Run("Scaffold Files Skipped", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()

		userFile1 := []byte("user managed file 1")
		userFile2 := []byte("user managed file 2")

		err := afero.WriteFile(fs, "user1.env", userFile1, 0o644)
		require.NoError(t, err)
		err = afero.WriteFile(fs, "user2.env", userFile2, 0o644)
		require.NoError(t, err)

		manifest := &Manifest{
			Files: map[string]FileEntry{
				"user1.env": {
					Hash:         HashContent(userFile1),
					ScaffoldMode: true,
				},
				"user2.env": {
					Hash:         HashContent(userFile2),
					ScaffoldMode: true,
				},
			},
		}

		// User modifies both files
		err = afero.WriteFile(fs, "user1.env", []byte("user modified content 1"), 0o644)
		require.NoError(t, err)
		err = afero.WriteFile(fs, "user2.env", []byte("user modified content 2"), 0o644)
		require.NoError(t, err)

		drifted := DetectDrift(fs, manifest)
		assert.Empty(t, drifted)
	})

	t.Run("Deleted Files Detected", func(t *testing.T) {
		t.Parallel()
		fs := afero.NewMemMapFs()

		manifest := &Manifest{
			Files: map[string]FileEntry{
				"missing.txt": {
					Hash:         HashContent([]byte("content")),
					ScaffoldMode: false,
				},
				"deleted.txt": {
					Hash:         HashContent([]byte("deleted content")),
					ScaffoldMode: false,
				},
			},
		}

		drifted := DetectDrift(fs, manifest)

		assert.Len(t, drifted, 2)

		for _, file := range drifted {
			assert.Equal(t, DriftReasonDeleted, file.Reason)
			assert.Contains(t, []string{"missing.txt", "deleted.txt"}, file.Path)
		}
	})

	t.Run("Mixed Drift Scenarios", func(t *testing.T) {
		t.Parallel()
		fs := afero.NewMemMapFs()

		// Setup various file types and states
		unchangedGenerated := []byte("# Generated by WebKit\npackage.json content")
		modifiedGenerated := []byte("# Generated by WebKit\noriginal terraform")
		unchangedScaffold := []byte("# User managed\nuser config")
		deletedGenerated := []byte("old generated file")

		// Create existing files
		err := afero.WriteFile(fs, ".github/workflows/ci.yml", unchangedGenerated, 0o644)
		require.NoError(t, err)
		err = afero.WriteFile(fs, "infra/main.tf", modifiedGenerated, 0o644)
		require.NoError(t, err)
		err = afero.WriteFile(fs, ".env.development", unchangedScaffold, 0o644)
		require.NoError(t, err)
		// Note: deleted.txt is NOT created

		manifest := &Manifest{
			Files: map[string]FileEntry{
				".github/workflows/ci.yml": {
					Hash:         HashContent(unchangedGenerated),
					ScaffoldMode: false,
				},
				"infra/main.tf": {
					Hash:         HashContent(modifiedGenerated),
					ScaffoldMode: false,
				},
				".env.development": {
					Hash:         HashContent(unchangedScaffold),
					ScaffoldMode: true,
				},
				"deleted.txt": {
					Hash:         HashContent(deletedGenerated),
					ScaffoldMode: false,
				},
			},
		}

		// User modifies the terraform file
		err = afero.WriteFile(fs, "infra/main.tf", []byte("# Generated by WebKit\nuser modified terraform"), 0o644)
		require.NoError(t, err)

		// User modifies the scaffold file (should be ignored)
		err = afero.WriteFile(fs, ".env.development", []byte("user modified config"), 0o644)
		require.NoError(t, err)

		drifted := DetectDrift(fs, manifest)

		// Should detect: 1 modified file + 1 deleted file
		assert.Len(t, drifted, 2)

		// Find the modified and deleted files
		var modifiedFile, deletedFile *DriftedFile
		for i := range drifted {
			if drifted[i].Path == "infra/main.tf" {
				modifiedFile = &drifted[i]
			}
			if drifted[i].Path == "deleted.txt" {
				deletedFile = &drifted[i]
			}
		}

		// Verify modified file
		require.NotNil(t, modifiedFile)
		assert.Equal(t, "infra/main.tf", modifiedFile.Path)
		assert.Equal(t, DriftReasonModified, modifiedFile.Reason)

		// Verify deleted file
		require.NotNil(t, deletedFile)
		assert.Equal(t, "deleted.txt", deletedFile.Path)
		assert.Equal(t, DriftReasonDeleted, deletedFile.Reason)

		// Verify unchanged and scaffold files are not in drift
		for _, file := range drifted {
			assert.NotEqual(t, ".github/workflows/ci.yml", file.Path)
			assert.NotEqual(t, ".env.development", file.Path)
		}
	})

	t.Run("No Drift When All Files Match", func(t *testing.T) {
		t.Parallel()
		fs := afero.NewMemMapFs()

		content := []byte("unchanged content")

		err := afero.WriteFile(fs, "file1.txt", content, 0o644)
		require.NoError(t, err)
		err = afero.WriteFile(fs, "file2.txt", content, 0o644)
		require.NoError(t, err)

		manifest := &Manifest{
			Files: map[string]FileEntry{
				"file1.txt": {
					Hash:         HashContent(content),
					ScaffoldMode: false,
				},
				"file2.txt": {
					Hash:         HashContent(content),
					ScaffoldMode: false,
				},
			},
		}

		drifted := DetectDrift(fs, manifest)
		assert.Empty(t, drifted)
	})
}
