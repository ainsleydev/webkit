// Code generated by MockGen. DO NOT EDIT.
// Source: tf.go
//
// Generated by this command:
//
//	mockgen -source=tf.go -destination ./internal/tfmocks/tf.go -package=tfmocks
//

// Package tfmocks is a generated GoMock package.
package tfmocks

import (
	context "context"
	io "io"
	reflect "reflect"

	tfexec "github.com/hashicorp/terraform-exec/tfexec"
	tfjson "github.com/hashicorp/terraform-json"
	gomock "go.uber.org/mock/gomock"
)

// MockterraformExecutor is a mock of terraformExecutor interface.
type MockterraformExecutor struct {
	ctrl     *gomock.Controller
	recorder *MockterraformExecutorMockRecorder
	isgomock struct{}
}

// MockterraformExecutorMockRecorder is the mock recorder for MockterraformExecutor.
type MockterraformExecutorMockRecorder struct {
	mock *MockterraformExecutor
}

// NewMockterraformExecutor creates a new mock instance.
func NewMockterraformExecutor(ctrl *gomock.Controller) *MockterraformExecutor {
	mock := &MockterraformExecutor{ctrl: ctrl}
	mock.recorder = &MockterraformExecutorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockterraformExecutor) EXPECT() *MockterraformExecutorMockRecorder {
	return m.recorder
}

// Apply mocks base method.
func (m *MockterraformExecutor) Apply(ctx context.Context, opts ...tfexec.ApplyOption) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Apply", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Apply indicates an expected call of Apply.
func (mr *MockterraformExecutorMockRecorder) Apply(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Apply", reflect.TypeOf((*MockterraformExecutor)(nil).Apply), varargs...)
}

// Destroy mocks base method.
func (m *MockterraformExecutor) Destroy(ctx context.Context, opts ...tfexec.DestroyOption) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Destroy", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Destroy indicates an expected call of Destroy.
func (mr *MockterraformExecutorMockRecorder) Destroy(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Destroy", reflect.TypeOf((*MockterraformExecutor)(nil).Destroy), varargs...)
}

// Init mocks base method.
func (m *MockterraformExecutor) Init(ctx context.Context, opts ...tfexec.InitOption) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Init", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Init indicates an expected call of Init.
func (mr *MockterraformExecutorMockRecorder) Init(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Init", reflect.TypeOf((*MockterraformExecutor)(nil).Init), varargs...)
}

// Output mocks base method.
func (m *MockterraformExecutor) Output(ctx context.Context, opts ...tfexec.OutputOption) (map[string]tfexec.OutputMeta, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Output", varargs...)
	ret0, _ := ret[0].(map[string]tfexec.OutputMeta)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Output indicates an expected call of Output.
func (mr *MockterraformExecutorMockRecorder) Output(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Output", reflect.TypeOf((*MockterraformExecutor)(nil).Output), varargs...)
}

// Plan mocks base method.
func (m *MockterraformExecutor) Plan(ctx context.Context, opts ...tfexec.PlanOption) (bool, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Plan", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Plan indicates an expected call of Plan.
func (mr *MockterraformExecutorMockRecorder) Plan(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Plan", reflect.TypeOf((*MockterraformExecutor)(nil).Plan), varargs...)
}

// SetStderr mocks base method.
func (m *MockterraformExecutor) SetStderr(w io.Writer) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetStderr", w)
}

// SetStderr indicates an expected call of SetStderr.
func (mr *MockterraformExecutorMockRecorder) SetStderr(w any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetStderr", reflect.TypeOf((*MockterraformExecutor)(nil).SetStderr), w)
}

// SetStdout mocks base method.
func (m *MockterraformExecutor) SetStdout(w io.Writer) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetStdout", w)
}

// SetStdout indicates an expected call of SetStdout.
func (mr *MockterraformExecutorMockRecorder) SetStdout(w any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetStdout", reflect.TypeOf((*MockterraformExecutor)(nil).SetStdout), w)
}

// ShowPlanFile mocks base method.
func (m *MockterraformExecutor) ShowPlanFile(ctx context.Context, planPath string, opts ...tfexec.ShowOption) (*tfjson.Plan, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, planPath}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ShowPlanFile", varargs...)
	ret0, _ := ret[0].(*tfjson.Plan)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ShowPlanFile indicates an expected call of ShowPlanFile.
func (mr *MockterraformExecutorMockRecorder) ShowPlanFile(ctx, planPath any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, planPath}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ShowPlanFile", reflect.TypeOf((*MockterraformExecutor)(nil).ShowPlanFile), varargs...)
}

// ShowPlanFileRaw mocks base method.
func (m *MockterraformExecutor) ShowPlanFileRaw(ctx context.Context, planPath string, opts ...tfexec.ShowOption) (string, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, planPath}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ShowPlanFileRaw", varargs...)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ShowPlanFileRaw indicates an expected call of ShowPlanFileRaw.
func (mr *MockterraformExecutorMockRecorder) ShowPlanFileRaw(ctx, planPath any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, planPath}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ShowPlanFileRaw", reflect.TypeOf((*MockterraformExecutor)(nil).ShowPlanFileRaw), varargs...)
}
