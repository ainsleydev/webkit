package cmd

import (
	"fmt"
	"testing"

	"github.com/spf13/afero"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.uber.org/mock/gomock"

	"github.com/ainsleydev/webkit/internal/appdef"
	"github.com/ainsleydev/webkit/internal/manifest"
	"github.com/ainsleydev/webkit/internal/mocks"
)

func TestUpdate(t *testing.T) {
	t.Skip()
	t.Parallel()

	t.Run("No Previous Manifest", func(t *testing.T) {
		t.Parallel()

		input, buf := setupWithPrinter(t, afero.NewMemMapFs(), &appdef.Definition{})

		err := update(t.Context(), input)
		assert.NoError(t, err)
		assert.Contains(t, buf.String(), "Updating project dependencies...")
		assert.Contains(t, buf.String(), "Successfully updated project dependencies!")

		// Verify manifest was created
		mani, err := manifest.Load(input.FS)
		require.NoError(t, err)
		assert.NotNil(t, mani)
	})

	t.Run("Manifest Load Error", func(t *testing.T) {
		t.Parallel()

		mock := mocks.NewMockFS(gomock.NewController(t))
		mock.EXPECT().
			Open(gomock.Any()).
			Return(nil, fmt.Errorf("read error")).
			Times(1)

		input := setup(t, mock, &appdef.Definition{})

		err := update(t.Context(), input)
		assert.Error(t, err)
		assert.ErrorContains(t, err, "loading manifest")
	})

	t.Run("Operation Fails", func(t *testing.T) {
		t.Parallel()

		// Create a definition that will cause one of the operations to fail
		// by using invalid configuration
		def := &appdef.Definition{
			Apps: []appdef.App{
				{
					Name: "", // Invalid: empty name should cause validation error
					Path: "./app",
					Type: appdef.AppTypeGoLang,
				},
			},
		}

		input, _ := setupWithPrinter(t, afero.NewMemMapFs(), def)

		err := update(t.Context(), input)
		assert.Error(t, err)
	})

	t.Run("Manifest Save Error", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewReadOnlyFs(afero.NewMemMapFs())
		input, _ := setupWithPrinter(t, fs, &appdef.Definition{})

		err := update(t.Context(), input)
		assert.Error(t, err)
		assert.ErrorContains(t, err, "saving manifest")
	})

	t.Run("Cleanup Orphaned Files", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()
		input, buf := setupWithPrinter(t, fs, &appdef.Definition{})

		// Create an old manifest with a file entry
		oldManifest := manifest.NewTracker()
		oldManifest.Add(manifest.FileEntry{
			Path:         "old-file.txt",
			Source:       "test",
			Hash:         "abc123",
			ScaffoldMode: false,
		})
		err := oldManifest.Save(fs)
		require.NoError(t, err)

		// Create the actual file
		err = afero.WriteFile(fs, "old-file.txt", []byte("content"), 0o644)
		require.NoError(t, err)

		// Run update - the old-file.txt should be removed since it's not generated by any operation
		err = update(t.Context(), input)
		assert.NoError(t, err)

		// Verify the file was cleaned up
		exists, err := afero.Exists(fs, "old-file.txt")
		require.NoError(t, err)
		assert.False(t, exists, "orphaned file should be removed")

		assert.Contains(t, buf.String(), "Successfully updated project dependencies!")
	})

	t.Run("Preserves Scaffold Mode Files", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()
		input, _ := setupWithPrinter(t, fs, &appdef.Definition{})

		// Create an old manifest with a scaffold mode file
		oldManifest := manifest.NewTracker()
		oldManifest.Add(manifest.FileEntry{
			Path:         "user-managed.env",
			Source:       "test",
			Hash:         "abc123",
			ScaffoldMode: true,
		})
		err := oldManifest.Save(fs)
		require.NoError(t, err)

		// Create the actual file
		err = afero.WriteFile(fs, "user-managed.env", []byte("USER_VAR=value"), 0o644)
		require.NoError(t, err)

		// Run update
		err = update(t.Context(), input)
		assert.NoError(t, err)

		// Verify scaffold mode file was NOT removed
		exists, err := afero.Exists(fs, "user-managed.env")
		require.NoError(t, err)
		assert.True(t, exists, "scaffold mode file should be preserved")

		content, err := afero.ReadFile(fs, "user-managed.env")
		require.NoError(t, err)
		assert.Equal(t, "USER_VAR=value", string(content))
	})

	t.Run("All Operations Execute In Order", func(t *testing.T) {
		t.Parallel()

		input, buf := setupWithPrinter(t, afero.NewMemMapFs(), &appdef.Definition{})

		err := update(t.Context(), input)
		assert.NoError(t, err)

		output := buf.String()

		// Verify all operations are mentioned
		assert.Contains(t, output, "Env: Scaffold .env files")
		assert.Contains(t, output, "Secrets: Scaffold secret files")
		assert.Contains(t, output, "Files: Create code style files")
		assert.Contains(t, output, "Files: Create git settings")
		assert.Contains(t, output, "Files: Create package.json")
		assert.Contains(t, output, "Files: Create turbo.json")
		assert.Contains(t, output, "CICD: Create PR workflows")
		assert.Contains(t, output, "CICD: Create backup workflows")
		assert.Contains(t, output, "Env: Sync .env files")
		assert.Contains(t, output, "Secrets: Sync secret files")
	})

	t.Run("Successful Update With Previous Manifest", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()
		input, buf := setupWithPrinter(t, fs, &appdef.Definition{})

		// Create initial manifest
		oldManifest := manifest.NewTracker()
		oldManifest.Add(manifest.FileEntry{
			Path:   ".gitignore",
			Source: "files",
			Hash:   "initial-hash",
		})
		err := oldManifest.Save(fs)
		require.NoError(t, err)

		// Run update
		err = update(t.Context(), input)
		assert.NoError(t, err)

		// Verify success message
		assert.Contains(t, buf.String(), "Successfully updated project dependencies!")

		// Verify new manifest exists
		newManifest, err := manifest.Load(fs)
		require.NoError(t, err)
		assert.NotNil(t, newManifest)
		assert.NotEmpty(t, newManifest.Files)
	})

	t.Run("Cleanup Error Propagates", func(t *testing.T) {
		t.Parallel()

		ctrl := gomock.NewController(t)
		mockFS := mocks.NewMockFS(ctrl)

		// Allow initial manifest load to succeed
		mockFS.EXPECT().
			Open(manifest.Path).
			Return(nil, fmt.Errorf("not found")).
			Times(1)

		// All operations will try to create directories and files
		mockFS.EXPECT().
			MkdirAll(gomock.Any(), gomock.Any()).
			Return(nil).
			AnyTimes()
		mockFS.EXPECT().
			OpenFile(gomock.Any(), gomock.Any(), gomock.Any()).
			Return(&mockFile{}, nil).
			AnyTimes()
		mockFS.EXPECT().
			Stat(gomock.Any()).
			Return(nil, fmt.Errorf("not found")).
			AnyTimes()

		// Make the second manifest load (for cleanup) fail
		mockFS.EXPECT().
			Open(manifest.Path).
			Return(nil, fmt.Errorf("cleanup load error")).
			Times(1)

		input := setup(t, mockFS, &appdef.Definition{})

		err := update(t.Context(), input)
		assert.Error(t, err)
		assert.ErrorContains(t, err, "loading manifest")
	})
}

// mockFile is a simple mock for afero.File to satisfy OpenFile expectations
type mockFile struct {
	afero.File
}

func (m *mockFile) Write(p []byte) (n int, err error) {
	return len(p), nil
}

func (m *mockFile) Close() error {
	return nil
}

func TestUpdateOps_Ordering(t *testing.T) {
	t.Parallel()
	t.Skip()

	t.Run("Env Scaffold Is First", func(t *testing.T) {
		t.Parallel()
		assert.Equal(t, "Env: Scaffold .env files", updateOps[0].name)
	})

	t.Run("Secrets Scaffold Is Second", func(t *testing.T) {
		t.Parallel()
		assert.Equal(t, "Secrets: Scaffold secret files", updateOps[1].name)
	})

	t.Run("Env Sync Is Second To Last", func(t *testing.T) {
		t.Parallel()
		assert.Equal(t, "Env: Sync .env files", updateOps[len(updateOps)-2].name)
	})

	t.Run("Secrets Sync Is Last", func(t *testing.T) {
		t.Parallel()
		assert.Equal(t, "Secrets: Sync secret files", updateOps[len(updateOps)-1].name)
	})

	t.Run("All Operations Have Names", func(t *testing.T) {
		t.Parallel()
		for i, op := range updateOps {
			assert.NotEmpty(t, op.name, "operation at index %d should have a name", i)
			assert.NotNil(t, op.command, "operation at index %d should have a command", i)
		}
	})
}
