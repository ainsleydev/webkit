// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package cmd

import "encoding/json"
import "fmt"

type OptionsDefinition struct {
	// Include parentheses around a sole arrow function parameter.
	ArrowParens interface{} `json:"arrowParens,omitempty" yaml:"arrowParens,omitempty" mapstructure:"arrowParens,omitempty"`

	// Put > of opening tags on the last line instead of on a new line.
	BracketSameLine bool `json:"bracketSameLine,omitempty" yaml:"bracketSameLine,omitempty" mapstructure:"bracketSameLine,omitempty"`

	// Print spaces between brackets.
	BracketSpacing bool `json:"bracketSpacing,omitempty" yaml:"bracketSpacing,omitempty" mapstructure:"bracketSpacing,omitempty"`

	// Check whether the file's first docblock comment contains '@noprettier' or
	// '@noformat' to determine if it should be formatted.
	CheckIgnorePragma bool `json:"checkIgnorePragma,omitempty" yaml:"checkIgnorePragma,omitempty" mapstructure:"checkIgnorePragma,omitempty"`

	// Print (to stderr) where a cursor at the given position would move to after
	// formatting.
	CursorOffset int `json:"cursorOffset,omitempty" yaml:"cursorOffset,omitempty" mapstructure:"cursorOffset,omitempty"`

	// Control how Prettier formats quoted code embedded in the file.
	EmbeddedLanguageFormatting interface{} `json:"embeddedLanguageFormatting,omitempty" yaml:"embeddedLanguageFormatting,omitempty" mapstructure:"embeddedLanguageFormatting,omitempty"`

	// Which end of line characters to apply.
	EndOfLine interface{} `json:"endOfLine,omitempty" yaml:"endOfLine,omitempty" mapstructure:"endOfLine,omitempty"`

	// Where to print operators when binary expressions wrap lines.
	ExperimentalOperatorPosition interface{} `json:"experimentalOperatorPosition,omitempty" yaml:"experimentalOperatorPosition,omitempty" mapstructure:"experimentalOperatorPosition,omitempty"`

	// Use curious ternaries, with the question mark after the condition.
	ExperimentalTernaries bool `json:"experimentalTernaries,omitempty" yaml:"experimentalTernaries,omitempty" mapstructure:"experimentalTernaries,omitempty"`

	// Specify the input filepath. This will be used to do parser inference.
	Filepath *string `json:"filepath,omitempty" yaml:"filepath,omitempty" mapstructure:"filepath,omitempty"`

	// How to handle whitespaces in HTML.
	HtmlWhitespaceSensitivity interface{} `json:"htmlWhitespaceSensitivity,omitempty" yaml:"htmlWhitespaceSensitivity,omitempty" mapstructure:"htmlWhitespaceSensitivity,omitempty"`

	// Insert @format pragma into file's first docblock comment.
	InsertPragma bool `json:"insertPragma,omitempty" yaml:"insertPragma,omitempty" mapstructure:"insertPragma,omitempty"`

	// Use single quotes in JSX.
	JsxSingleQuote bool `json:"jsxSingleQuote,omitempty" yaml:"jsxSingleQuote,omitempty" mapstructure:"jsxSingleQuote,omitempty"`

	// How to wrap object literals.
	ObjectWrap interface{} `json:"objectWrap,omitempty" yaml:"objectWrap,omitempty" mapstructure:"objectWrap,omitempty"`

	// Which parser to use.
	Parser interface{} `json:"parser,omitempty" yaml:"parser,omitempty" mapstructure:"parser,omitempty"`

	// Add a plugin. Multiple plugins can be passed as separate `--plugin`s.
	Plugins []string `json:"plugins,omitempty" yaml:"plugins,omitempty" mapstructure:"plugins,omitempty"`

	// The line length where Prettier will try wrap.
	PrintWidth int `json:"printWidth,omitempty" yaml:"printWidth,omitempty" mapstructure:"printWidth,omitempty"`

	// How to wrap prose.
	ProseWrap interface{} `json:"proseWrap,omitempty" yaml:"proseWrap,omitempty" mapstructure:"proseWrap,omitempty"`

	// Change when properties in objects are quoted.
	QuoteProps interface{} `json:"quoteProps,omitempty" yaml:"quoteProps,omitempty" mapstructure:"quoteProps,omitempty"`

	// Format code ending at a given character offset (exclusive).
	// The range will extend forwards to the end of the selected statement.
	RangeEnd *int `json:"rangeEnd,omitempty" yaml:"rangeEnd,omitempty" mapstructure:"rangeEnd,omitempty"`

	// Format code starting at a given character offset.
	// The range will extend backwards to the start of the first line containing the
	// selected statement.
	RangeStart int `json:"rangeStart,omitempty" yaml:"rangeStart,omitempty" mapstructure:"rangeStart,omitempty"`

	// Require either '@prettier' or '@format' to be present in the file's first
	// docblock comment in order for it to be formatted.
	RequirePragma bool `json:"requirePragma,omitempty" yaml:"requirePragma,omitempty" mapstructure:"requirePragma,omitempty"`

	// Print semicolons.
	Semi bool `json:"semi,omitempty" yaml:"semi,omitempty" mapstructure:"semi,omitempty"`

	// Enforce single attribute per line in HTML, Vue and JSX.
	SingleAttributePerLine bool `json:"singleAttributePerLine,omitempty" yaml:"singleAttributePerLine,omitempty" mapstructure:"singleAttributePerLine,omitempty"`

	// Use single quotes instead of double quotes.
	SingleQuote bool `json:"singleQuote,omitempty" yaml:"singleQuote,omitempty" mapstructure:"singleQuote,omitempty"`

	// Number of spaces per indentation level.
	TabWidth int `json:"tabWidth,omitempty" yaml:"tabWidth,omitempty" mapstructure:"tabWidth,omitempty"`

	// Print trailing commas wherever possible when multi-line.
	TrailingComma interface{} `json:"trailingComma,omitempty" yaml:"trailingComma,omitempty" mapstructure:"trailingComma,omitempty"`

	// Indent with tabs instead of spaces.
	UseTabs bool `json:"useTabs,omitempty" yaml:"useTabs,omitempty" mapstructure:"useTabs,omitempty"`

	// Indent script and style tags in Vue files.
	VueIndentScriptAndStyle bool `json:"vueIndentScriptAndStyle,omitempty" yaml:"vueIndentScriptAndStyle,omitempty" mapstructure:"vueIndentScriptAndStyle,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OptionsDefinition) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain OptionsDefinition
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["arrowParens"]; !ok || v == nil {
		plain.ArrowParens = "always"
	}
	if v, ok := raw["bracketSameLine"]; !ok || v == nil {
		plain.BracketSameLine = false
	}
	if v, ok := raw["bracketSpacing"]; !ok || v == nil {
		plain.BracketSpacing = true
	}
	if v, ok := raw["checkIgnorePragma"]; !ok || v == nil {
		plain.CheckIgnorePragma = false
	}
	if v, ok := raw["cursorOffset"]; !ok || v == nil {
		plain.CursorOffset = -1.0
	}
	if v, ok := raw["embeddedLanguageFormatting"]; !ok || v == nil {
		plain.EmbeddedLanguageFormatting = "auto"
	}
	if v, ok := raw["endOfLine"]; !ok || v == nil {
		plain.EndOfLine = "lf"
	}
	if v, ok := raw["experimentalOperatorPosition"]; !ok || v == nil {
		plain.ExperimentalOperatorPosition = "end"
	}
	if v, ok := raw["experimentalTernaries"]; !ok || v == nil {
		plain.ExperimentalTernaries = false
	}
	if v, ok := raw["htmlWhitespaceSensitivity"]; !ok || v == nil {
		plain.HtmlWhitespaceSensitivity = "css"
	}
	if v, ok := raw["insertPragma"]; !ok || v == nil {
		plain.InsertPragma = false
	}
	if v, ok := raw["jsxSingleQuote"]; !ok || v == nil {
		plain.JsxSingleQuote = false
	}
	if v, ok := raw["objectWrap"]; !ok || v == nil {
		plain.ObjectWrap = "preserve"
	}
	if v, ok := raw["plugins"]; !ok || v == nil {
		plain.Plugins = []string{}
	}
	if v, ok := raw["printWidth"]; !ok || v == nil {
		plain.PrintWidth = 80.0
	}
	if v, ok := raw["proseWrap"]; !ok || v == nil {
		plain.ProseWrap = "preserve"
	}
	if v, ok := raw["quoteProps"]; !ok || v == nil {
		plain.QuoteProps = "as-needed"
	}
	if v, ok := raw["rangeStart"]; !ok || v == nil {
		plain.RangeStart = 0.0
	}
	if v, ok := raw["requirePragma"]; !ok || v == nil {
		plain.RequirePragma = false
	}
	if v, ok := raw["semi"]; !ok || v == nil {
		plain.Semi = true
	}
	if v, ok := raw["singleAttributePerLine"]; !ok || v == nil {
		plain.SingleAttributePerLine = false
	}
	if v, ok := raw["singleQuote"]; !ok || v == nil {
		plain.SingleQuote = false
	}
	if v, ok := raw["tabWidth"]; !ok || v == nil {
		plain.TabWidth = 2.0
	}
	if v, ok := raw["trailingComma"]; !ok || v == nil {
		plain.TrailingComma = "all"
	}
	if v, ok := raw["useTabs"]; !ok || v == nil {
		plain.UseTabs = false
	}
	if v, ok := raw["vueIndentScriptAndStyle"]; !ok || v == nil {
		plain.VueIndentScriptAndStyle = false
	}
	*j = OptionsDefinition(plain)
	return nil
}

type OverridesDefinitionOverridesElem struct {
	// Exclude these files from this override.
	ExcludeFiles interface{} `json:"excludeFiles,omitempty" yaml:"excludeFiles,omitempty" mapstructure:"excludeFiles,omitempty"`

	// Include these files in this override.
	Files interface{} `json:"files" yaml:"files" mapstructure:"files"`

	// The options to apply for this override.
	Options *OptionsDefinition `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OverridesDefinitionOverridesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["files"]; !ok || v == nil {
		return fmt.Errorf("field files in OverridesDefinitionOverridesElem: required")
	}
	type Plain OverridesDefinitionOverridesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = OverridesDefinitionOverridesElem(plain)
	return nil
}

type OverridesDefinition struct {
	// Provide a list of patterns to override prettier configuration.
	Overrides []OverridesDefinitionOverridesElem `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`
}
