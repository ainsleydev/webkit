package docs

import (
	"context"
	"encoding/json"
	"fmt"
	"path/filepath"
	"strings"
	"time"

	"github.com/pkg/errors"
	"github.com/spf13/afero"

	"github.com/ainsleydev/webkit/internal/appdef"
	"github.com/ainsleydev/webkit/internal/cmdtools"
	"github.com/ainsleydev/webkit/internal/manifest"
	"github.com/ainsleydev/webkit/internal/scaffold"
	"github.com/ainsleydev/webkit/internal/templates"
)

const (
	webkitSymbolURL = "https://github.com/ainsleydev/webkit/blob/main/resources/symbol.png?raw=true"
	resourcesDir    = "resources"
	outputsFilePath = ".webkit/outputs.json"
)

type (
	// WebkitOutputs represents the structure of .webkit/outputs.json
	// generated by Terraform after infrastructure provisioning.
	WebkitOutputs struct {
		Monitoring MonitoringOutputs `json:"monitoring"`
		Slack      SlackOutputs      `json:"slack"`
	}
	// MonitoringOutputs contains Peekaping monitor data for status badges.
	MonitoringOutputs struct {
		PeekapingEndpoint string                   `json:"peekaping_endpoint"`
		HTTPMonitors      map[string]MonitorOutput `json:"http_monitors"`
		DNSMonitors       map[string]MonitorOutput `json:"dns_monitors"`
		PushMonitors      map[string]MonitorOutput `json:"push_monitors"`
		StatusPageURL     string                   `json:"status_page_url"`
	}
	// MonitorOutput represents a single monitor's details.
	MonitorOutput struct {
		ID   string `json:"id"`
		Name string `json:"name"`
	}
	// SlackOutputs contains Slack channel information.
	SlackOutputs struct {
		ChannelName string `json:"channel_name"`
		ChannelID   string `json:"channel_id"`
	}
)

// Readme creates the README.md file at the project root by combining
// the base template with project data from app.json.
func Readme(_ context.Context, input cmdtools.CommandInput) error {
	appDef := input.AppDef()

	data := map[string]any{
		"Definition":     appDef,
		"Content":        mustLoadCustomContent(input.FS, "README.md"),
		"LogoURL":        detectLogoURL(input.FS),
		"DomainLinks":    formatDomainLinks(appDef),
		"ProviderGroups": groupByProvider(appDef),
		"CurrentYear":    time.Now().Year(),
		"Outputs":        loadWebkitOutputs(input.FS),
	}

	err := input.Generator().Template(
		"README.md",
		templates.MustLoadTemplate("README.md"),
		data,
		scaffold.WithTracking(manifest.SourceProject()),
	)
	if err != nil {
		return errors.Wrap(err, "generating README.md")
	}

	return nil
}

// loadWebkitOutputs attempts to load the .webkit/outputs.json file.
// Returns nil if the file doesn't exist or can't be parsed.
func loadWebkitOutputs(fs afero.Fs) *WebkitOutputs {
	data, err := afero.ReadFile(fs, outputsFilePath)
	if err != nil {
		return nil
	}

	var outputs WebkitOutputs
	if err = json.Unmarshal(data, &outputs); err != nil {
		return nil
	}

	return &outputs
}

// detectLogoURL checks for logo files in resources directory and returns
// the path or falls back to the WebKit symbol URL.
func detectLogoURL(fs afero.Fs) string {
	extensions := []string{"svg", "png", "jpg"}

	for _, ext := range extensions {
		logoPath := filepath.Join(resourcesDir, fmt.Sprintf("logo.%s", ext))
		exists, err := afero.Exists(fs, logoPath)
		if err == nil && exists {
			return fmt.Sprintf("./%s", logoPath)
		}
	}

	return webkitSymbolURL
}

// formatDomainLinks creates the HTML links for all primary domains.
func formatDomainLinks(def *appdef.Definition) string {
	var links []string

	for _, app := range def.Apps {
		if uri := app.PrimaryDomainURL(); uri != "" {
			link := fmt.Sprintf(`<a href="%s"><strong>%s</strong></a>`, uri, app.Title)
			links = append(links, link)
		}
	}

	return strings.Join(links, " Â· ")
}

// groupByProvider groups apps and resources by their infrastructure provider.
func groupByProvider(def *appdef.Definition) map[string]string {
	groups := make(map[appdef.ResourceProvider][]string)

	for _, app := range def.Apps {
		if app.Infra.Provider != "" {
			groups[app.Infra.Provider] = append(
				groups[app.Infra.Provider],
				fmt.Sprintf("%s (App)", app.Title),
			)
		}
	}

	for _, resource := range def.Resources {
		groups[resource.Provider] = append(
			groups[resource.Provider],
			fmt.Sprintf("%s (%s)", resource.Title, resource.Type),
		)
	}

	result := make(map[string]string)
	for provider, items := range groups {
		result[string(provider)] = strings.Join(items, ", ")
	}

	return result
}
