package appdef

import (
	"fmt"
	"strings"

	"github.com/ainsleydev/webkit/pkg/env"
)

type (
	// MonitoringConfig is the user-facing config in app.json.
	// It's intentionally simple - just an enabled flag.
	MonitoringConfig struct {
		Enabled bool `json:"enabled" description:"Whether to enable uptime monitoring for this app or resource (defaults to true)"`
	}

	// Monitor contains internal monitoring configuration with smart defaults.
	// This struct is passed to Terraform and contains all the sophisticated logic
	// that users don't need to configure manually.
	Monitor struct {
		Name    string      // Unique monitor name.
		Type    MonitorType // Monitor type (http, postgres, push).
		Enabled bool        // Whether monitor is enabled.

		// HTTP-specific fields.
		URL             string // Full URL to monitor.
		Method          string // HTTP method (default: "GET").
		ExpectedStatus  []int  // Expected HTTP status codes (default: [200]).
		HealthCheckPath string // Health check endpoint path.

		// Database-specific fields.
		DatabaseURL    string // Database connection URL.
		ConnectionType string // Database type (postgres, mysql, etc.).

		// Push/Heartbeat-specific fields.
		PushURL          string // Generated by Uptime Kuma.
		ExpectedInterval int    // Seconds, auto-calculated from cron.

		// Common settings with sensible defaults.
		Interval      int  // Check interval in seconds.
		RetryInterval int  // Retry interval in seconds.
		MaxRetries    int  // Maximum retry attempts.
		UpsideDown    bool // Inverted status (up=down, down=up).
		IgnoreTLS     bool // Skip TLS certificate validation.
	}

	// MonitorType defines the type of monitor.
	MonitorType string
)

// MonitorType constants.
const (
	MonitorTypeHTTP     MonitorType = "http"
	MonitorTypePostgres MonitorType = "postgres"
	MonitorTypePush     MonitorType = "push"
)

// String implements fmt.Stringer on MonitorType.
func (m MonitorType) String() string {
	return string(m)
}

// GenerateMonitors creates HTTP monitors for all domains in the app.
// It generates one monitor per domain (primary + aliases), excluding unmanaged domains.
// Monitoring must be explicitly enabled in the app configuration.
func (a *App) GenerateMonitors() []Monitor {
	if !a.IsMonitoringEnabled() {
		return nil
	}

	monitors := make([]Monitor, 0)

	// Create HTTP monitor for each domain (primary + aliases).
	for _, domain := range a.Domains {
		if domain.Type == DomainTypeUnmanaged {
			continue
		}

		monitors = append(monitors, Monitor{
			Name:            fmt.Sprintf("%s-%s", a.Name, sanitiseMonitorName(domain.Name)),
			Type:            MonitorTypeHTTP,
			Enabled:         true,
			URL:             fmt.Sprintf("https://%s%s", domain.Name, a.healthCheckPath()),
			Method:          "GET",
			ExpectedStatus:  []int{200},
			HealthCheckPath: a.healthCheckPath(),
			Interval:        60, // 1 minute.
			RetryInterval:   60, // 1 minute.
			MaxRetries:      3,
			UpsideDown:      false,
			IgnoreTLS:       false,
		})
	}

	return monitors
}

// healthCheckPath extracts the health check path from the app's infra config.
// It defaults to "/" if not specified.
func (a *App) healthCheckPath() string {
	if a.Infra.Config == nil {
		return "/"
	}

	if path, ok := a.Infra.Config["health_check_path"].(string); ok && path != "" {
		return path
	}

	return "/"
}

// IsMonitoringEnabled returns whether monitoring is enabled for this app.
// Monitoring is enabled by default (opt-out).
func (a *App) IsMonitoringEnabled() bool {
	return a.Monitoring.Enabled
}

// GenerateMonitors creates monitors for resources based on their type.
// Currently only Postgres databases are supported for monitoring.
// Monitoring must be explicitly enabled in the resource configuration.
func (r *Resource) GenerateMonitors(enviro env.Environment) []Monitor {
	if !r.IsMonitoringEnabled() {
		return nil
	}

	// Only Postgres supported for now (Uptime Kuma limitation).
	if r.Type != ResourceTypePostgres {
		return nil
	}

	return []Monitor{
		{
			Name:           fmt.Sprintf("%s-%s", r.Name, enviro),
			Type:           MonitorTypePostgres,
			Enabled:        true,
			DatabaseURL:    r.terraformOutputReference(enviro, "connection_url"),
			ConnectionType: "postgres",
			Interval:       300, // 5 minutes for databases.
			RetryInterval:  60,  // 1 minute.
			MaxRetries:     3,
			UpsideDown:     false,
			IgnoreTLS:      false,
		},
	}
}

// GenerateHeartbeatMonitor creates a push monitor for backup job heartbeats.
// The monitor expects a heartbeat signal after each successful backup.
func (r *Resource) GenerateHeartbeatMonitor(cronSchedule string) Monitor {
	if !r.Backup.Enabled {
		return Monitor{}
	}

	return Monitor{
		Name:             fmt.Sprintf("backup-%s", r.Name),
		Type:             MonitorTypePush,
		Enabled:          true,
		ExpectedInterval: calculateHeartbeatInterval(cronSchedule),
		MaxRetries:       2,
		UpsideDown:       false,
	}
}

// IsMonitoringEnabled returns whether monitoring is enabled for this resource.
// Monitoring is enabled by default (opt-out).
func (r *Resource) IsMonitoringEnabled() bool {
	return r.Monitoring.Enabled
}

// terraformOutputReference returns a Terraform interpolation string for a resource output.
// This is used to reference Terraform module outputs in the generated configuration.
//
// Example:
//
//	r.terraformOutputReference(env.Production, "connection_url")
//	â†“
//	"${module.resources.db_production_connection_url}"
func (r *Resource) terraformOutputReference(enviro env.Environment, output string) string {
	return fmt.Sprintf("${module.resources.%s_%s_%s}",
		r.Name,
		enviro,
		output)
}

// calculateHeartbeatInterval parses a cron schedule and calculates the expected
// heartbeat interval with a 10% buffer for timing variations.
//
// For now, this is a simplified implementation that assumes daily backups.
// TODO: Implement proper cron parsing using a library like github.com/robfig/cron.
func calculateHeartbeatInterval(cronSchedule string) int {
	// Suppress unused parameter warning until cron parsing is implemented.
	_ = cronSchedule

	// Parse "0 2 * * *" (daily at 2am) -> 24 hours.
	// Add 10% buffer -> 26.4 hours = 95040 seconds.
	const (
		dailySeconds = 86400 // 24 hours.
		bufferFactor = 1.1   // 10% buffer.
	)

	// TODO: Implement proper cron parsing.
	// For now, assume daily schedule and apply buffer.
	baseInterval := dailySeconds

	return int(float64(baseInterval) * bufferFactor)
}

// sanitiseMonitorName converts a domain name to a valid monitor name component.
// It replaces dots with hyphens to create Terraform-safe resource names.
//
// Example:
//
//	sanitiseMonitorName("api.example.com") -> "api-example-com"
func sanitiseMonitorName(domain string) string {
	return strings.ReplaceAll(domain, ".", "-")
}
