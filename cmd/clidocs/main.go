// Package main generates CLI documentation for VitePress.
package main

import (
	"bytes"
	"context"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	docs "github.com/urfave/cli-docs/v3"
	"github.com/urfave/cli/v3"

	"github.com/ainsleydev/webkit/internal/cmd/cicd"
	cmddocs "github.com/ainsleydev/webkit/internal/cmd/docs"
	"github.com/ainsleydev/webkit/internal/cmd/env"
	"github.com/ainsleydev/webkit/internal/cmd/infra"
	"github.com/ainsleydev/webkit/internal/cmd/payload"
	"github.com/ainsleydev/webkit/internal/cmd/secrets"
	"github.com/ainsleydev/webkit/internal/printer"
)

const defaultOutput = "docs/cli/reference.md"

func main() {
	var output string
	flag.StringVar(&output, "output", defaultOutput, "Output file path")
	flag.Parse()

	p := printer.New(os.Stdout)

	p.Info("Generating CLI documentation...")
	p.LineBreak()

	if err := run(output); err != nil {
		p.Error(err.Error())
		p.LineBreak()
		os.Exit(1)
	}

	p.Success(fmt.Sprintf("CLI documentation generated at %s", output))
	p.LineBreak()
}

func run(output string) error {
	cmd := buildCLI()

	md, err := docs.ToMarkdown(cmd)
	if err != nil {
		return fmt.Errorf("generating markdown: %w", err)
	}

	// Wrap with VitePress frontmatter and adjust formatting
	content := formatForVitePress(md)

	// Ensure output directory exists
	dir := filepath.Dir(output)
	if err := os.MkdirAll(dir, 0o755); err != nil {
		return fmt.Errorf("creating output directory: %w", err)
	}

	if err := os.WriteFile(output, []byte(content), 0o644); err != nil {
		return fmt.Errorf("writing file: %w", err)
	}

	return nil
}

// buildCLI constructs the CLI command structure for documentation.
// This mirrors internal/cmd/cli.go but without runtime dependencies.
func buildCLI() *cli.Command {
	return &cli.Command{
		Name:        "webkit",
		Usage:       "Configuration-driven infrastructure for web projects",
		Description: "WebKit generates infrastructure, CI/CD, and project configuration from a single app.json manifest file.",
		Commands: []*cli.Command{
			{
				Name:        "update",
				Usage:       "Regenerate all project files from app.json",
				Description: "Rebuilds all generated files based on current app.json configuration. This is the primary command for keeping your project in sync with your manifest.",
			},
			{
				Name:        "validate",
				Usage:       "Validate app.json configuration",
				Description: "Validates the app.json file for correctness, including required fields, domain formats, paths, and environment variable references.",
			},
			{
				Name:        "scaffold",
				Usage:       "Generate individual components",
				Description: "Generate specific components without running a full update. Available components vary based on your configuration.",
				Arguments: []cli.Argument{
					&cli.StringArg{
						Name:  "component",
						Usage: "Component to scaffold",
					},
				},
			},
			{
				Name:        "drift",
				Usage:       "Detect manual modifications to generated files",
				Description: "Compares current file contents against stored hashes to identify changes made outside of WebKit.",
			},
			{
				Name:        "version",
				Usage:       "Display the installed WebKit version",
				Description: "Shows the current version of the WebKit CLI.",
			},
			secrets.Command,
			env.Command,
			infra.Command,
			cicd.Command,
			cmddocs.Command,
			payload.Command,
		},
	}
}

// formatForVitePress wraps the markdown with VitePress frontmatter
// and adjusts heading levels.
func formatForVitePress(md string) string {
	var buf bytes.Buffer

	// Frontmatter
	buf.WriteString("---\n")
	buf.WriteString("# Auto-generated by cmd/clidocs\n")
	buf.WriteString("# Do not edit manually\n")
	buf.WriteString("---\n\n")

	// Title
	buf.WriteString("# CLI reference\n\n")
	buf.WriteString("This page documents all available WebKit commands.\n\n")
	buf.WriteString("::: tip Auto-generated\n")
	buf.WriteString("This documentation is automatically generated from the CLI source code.\n")
	buf.WriteString(":::\n\n")

	// Adjust heading levels (# -> ##, ## -> ###, etc.)
	lines := strings.Split(md, "\n")
	for _, line := range lines {
		if strings.HasPrefix(line, "# ") {
			// Skip the main title as we've added our own
			continue
		}
		if strings.HasPrefix(line, "## ") {
			buf.WriteString("#" + line + "\n")
		} else if strings.HasPrefix(line, "### ") {
			buf.WriteString("#" + line + "\n")
		} else {
			buf.WriteString(line + "\n")
		}
	}

	return buf.String()
}
