This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

# File Summary

## Purpose
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: internal/**/*.go
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
internal/
  appdef/
    apps_test.go
    apps.go
    commands_test.go
    commands.go
    definition_test.go
    definition.go
    env_test.go
    env.go
    old.go
    resources_test.go
    resources.go
  cmd/
    internal/
      cmdtools/
        input_test.go
        input.go
        tools.go
      operations/
        infra/
          infra_temp.go
        secrets/
          create_files_test.go
          create_files.go
          decrypt_test.go
          decrypt.go
          encrypt_test.go
          encrypt.go
          get_test.go
          get.go
          secrets_integration_test.go
          sync.go
          util_test.go
          util.go
          validate.go
        ci_cd_test.go
        ci_cd.go
        code_style_test.go
        code_style.go
        git_settings_test.go
        git_settings.go
        package_json_test.go
        package_json.go
      schemas/
        github/
          settings.go
        package_json.go
    cli.go
    drift.go
    env.go
    scaffold.go
    scratch.go
    secrets.go
    update.go
  config/
    config_test.go
    config.go
  executil/
    exec_test.go
    exec.go
    executil_test.go
    executil.go
    mem_test.go
    mem.go
  fsext/
    copier_test.go
    copier.go
  git/
    clone_test.go
    clone.go
    git_integration_test.go
    git_test.go
    git.go
  print/
    print.go
  scaffold/
    generate_test.go
    generate.go
    notice_test.go
    notice.go
    options.go
  secrets/
    age/
      age_test.go
      age.go
      provider_test.go
      provider.go
    sops/
      map_test.go
      map.go
      provider.go
      sops_test.go
      sops.go
      util_test.go
      util.go
    resolve.go
    secrets.go
    sync_result.go
    sync_test.go
    sync.go
    validate.go
  templates/
    embed.go
    funcs.go
  testutil/
    action_validator.go
    afero.go
    schema.go
```

# Files

## File: internal/cmd/internal/operations/secrets/decrypt_test.go
```go
package secrets
```

## File: internal/cmd/internal/operations/secrets/decrypt.go
```go
package secrets

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"path/filepath"

	"github.com/ainsleydev/webkit/internal/cmd/internal/cmdtools"
	"github.com/ainsleydev/webkit/internal/secrets"
	"github.com/ainsleydev/webkit/internal/secrets/age"
	"github.com/ainsleydev/webkit/internal/secrets/sops"
	"github.com/ainsleydev/webkit/pkg/env"
)

func DecryptFiles(ctx context.Context, input cmdtools.CommandInput) error {
	fmt.Println("Decrypting secret files...")

	prov, err := age.NewProvider()
	if err != nil {
		return err
	}

	client := sops.NewClient(prov)

	for _, e := range env.All {
		path := filepath.Join(input.BaseDir, secrets.FilePath, e+".yaml")
		err = client.Decrypt(path)
		if errors.Is(err, sops.ErrNotEncrypted) {
			continue
		} else if err != nil {
			slog.ErrorContext(ctx, "Failed to decrypt secret file", "error", err, "file", path)
		}
	}

	fmt.Println("Successfully decrypted secret files")

	return nil
}
```

## File: internal/cmd/internal/operations/secrets/encrypt.go
```go
package secrets

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"path/filepath"

	"github.com/ainsleydev/webkit/internal/cmd/internal/cmdtools"
	"github.com/ainsleydev/webkit/internal/secrets"
	"github.com/ainsleydev/webkit/internal/secrets/sops"
	"github.com/ainsleydev/webkit/pkg/env"
)

func EncryptFiles(ctx context.Context, input cmdtools.CommandInput) error {
	fmt.Println("Encrypting secret files...")

	client, err := getSopsClient()
	if err != nil {
		return err
	}

	for _, e := range env.All {
		path := filepath.Join(input.BaseDir, secrets.FilePath, e+".yaml")
		err = client.Encrypt(path)
		if errors.Is(err, sops.ErrAlreadyEncrypted) {
			continue
		} else if err != nil {
			slog.ErrorContext(ctx, "Failed to encrypt secret file", "error", err, "file", path)
		}
	}

	fmt.Println("Successfully encrypted secret files")

	return nil
}
```

## File: internal/cmd/internal/operations/secrets/get_test.go
```go
package secrets

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/require"
	"github.com/urfave/cli/v3"

	"github.com/ainsleydev/webkit/internal/cmd/internal/cmdtools"
	"github.com/ainsleydev/webkit/internal/executil"
	"github.com/ainsleydev/webkit/internal/secrets"
	"github.com/ainsleydev/webkit/pkg/env"
)

func TestGet(t *testing.T) {
	t.Parallel()

	if !executil.Exists("sops") {
		t.Skip("sops CLI not found in PATH; skipping integration test")
	}

	tmpDir := t.TempDir()
	secretsDir := filepath.Join(tmpDir, secrets.FilePath)
	require.NoError(t, os.MkdirAll(secretsDir, os.ModePerm))

	envName := env.Production
	key := "SECRET_KEY"
	value := "supersecret"

	plainPath := filepath.Join(secretsDir, envName+".yaml")

	// Write plaintext YAML
	content := fmt.Sprintf("%s: %q\n", key, value)
	require.NoError(t, os.WriteFile(plainPath, []byte(content), os.ModePerm))

	// Encrypt using SOPS + age
	cmd := exec.CommandContext(t.Context(), "sops", "--encrypt", "--in-place", plainPath)
	out, err := cmd.CombinedOutput()
	require.NoErrorf(t, err, "failed to encrypt test file with sops: %s", string(out))

	// Prepare CLI command
	cmdCLI := &cli.Command{
		Flags: []cli.Flag{
			&cli.StringFlag{Name: "env"},
			&cli.StringFlag{Name: "key"},
		},
	}
	require.NoError(t, cmdCLI.Set("env", envName))
	require.NoError(t, cmdCLI.Set("key", key))

	input := cmdtools.CommandInput{
		Command: cmdCLI,
		BaseDir: tmpDir,
	}

	// Run Get
	err = Get(t.Context(), input)
	require.NoError(t, err)
}
```

## File: internal/cmd/internal/operations/secrets/get.go
```go
package secrets

import (
	"context"
	"fmt"
	"path/filepath"

	"github.com/ainsleydev/webkit/internal/cmd/internal/cmdtools"
	"github.com/ainsleydev/webkit/internal/secrets"
	"github.com/ainsleydev/webkit/internal/secrets/sops"
)

// Get retrieves a singular decrypted secret by environment.
// Use with caution.
func Get(_ context.Context, input cmdtools.CommandInput) error {
	cmd := input.Command
	env := cmd.String("env")
	key := cmd.String("key")

	client, err := getSopsClient()
	if err != nil {
		return err
	}

	path := filepath.Join(input.BaseDir, secrets.FilePath, env+".yaml")
	vals, err := sops.DecryptFileToMap(client, path)
	if err != nil {
		return err
	}

	value, ok := vals[key]
	if !ok {
		return fmt.Errorf("key %q not found for env: %s", key, env)
	}

	fmt.Println(value)

	return nil
}
```

## File: internal/cmd/internal/operations/secrets/secrets_integration_test.go
```go
package secrets

import (
	"fmt"
	"testing"

	"github.com/spf13/afero"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/urfave/cli/v3"

	"github.com/ainsleydev/webkit/internal/appdef"
	"github.com/ainsleydev/webkit/internal/cmd/internal/cmdtools"
	"github.com/ainsleydev/webkit/internal/executil"
)

func TestSecretsIntegration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	if !executil.Exists("sops") {
		t.Skip("sops CLI not found in PATH; skipping integration test")
	}

	ctx := t.Context()

	tmpDir := t.TempDir()
	fs := afero.NewBasePathFs(afero.NewOsFs(), tmpDir)

	input := cmdtools.CommandInput{
		FS:      fs,
		BaseDir: tmpDir,
		AppDefCache: &appdef.Definition{
			Shared: appdef.Shared{
				Env: appdef.Environment{
					Production: map[string]appdef.EnvValue{
						"SECRET_SHARED_VAR": {Value: "secret", Source: appdef.EnvSourceSOPS},
					},
				},
			},
			Apps: []appdef.App{
				{
					Name: "sops",
					Env: appdef.Environment{
						Dev: map[string]appdef.EnvValue{
							"SECRET_APP_VAR": {Value: "secret", Source: appdef.EnvSourceSOPS},
						},
						Production: map[string]appdef.EnvValue{
							"SECRET_APP_VAR": {Value: "secret", Source: appdef.EnvSourceSOPS},
						},
						Staging: map[string]appdef.EnvValue{
							"SECRET_APP_VAR": {Value: "secret", Source: appdef.EnvSourceSOPS},
						},
					},
				},
			},
		},
	}

	err := CreateFiles(ctx, input)
	assert.NoError(t, err)

	// Sync doesnt write values for you, it only writes placeholders
	// so we need to write back to the file.

	t.Log("Syncs Vars to Environments")
	{
		err = Sync(ctx, input)
		assert.NoError(t, err)
	}

	t.Log("Encrypts Files")
	{
		err = EncryptFiles(ctx, input)
		assert.NoError(t, err)
	}

	t.Log("Decrypts Files")
	{
		err = DecryptFiles(ctx, input)
		assert.NoError(t, err)
	}

	t.Log("Gets Vars")
	{
		assert.NoError(t, EncryptFiles(ctx, input))

		input.Command = &cli.Command{
			Flags: []cli.Flag{
				&cli.StringFlag{Name: "env"},
				&cli.StringFlag{Name: "key"},
			},
		}
		require.NoError(t, input.Command.Set("env", "production"))
		require.NoError(t, input.Command.Set("key", "SECRET_APP_VAR"))

		err = Get(ctx, input)
		require.NoError(t, err)

		fmt.Println(err)
	}

}
```

## File: internal/cmd/internal/operations/secrets/util.go
```go
package secrets

import (
	"github.com/ainsleydev/webkit/internal/secrets/age"
	"github.com/ainsleydev/webkit/internal/secrets/sops"
)

func getSopsClient() (sops.EncrypterDecrypter, error) {
	prov, err := age.NewProvider()
	if err != nil {
		return nil, err
	}
	return sops.NewClient(prov), nil
}
```

## File: internal/executil/executil_test.go
```go
package executil

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestCommand_String(t *testing.T) {
	t.Parallel()

	tt := map[string]struct {
		input Command
		want  string
	}{
		"No Args": {
			input: NewCommand("git"),
			want:  "git",
		},
		"Single Arg": {
			input: NewCommand("echo", "hello"),
			want:  "echo hello",
		},
		"Multiple Args": {
			input: NewCommand("build", "-o", "bin/app"),
			want:  "build -o bin/app",
		},
		"Empty Name": {
			input: NewCommand(""),
			want:  "",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			t.Parallel()
			got := test.input.String()
			assert.Equal(t, test.want, got)
		})
	}
}

func Test_Exists(t *testing.T) {
	t.Parallel()

	tt := map[string]struct {
		input string
		want  bool
	}{
		"Existing Command": {
			input: "echo",
			want:  true,
		},
		"Nonexistent Command": {
			input: "nonexistentcommand123",
			want:  false,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			t.Parallel()
			got := Exists(test.input)
			assert.Equal(t, test.want, got)
		})
	}
}
```

## File: internal/executil/executil.go
```go
package executil

import (
	"context"
	"io"
	"os/exec"
	"strings"
)

type (
	// Runner is the interface for running external commands
	// using exec.Command.
	Runner interface {
		Run(ctx context.Context, cmd Command) (Result, error)
	}
	// Command defines all options for running a command.
	Command struct {
		Name   string
		Args   []string
		Dir    string
		Env    map[string]string
		Stdin  io.Reader
		Stdout io.Writer
		Stderr io.Writer
	}
	// Result captures the outcome of running a command.
	Result struct {
		CmdLine string
		Output  string
	}
)

// NewCommand creates a new Command with a name and args.
func NewCommand(name string, args ...string) Command {
	return Command{Name: name, Args: args}
}

// String implements fmt.Stringer on the command to print
// the name of the command and it's arguments.
func (c Command) String() string {
	if len(c.Args) == 0 {
		return c.Name
	}
	return c.Name + " " + strings.Join(c.Args, " ")
}

// Exists checks to see if a command line application
// exists named by the PATH environment variable.
func Exists(command string) bool {
	_, err := exec.LookPath(command)
	return err == nil
}
```

## File: internal/appdef/definition_test.go
```go
package appdef

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestGithubLabels(t *testing.T) {
	t.Parallel()

	tt := map[string]struct {
		input Definition
		want  []string
	}{
		"No Apps": {
			input: Definition{Apps: nil},
			want:  []string{"webkit"},
		},
		"Single App": {
			input: Definition{
				Apps: []App{
					{Type: AppTypeSvelteKit},
				},
			},
			want: []string{"webkit", AppTypeSvelteKit.String()},
		},
		"Multiple Apps": {
			input: Definition{
				Apps: []App{
					{Type: AppTypeGoLang},
					{Type: AppTypePayload},
				},
			},
			want: []string{
				"webkit",
				AppTypeGoLang.String(),
				AppTypePayload.String(),
			},
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			t.Parallel()
			got := test.input.GithubLabels()
			assert.Equal(t, test.want, got)
		})
	}
}
```

## File: internal/appdef/old.go
```go
package appdef

import schemaorg "github.com/ainsleydev/webkit/pkg/markup/schema"

type definitionOld struct {
	Name          string
	Slug          string
	URL           string
	Description   string
	WebKitVersion string
	TitleSuffix   string
	Logo          string
	Adapter       string
	Deployment    string
	Images        []string
	Company       schemaorg.Organisation
	Social        Social
	Menus         map[string][]MenuItem
	Params        map[string]any // Other

	Analytics struct {
		Google    string
		Plausible string
	}
}

type MenuItem struct {
	Identifier string
	Name       string
	URL        string
	Weight     string
	Children   []MenuItem
	Params     map[string]any
}

type Contact struct {
	Email       string
	Phone       string
	Coordinates struct{ Latitude, Longitude string }
	Address     schemaorg.Address
}

type Social struct {
	Twitter   string
	LinkedIn  string
	GitHub    string
	YouTube   string
	Facebook  string
	Instagram string
	TikTok    string
	Dribbble  string
}
```

## File: internal/cmd/internal/cmdtools/input_test.go
```go
package cmdtools
```

## File: internal/cmd/internal/cmdtools/tools.go
```go
package cmdtools

import (
	"fmt"
	"os"
)

// TODO: Make sexy af
func Exit(err error) {
	if err != nil {
		fmt.Println(err.Error())
	}
	os.Exit(0)
}
```

## File: internal/cmd/internal/operations/infra/infra_temp.go
```go
package infra

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/hashicorp/terraform-exec/tfexec"

	"github.com/ainsleydev/webkit/infra/terraform"
	"github.com/ainsleydev/webkit/internal/appdef"
	"github.com/ainsleydev/webkit/internal/cmd/internal/cmdtools"
	"github.com/ainsleydev/webkit/internal/config"
	"github.com/ainsleydev/webkit/internal/executil"
	"github.com/ainsleydev/webkit/internal/fsext"
	"github.com/ainsleydev/webkit/internal/git"
)

const (
	webkitInfraRepo = "https://github.com/ainsleydev/webkit-infra.git"
	webkitInfraRef  = "main" // or version tag like "v1.2.3"
)

func Test(ctx context.Context, input cmdtools.CommandInput) error {
	tmpDir, err := os.MkdirTemp("", "webkit-tf")
	if err != nil {
		return err
	}
	defer func(path string) {
		if err = os.RemoveAll(path); err != nil {
			slog.ErrorContext(ctx, "Failed to remove temp dir", slog.String("path", path))
		}
	}(tmpDir)

	fmt.Println("Temp dir:", tmpDir)

	// Copy embedded templates to the working directory
	err = fsext.CopyAllEmbed(tfembed.Templates, tmpDir)
	if err != nil {
		return err
	}

	whichCmd := executil.NewCommand("which", "terraform")
	run, err := executil.DefaultRunner().Run(ctx, whichCmd)
	if err != nil {
		return err
	}
	tfPath := strings.TrimSpace(run.Output)

	// Create terraform executor
	tfDir := filepath.Join(tmpDir, "base")
	tf, err := tfexec.NewTerraform(tfDir, tfPath)
	if err != nil {
		return fmt.Errorf("creating terraform executor: %w", err)
	}

	// Resolve env vars

	fmt.Println("Initializing Terraform...")
	if err = tf.Init(ctx, tfexec.Upgrade(true)); err != nil {
		return fmt.Errorf("terraform init: %w", err)
	}

	fmt.Println("Making Plan....")
	_, err = tf.Plan(ctx,
		tfexec.Var("project_name=hey!"),
		tfexec.Var("environment=production!"),
	)
	if err != nil {
		return fmt.Errorf("executing plan: %w", err)
	}

	state, err := tf.Show(context.Background())
	if err != nil {
		return err
	}

	fmt.Println(state)

	return nil

	//fmt.Println(run.Output)
	//os.Exit(1)
	//// Run Terraform commands
	//tf, err := tfexec.NewTerraform(tmp, "/usr/local/bin/terraform")
	//if err != nil {
	//	log.Fatal(err)
	//}
	//
	//ctx := context.Background()
	//if err := tf.Init(ctx); err != nil {
	//	log.Fatal(err)
	//}
	//
	//if err := tf.Plan(ctx); err != nil {
	//	log.Fatal(err)
	//}

}

// InfraPlan runs terraform plan using the webkit-infra repository
//
// This function:
// 1. Clones or updates the webkit-infra repository
// 2. Writes app.json to the terraform working directory
// 3. Initializes terraform with the appropriate backend
// 4. Runs terraform plan to preview infrastructure changes
//
// Note: app.json is passed to terraform unmodified. If terraform cannot
// handle the app.json structure, this will be noted but not block execution.
func InfraPlan(ctx context.Context, input cmdtools.CommandInput) error {
	app := input.AppDef()

	// 1. Determine where to clone webkit-infra repo
	configDir, err := config.Dir()
	if err != nil {
		return fmt.Errorf("getting config dir: %w", err)
	}

	infraPath := filepath.Join(configDir, "webkit-infra")

	// 2. Clone or update webkit-infra repository using the git package
	if err := ensureWebKitInfra(ctx, infraPath); err != nil {
		return err
	}

	// 3. Navigate to infra subdirectory (where Terraform root is)
	terraformDir := filepath.Join(infraPath, "infra")

	// 4. Write app.json to the terraform directory
	// This passes the app definition to terraform with no modifications
	if err := writeAppJSON(terraformDir, app); err != nil {
		return fmt.Errorf("writing app.json: %w", err)
	}

	// 5. Initialize Terraform
	tf, err := initTerraform(ctx, terraformDir)
	if err != nil {
		return fmt.Errorf("initializing terraform: %w", err)
	}

	// 6. Run terraform plan
	fmt.Println("Running terraform plan...")
	if err := runTerraformPlan(ctx, tf); err != nil {
		return fmt.Errorf("terraform plan failed: %w", err)
	}

	fmt.Println("Terraform plan completed successfully!")
	return nil
}

// ensureWebKitInfra clones or updates the webkit-infra repository
func ensureWebKitInfra(ctx context.Context, infraPath string) error {
	// Create git client with default runner
	gitClient, err := git.New(executil.DefaultRunner())
	if err != nil {
		return fmt.Errorf("creating git client: %w", err)
	}

	cfg := git.CloneConfig{
		URL:       webkitInfraRepo,
		LocalPath: infraPath,
		Ref:       webkitInfraRef,
		Depth:     1, // Shallow clone for faster downloads
	}

	fmt.Printf("Ensuring webkit-infra repository at %s...\n", infraPath)
	if err := gitClient.CloneOrUpdate(ctx, cfg); err != nil {
		return fmt.Errorf("cloning/updating webkit-infra: %w", err)
	}

	return nil
}

// writeAppJSON writes the app definition to app.json in the terraform directory
// The app.json is passed to terraform with no modifications
func writeAppJSON(terraformDir string, app *appdef.Definition) error {
	appJSONPath := filepath.Join(terraformDir, "app.json")

	// Marshal the app definition to JSON with indentation for readability
	data, err := json.MarshalIndent(app, "", "  ")
	if err != nil {
		return fmt.Errorf("marshaling app definition: %w", err)
	}

	// Write app.json to the terraform directory
	if err := os.WriteFile(appJSONPath, data, 0644); err != nil {
		return fmt.Errorf("writing app.json file: %w", err)
	}

	fmt.Printf("Wrote app.json to %s\n", appJSONPath)

	// NOTE: If terraform cannot handle app.json in this format, we note it here
	// but do not block execution as per requirements
	fmt.Println("Note: app.json passed to terraform unmodified")
	fmt.Println("If terraform cannot parse this format, terraform init/plan will fail")

	return nil
}

// initTerraform initializes terraform in the given directory
func initTerraform(ctx context.Context, workingDir string) (*tfexec.Terraform, error) {
	// Find terraform executable in PATH
	terraformPath, err := findTerraformExecutable()
	if err != nil {
		return nil, err
	}

	// Create terraform executor
	tf, err := tfexec.NewTerraform(workingDir, terraformPath)
	if err != nil {
		return nil, fmt.Errorf("creating terraform executor: %w", err)
	}

	// Initialize terraform
	fmt.Println("Initializing terraform...")
	if err := tf.Init(ctx, tfexec.Upgrade(true)); err != nil {
		return nil, fmt.Errorf("terraform init: %w", err)
	}

	return tf, nil
}

// runTerraformPlan executes terraform plan
func runTerraformPlan(ctx context.Context, tf *tfexec.Terraform) error {
	// Run terraform plan
	// The plan output will be printed to stdout automatically
	_, err := tf.Plan(ctx)
	if err != nil {
		return fmt.Errorf("executing plan: %w", err)
	}

	return nil
}

// findTerraformExecutable locates the terraform binary in PATH
func findTerraformExecutable() (string, error) {
	// Try to find terraform in PATH
	path, err := exec.LookPath("terraform")
	if err != nil {
		return "", fmt.Errorf("terraform not found in PATH: %w", err)
	}
	return path, nil
}
```

## File: internal/cmd/internal/operations/secrets/create_files_test.go
```go
package secrets

import (
	"testing"

	"github.com/spf13/afero"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/ainsleydev/webkit/internal/appdef"
	"github.com/ainsleydev/webkit/internal/cmd/internal/cmdtools"
	"github.com/ainsleydev/webkit/internal/testutil"
	"github.com/ainsleydev/webkit/pkg/env"
)

func TestCreateSecretFiles(t *testing.T) {
	t.Parallel()

	t.Run("Success", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()

		err := CreateFiles(t.Context(), cmdtools.CommandInput{
			FS:          fs,
			AppDefCache: &appdef.Definition{},
		})
		assert.NoError(t, err)

		t.Log(".sops.yaml Created")
		{
			exists, err := afero.Exists(fs, "resources/.sops.yaml")
			assert.NoError(t, err)
			assert.True(t, exists)

			content, err := afero.ReadFile(fs, "resources/.sops.yaml")
			require.NoError(t, err)
			assert.Contains(t, string(content), "creation_rules")
			assert.Contains(t, string(content), "secrets/.*\\.yaml$")
			assert.Contains(t, string(content), "age1")
		}

		t.Log("Secret Files Created")
		{
			environments := []string{env.Development, env.Staging, env.Production}
			for _, enviro := range environments {
				path := "resources/secrets/" + enviro + ".yaml"

				exists, err := afero.Exists(fs, path)
				assert.NoError(t, err)
				assert.True(t, exists)

				file, err := afero.ReadFile(fs, path)
				assert.NoError(t, err)
				assert.Empty(t, string(file))
			}
		}
	})

	t.Run("Error", func(t *testing.T) {
		t.Parallel()

		got := CreateFiles(t.Context(), cmdtools.CommandInput{
			FS:          &testutil.AferoErrCreateFs{Fs: afero.NewMemMapFs()},
			AppDefCache: &appdef.Definition{},
		})
		assert.Error(t, got)
	})
}
```

## File: internal/cmd/internal/operations/secrets/create_files.go
```go
package secrets

import (
	"context"
	"fmt"

	"github.com/spf13/afero"

	"github.com/ainsleydev/webkit/internal/cmd/internal/cmdtools"
	"github.com/ainsleydev/webkit/internal/scaffold"
	"github.com/ainsleydev/webkit/internal/secrets"
	"github.com/ainsleydev/webkit/pkg/env"
)

// CreateFiles generates the basic SOPS secret file structure.
// This creates empty secret files and SOPS configuration without
// parsing app.json.
func CreateFiles(_ context.Context, input cmdtools.CommandInput) error {
	gen := scaffold.New(afero.NewBasePathFs(input.FS, "resources"))

	if err := generateSOPSConfig(gen); err != nil {
		return fmt.Errorf("generating .sops.yaml: %w", err)
	}

	for _, enviro := range env.All {
		filePath := fmt.Sprintf("secrets/%s.yaml", enviro)

		// If we generate a file that has YAML commentary in the file,
		// SOPS will encrypt the comments when Encrypt() is called,
		// malforming the file.
		err := gen.Bytes(filePath, make([]byte, 0), scaffold.WithScaffoldMode())
		if err != nil {
			return fmt.Errorf("generating %s: %w", filePath, err)
		}
	}

	return nil
}

// generateSOPSConfig creates the .sops.yaml configuration file which tells
// sops how to encrypt and decrypt files without specifying rules or keys
// everytime we call the cmd.
func generateSOPSConfig(gen scaffold.Generator) error {
	config := map[string]any{
		"creation_rules": []map[string]any{
			{
				"path_regex": `secrets/.*\.yaml$`,
				"age":        secrets.AgePublicKey,
			},
		},
	}
	return gen.YAML(".sops.yaml", config)
}
```

## File: internal/cmd/internal/operations/secrets/encrypt_test.go
```go
package secrets
```

## File: internal/cmd/internal/operations/secrets/sync.go
```go
package secrets

import (
	"context"
	"fmt"
	"strings"

	"github.com/ainsleydev/webkit/internal/cmd/internal/cmdtools"
	"github.com/ainsleydev/webkit/internal/secrets"
)

// Sync adds missing secret placeholders to SOPS files based on app.json.
// This command reads environment variables with source: "sops" and ensures
// corresponding placeholder entries exist in the appropriate secret files.
// Only works with unencrypted files.
func Sync(_ context.Context, input cmdtools.CommandInput) error {
	app := input.AppDef()

	results, err := secrets.Sync(secrets.SyncConfig{
		FS:     input.FS,
		AppDef: app,
	})
	if err != nil {
		return fmt.Errorf("syncing secrets: %w", err)
	}

	if len(results.Files) == 0 {
		fmt.Println("No secrets with source: 'sops' found in app.json")
		return nil
	}

	fmt.Println("Syncing secrets from app.json...")

	for _, file := range results.Files {
		printFileResult(file)
	}

	// Print summary
	printSummary(results)

	// Return error if any files had errors
	if results.HasErrors() {
		return fmt.Errorf("some files had errors during sync")
	}

	return nil
}

// printFileResult handles output for a single file
func printFileResult(file secrets.SyncResult) {
	fmt.Printf("✓ %s\n", file.FilePath)

	if file.Error != nil {
		fmt.Printf("  ✗ Error: %v\n", file.Error)
		fmt.Println()
		return
	}

	if file.WasMissing {
		fmt.Println("  ⚠ File does not exist")
		fmt.Println()
		return
	}

	if file.WasEncrypted {
		fmt.Println("  ⚠ Skipped (file is encrypted)")
		fmt.Println()
		return
	}

	// Print added secrets
	if len(file.AddedSecrets) > 0 {
		for _, secret := range file.AddedSecrets {
			appList := strings.Join(secret.AppNames, ", ")
			fmt.Printf("  • Added %s (used by: %s)\n", secret.Key, appList)
		}
	}

	// Print skipped count if any
	if file.Skipped > 0 {
		fmt.Printf("  • Skipped %d existing secret%s\n", file.Skipped, pluralize(file.Skipped))
	}

	// If nothing was added or skipped
	if file.Added == 0 && file.Skipped == 0 {
		fmt.Println("  • No secrets to sync")
	}

	fmt.Println()
}

// printSummary prints overall sync summary
func printSummary(results *secrets.SyncResults) {
	separator := "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

	fmt.Println(separator)
	fmt.Printf("Summary: %d secret%s added, %d skipped",
		results.TotalAdded(), pluralize(results.TotalAdded()),
		results.TotalSkipped())

	if results.MissingCount() > 0 {
		fmt.Printf(", %d file%s missing", results.MissingCount(), pluralize(results.MissingCount()))
	}
	if results.EncryptedCount() > 0 {
		fmt.Printf(", %d encrypted file%s skipped", results.EncryptedCount(), pluralize(results.EncryptedCount()))
	}

	fmt.Printf("\n%s\n", separator)

	// Helpful hints
	if results.MissingCount() > 0 {
		fmt.Println("\n💡 Run 'webkit scaffold secrets' to create missing files")
	}
	if results.TotalAdded() > 0 {
		fmt.Println("\n💡 Replace placeholder values (REPLACE_ME_*) with actual secrets")
		fmt.Println("💡 Run 'webkit secrets encrypt' to encrypt files before committing")
	}
}

// pluralize returns "s" if count != 1, empty string otherwise
func pluralize(count int) string {
	if count == 1 {
		return ""
	}
	return "s"
}
```

## File: internal/cmd/internal/operations/secrets/util_test.go
```go
package secrets

import (
	"path/filepath"
	"testing"

	"github.com/spf13/afero"
	"github.com/stretchr/testify/require"

	"github.com/ainsleydev/webkit/internal/secrets"
	"github.com/ainsleydev/webkit/pkg/env"
)

func setupTestSecretFiles(t *testing.T, fs afero.Fs, baseDir string) {
	t.Helper()

	environments := []string{env.Development, env.Staging, env.Production}
	for _, e := range environments {
		path := filepath.Join(baseDir, secrets.FilePath, e+".yaml")

		// Create directory
		dir := filepath.Dir(path)
		require.NoError(t, fs.MkdirAll(dir, 0755))

		// Write plaintext secret file with actual secret values
		content := `# ` + e + ` environment secrets
SECRET_KEY: "test_secret_value_` + e + `"
API_TOKEN: "token_123_` + e + `"
DATABASE_PASSWORD: "super_secret_password_` + e + `"
`
		require.NoError(t, afero.WriteFile(fs, path, []byte(content), 0600))
	}
}

func setupSOPSConfig(t *testing.T, fs afero.Fs, baseDir string, agePublicKey string) {
	t.Helper()

	sopsConfig := `creation_rules:
  - path_regex: secrets/.*\.yaml$
    age: ` + agePublicKey + `
`
	configPath := filepath.Join(baseDir, "resources", ".sops.yaml")
	dir := filepath.Dir(configPath)
	require.NoError(t, fs.MkdirAll(dir, 0755))
	require.NoError(t, afero.WriteFile(fs, configPath, []byte(sopsConfig), 0644))
}
```

## File: internal/cmd/internal/operations/secrets/validate.go
```go
package secrets

import (
	"context"
	"fmt"

	"github.com/ainsleydev/webkit/internal/cmd/internal/cmdtools"
	"github.com/ainsleydev/webkit/internal/secrets"
)

// Validate validates that all secrets referenced in app.json exist in SOPS files
func Validate(ctx context.Context, input cmdtools.CommandInput) error {
	app := input.AppDef()

	checkOrphans := input.Command.Bool("check-orphans")
	allowEncrypted := input.Command.Bool("allow-encrypted")

	fmt.Println("Validating secrets from app.json...")

	result, err := secrets.Validate(secrets.ValidateConfig{
		FS:             input.FS,
		AppDef:         app,
		CheckOrphans:   checkOrphans,
		AllowEncrypted: allowEncrypted,
	})
	if err != nil {
		return fmt.Errorf("validation failed: %w", err)
	}

	printValidationResults(result, checkOrphans)

	if !result.Valid {
		return fmt.Errorf("validation failed - missing secrets detected")
	}

	return nil
}

// printValidationResults outputs validation results in a user-friendly format
func printValidationResults(result *secrets.ValidationResult, checkOrphans bool) {
	separator := "═══════════════════════════════════════════════════════════"

	fmt.Println()

	// Print file-by-file results
	for _, file := range result.Files {
		printFileValidation(file)
	}

	fmt.Println(separator)

	// Print summary
	if result.Valid {
		fmt.Println("✅ All secrets validated successfully!")

		if len(result.Files) > 0 {
			totalKeys := 0
			for _, file := range result.Files {
				totalKeys += len(file.MissingKeys)
			}
			fmt.Printf("   Validated %d secret file(s)\n", len(result.Files))
		}
	} else {
		fmt.Println("❌ Validation failed!")
		fmt.Printf("   %d missing secret(s) detected\n", len(result.MissingSecrets))

		// Group by environment
		byEnv := make(map[string][]secrets.MissingSecret)
		for _, missing := range result.MissingSecrets {
			byEnv[missing.Environment] = append(byEnv[missing.Environment], missing)
		}

		fmt.Println("\nMissing secrets:")
		for env, secrets := range byEnv {
			fmt.Printf("\n  %s:\n", env)
			for _, secret := range secrets {
				fmt.Printf("    • %s (used by: %s)\n", secret.Key, secret.AppName)
				fmt.Printf("      Expected in: %s\n", secret.ExpectedIn)
			}
		}
	}

	// Print orphaned keys if checked
	if checkOrphans && len(result.OrphanedKeys) > 0 {
		fmt.Println("\n⚠️  Orphaned keys (in SOPS files but not in app.json):")
		byFile := make(map[string][]string)
		for _, orphan := range result.OrphanedKeys {
			byFile[orphan.FilePath] = append(byFile[orphan.FilePath], orphan.Key)
		}
		for file, keys := range byFile {
			fmt.Printf("\n  %s:\n", file)
			for _, key := range keys {
				fmt.Printf("    • %s\n", key)
			}
		}
	}

	fmt.Println(separator)

	// Helpful hints
	if !result.Valid {
		fmt.Println("\n💡 Run 'webkit secrets sync' to add missing secrets")
		fmt.Println("💡 Run 'webkit secrets validate --check-orphans' to find unused keys")
	}
}

// printFileValidation outputs validation results for a single file
func printFileValidation(file secrets.FileValidation) {
	if !file.Exists {
		fmt.Printf("⚠️  %s - file does not exist\n", file.FilePath)
		return
	}

	if file.Error != nil {
		fmt.Printf("❌ %s - error: %v\n", file.FilePath, file.Error)
		return
	}

	if file.IsEncrypted {
		fmt.Printf("🔒 %s - encrypted (skipped)\n", file.FilePath)
		return
	}

	if len(file.MissingKeys) == 0 {
		fmt.Printf("✅ %s\n", file.FilePath)
	} else {
		fmt.Printf("❌ %s - %d missing key(s)\n", file.FilePath, len(file.MissingKeys))
		for _, key := range file.MissingKeys {
			fmt.Printf("     • %s\n", key)
		}
	}
}
```

## File: internal/cmd/internal/schemas/github/settings.go
```go
package github

// RepoSettings represents the root configuration structure for GitHub
// repository settings.
//
// See: https://github.com/apps/settings
// And: https://github.com/repository-settings/app/blob/master/docs/configuration.md
type RepoSettings struct {
	Repository    Repository     `yaml:"repository"`
	Labels        []Label        `yaml:"labels,omitempty"`
	Milestones    []Milestone    `yaml:"milestones,omitempty"`
	Collaborators []Collaborator `yaml:"collaborators,omitempty"`
	Teams         []Team         `yaml:"teams,omitempty"`
	Branches      []Branch       `yaml:"branches,omitempty"`
}

// Repository contains all repository-level settings
type Repository struct {
	Name                         string   `yaml:"name,omitempty"`
	Description                  string   `yaml:"description,omitempty"`
	Homepage                     string   `yaml:"homepage,omitempty"`
	Topics                       []string `yaml:"topics,omitempty"`
	Private                      bool     `yaml:"private,omitempty"`
	HasIssues                    bool     `yaml:"has_issues,omitempty"`
	HasProjects                  bool     `yaml:"has_projects,omitempty"`
	HasWiki                      bool     `yaml:"has_wiki,omitempty"`
	HasDownloads                 bool     `yaml:"has_downloads,omitempty"`
	DefaultBranch                string   `yaml:"default_branch,omitempty"`
	AllowSquashMerge             bool     `yaml:"allow_squash_merge,omitempty"`
	AllowMergeCommit             bool     `yaml:"allow_merge_commit,omitempty"`
	AllowRebaseMerge             bool     `yaml:"allow_rebase_merge,omitempty"`
	DeleteBranchOnMerge          bool     `yaml:"delete_branch_on_merge,omitempty"`
	EnableAutomatedSecurityFixes bool     `yaml:"enable_automated_security_fixes,omitempty"`
	EnableVulnerabilityAlerts    bool     `yaml:"enable_vulnerability_alerts,omitempty"`
}

// Label represents a GitHub label configuration
type Label struct {
	Name        string `yaml:"name"`
	Color       string `yaml:"color"`
	Description string `yaml:"description,omitempty"`
	NewName     string `yaml:"new_name,omitempty"`
}

// Milestone represents a GitHub milestone configuration
type Milestone struct {
	Title       string `yaml:"title"`
	Description string `yaml:"description,omitempty"`
	State       string `yaml:"state"`
}

// Collaborator represents a repository collaborator
type Collaborator struct {
	Username   string `yaml:"username"`
	Permission string `yaml:"permission"`
}

// Team represents a team with repository access
type Team struct {
	Name       string `yaml:"name"`
	Permission string `yaml:"permission"`
}

// Branch represents branch protection settings
type Branch struct {
	Name       string            `yaml:"name"`
	Protection *BranchProtection `yaml:"protection,omitempty"`
}

// BranchProtection contains branch protection rules
type BranchProtection struct {
	RequiredPullRequestReviews *RequiredPullRequestReviews `yaml:"required_pull_request_reviews,omitempty"`
	RequiredStatusChecks       *RequiredStatusChecks       `yaml:"required_status_checks,omitempty"`
	EnforceAdmins              bool                        `yaml:"enforce_admins,omitempty"`
	RequiredLinearHistory      bool                        `yaml:"required_linear_history,omitempty"`
	Restrictions               *Restrictions               `yaml:"restrictions,omitempty"`
}

// RequiredPullRequestReviews contains PR review requirements
type RequiredPullRequestReviews struct {
	RequiredApprovingReviewCount int                    `yaml:"required_approving_review_count"`
	DismissStaleReviews          bool                   `yaml:"dismiss_stale_reviews,omitempty"`
	RequireCodeOwnerReviews      bool                   `yaml:"require_code_owner_reviews,omitempty"`
	DismissalRestrictions        *DismissalRestrictions `yaml:"dismissal_restrictions,omitempty"`
}

// DismissalRestrictions specifies who can dismiss reviews
type DismissalRestrictions struct {
	Users []string `yaml:"users,omitempty"`
	Teams []string `yaml:"teams,omitempty"`
}

// RequiredStatusChecks contains status check requirements
type RequiredStatusChecks struct {
	Strict   bool     `yaml:"strict"`
	Contexts []string `yaml:"contexts,omitempty"`
}

// Restrictions contains push restrictions
type Restrictions struct {
	Apps  []string `yaml:"apps,omitempty"`
	Users []string `yaml:"users,omitempty"`
	Teams []string `yaml:"teams,omitempty"`
}
```

## File: internal/cmd/internal/schemas/package_json.go
```go
// Code generated from JSON Schema using quicktype. DO NOT EDIT.
// To parse and unparse this JSON data, add this code to your project and do:
//
//    packageJSON, err := UnmarshalPackageJSON(bytes)
//    bytes, err = packageJSON.Marshal()

package schemas

import "encoding/json"

func UnmarshalPackageJSON(data []byte) (PackageJSON, error) {
	var r PackageJSON
	err := json.Unmarshal(data, &r)
	return r, err
}

func (r *PackageJSON) Marshal() ([]byte, error) {
	return json.Marshal(r)
}

type PackageJSON struct {
	Schema            string                       `json:"$schema"`
	Title             string                       `json:"title"`
	Definitions       Definitions                  `json:"definitions"`
	Type              TypeElement                  `json:"type"`
	PatternProperties PackageJSONPatternProperties `json:"patternProperties"`
	Properties        PackageJSONProperties        `json:"properties"`
	AnyOf             []AnyOf                      `json:"anyOf"`
	ID                string                       `json:"$id"`
}

type AnyOf struct {
	Type     TypeElement `json:"type"`
	Not      Not         `json:"not"`
	Required []string    `json:"required,omitempty"`
}

type Not struct {
	Required []string `json:"required"`
}

type Definitions struct {
	Person                        Person                  `json:"person"`
	Dependency                    Dependency              `json:"dependency"`
	DevDependency                 Dependency              `json:"devDependency"`
	OptionalDependency            Dependency              `json:"optionalDependency"`
	PeerDependency                Dependency              `json:"peerDependency"`
	PeerDependencyMeta            PeerDependencyMeta      `json:"peerDependencyMeta"`
	License                       DefinitionsLicenseClass `json:"license"`
	ScriptsInstallAfter           Scripts                 `json:"scriptsInstallAfter"`
	ScriptsPublishAfter           Scripts                 `json:"scriptsPublishAfter"`
	ScriptsRestart                Scripts                 `json:"scriptsRestart"`
	ScriptsStart                  Scripts                 `json:"scriptsStart"`
	ScriptsStop                   Scripts                 `json:"scriptsStop"`
	ScriptsTest                   Scripts                 `json:"scriptsTest"`
	ScriptsUninstallBefore        Scripts                 `json:"scriptsUninstallBefore"`
	ScriptsVersionBefore          Scripts                 `json:"scriptsVersionBefore"`
	PackageExportsEntryPath       PackageExportsEntryPath `json:"packageExportsEntryPath"`
	PackageExportsEntryObject     PackagePortsEntryObject `json:"packageExportsEntryObject"`
	PackageExportsEntry           PackageExportsEntry     `json:"packageExportsEntry"`
	PackageExportsFallback        PackageExportsFallback  `json:"packageExportsFallback"`
	PackageExportsEntryOrFallback PackageExportsEntry     `json:"packageExportsEntryOrFallback"`
	PackageImportsEntryPath       PackageImportsEntryPath `json:"packageImportsEntryPath"`
	PackageImportsEntryObject     PackagePortsEntryObject `json:"packageImportsEntryObject"`
	PackageImportsEntry           PackageExportsEntry     `json:"packageImportsEntry"`
	PackageImportsFallback        PackageExportsFallback  `json:"packageImportsFallback"`
	PackageImportsEntryOrFallback PackageExportsEntry     `json:"packageImportsEntryOrFallback"`
	FundingURL                    FundingURL              `json:"fundingUrl"`
	FundingWay                    FundingWay              `json:"fundingWay"`
	DevEngineDependency           DevEngineDependency     `json:"devEngineDependency"`
}

type Dependency struct {
	Description          string       `json:"description"`
	Type                 TypeElement  `json:"type"`
	AdditionalProperties EngineStrict `json:"additionalProperties"`
}

type EngineStrict struct {
	Type TypeElement `json:"type"`
}

type DevEngineDependency struct {
	Description string                        `json:"description"`
	Type        TypeElement                   `json:"type"`
	Required    []string                      `json:"required"`
	Properties  DevEngineDependencyProperties `json:"properties"`
}

type DevEngineDependencyProperties struct {
	Name    Description `json:"name"`
	Version Description `json:"version"`
	OnFail  TypeClass   `json:"onFail"`
}

type Description struct {
	Type        TypeElement `json:"type"`
	Description string      `json:"description"`
}

type TypeClass struct {
	Type        TypeElement `json:"type"`
	Enum        []string    `json:"enum"`
	Description string      `json:"description"`
	Default     *string     `json:"default,omitempty"`
}

type FundingURL struct {
	Type        TypeElement `json:"type"`
	Format      string      `json:"format"`
	Description string      `json:"description"`
}

type FundingWay struct {
	Type                 TypeElement          `json:"type"`
	Description          string               `json:"description"`
	Properties           FundingWayProperties `json:"properties"`
	AdditionalProperties bool                 `json:"additionalProperties"`
	Required             []string             `json:"required"`
}

type FundingWayProperties struct {
	URL  Author      `json:"url"`
	Type Description `json:"type"`
}

type Author struct {
	Ref string `json:"$ref"`
}

type DefinitionsLicenseClass struct {
	AnyOf []OneOfElement `json:"anyOf"`
}

type OneOfElement struct {
	Type *TypeElement `json:"type,omitempty"`
	Enum []string     `json:"enum,omitempty"`
}

type PackageExportsEntry struct {
	OneOf []Author `json:"oneOf"`
}

type PackagePortsEntryObject struct {
	Type                 TypeElement                         `json:"type"`
	Description          string                              `json:"description"`
	Properties           PackageExportsEntryObjectProperties `json:"properties"`
	PatternProperties    map[string]LicenseValue             `json:"patternProperties"`
	AdditionalProperties bool                                `json:"additionalProperties"`
}

type LicenseValue struct {
	Ref         Ref    `json:"$ref"`
	Description string `json:"description"`
}

type PackageExportsEntryObjectProperties struct {
	Require    LicenseValue `json:"require"`
	Import     LicenseValue `json:"import"`
	ModuleSync *ModuleSync  `json:"module-sync,omitempty"`
	Node       LicenseValue `json:"node"`
	Default    LicenseValue `json:"default"`
	Types      LicenseValue `json:"types"`
}

type ModuleSync struct {
	Ref         Ref    `json:"$ref"`
	Comment     string `json:"$comment"`
	Description string `json:"description"`
}

type PackageExportsEntryPath struct {
	Type        []string `json:"type"`
	Description string   `json:"description"`
	Pattern     string   `json:"pattern"`
}

type PackageExportsFallback struct {
	Type        PackageExportsFallbackType `json:"type"`
	Description string                     `json:"description"`
	Items       Author                     `json:"items"`
}

type PackageImportsEntryPath struct {
	Type        []string `json:"type"`
	Description string   `json:"description"`
}

type PeerDependencyMeta struct {
	Description          string                                 `json:"description"`
	Type                 TypeElement                            `json:"type"`
	AdditionalProperties PeerDependencyMetaAdditionalProperties `json:"additionalProperties"`
}

type PeerDependencyMetaAdditionalProperties struct {
	Type                 TypeElement      `json:"type"`
	AdditionalProperties bool             `json:"additionalProperties"`
	Properties           PurpleProperties `json:"properties"`
}

type PurpleProperties struct {
	Optional Description `json:"optional"`
}

type Person struct {
	Description string           `json:"description"`
	Type        []TypeElement    `json:"type"`
	Required    []string         `json:"required"`
	Properties  PersonProperties `json:"properties"`
}

type PersonProperties struct {
	Name  EngineStrict `json:"name"`
	URL   Email        `json:"url"`
	Email Email        `json:"email"`
}

type Email struct {
	Type   TypeElement `json:"type"`
	Format string      `json:"format"`
}

type Scripts struct {
	Description                string      `json:"description"`
	Type                       TypeElement `json:"type"`
	XIntellijLanguageInjection string      `json:"x-intellij-language-injection"`
}

type PackageJSONPatternProperties struct {
	Empty Empty `json:"^_"`
}

type Empty struct {
	Description string `json:"description"`
	TsType      string `json:"tsType"`
}

type PackageJSONProperties struct {
	Name                 Name                   `json:"name"`
	Version              Description            `json:"version"`
	Description          Description            `json:"description"`
	Keywords             CPUElement             `json:"keywords"`
	Homepage             Description            `json:"homepage"`
	Bugs                 Bugs                   `json:"bugs"`
	License              LicenseValue           `json:"license"`
	Licenses             Licenses               `json:"licenses"`
	Author               Author                 `json:"author"`
	Contributors         PackageExportsFallback `json:"contributors"`
	Maintainers          PackageExportsFallback `json:"maintainers"`
	Files                CPUElement             `json:"files"`
	Main                 Description            `json:"main"`
	Exports              Exports                `json:"exports"`
	Imports              Config                 `json:"imports"`
	Bin                  Bin                    `json:"bin"`
	Type                 TypeClass              `json:"type"`
	Types                Description            `json:"types"`
	Typings              Description            `json:"typings"`
	TypesVersions        TypesVersions          `json:"typesVersions"`
	Man                  Man                    `json:"man"`
	Directories          Directories            `json:"directories"`
	Repository           Repository             `json:"repository"`
	Funding              Funding                `json:"funding"`
	Scripts              ScriptsClass           `json:"scripts"`
	Config               Config                 `json:"config"`
	Dependencies         Author                 `json:"dependencies"`
	DevDependencies      Author                 `json:"devDependencies"`
	OptionalDependencies Author                 `json:"optionalDependencies"`
	PeerDependencies     Author                 `json:"peerDependencies"`
	PeerDependenciesMeta Author                 `json:"peerDependenciesMeta"`
	BundleDependencies   BundleDependencies     `json:"bundleDependencies"`
	BundledDependencies  BundleDependencies     `json:"bundledDependencies"`
	Resolutions          Description            `json:"resolutions"`
	Overrides            Description            `json:"overrides"`
	PackageManager       PackageManager         `json:"packageManager"`
	Engines              Engines                `json:"engines"`
	Volta                Volta                  `json:"volta"`
	EngineStrict         EngineStrict           `json:"engineStrict"`
	OS                   CPUElement             `json:"os"`
	CPU                  CPUElement             `json:"cpu"`
	DevEngines           DevEngines             `json:"devEngines"`
	PreferGlobal         Description            `json:"preferGlobal"`
	Private              Private                `json:"private"`
	PublishConfig        PublishConfig          `json:"publishConfig"`
	Dist                 Dist                   `json:"dist"`
	Readme               EngineStrict           `json:"readme"`
	Module               Description            `json:"module"`
	Esnext               Esnext                 `json:"esnext"`
	Workspaces           Workspaces             `json:"workspaces"`
	Jspm                 Author                 `json:"jspm"`
	EslintConfig         Author                 `json:"eslintConfig"`
	Prettier             Author                 `json:"prettier"`
	Stylelint            Author                 `json:"stylelint"`
	Ava                  Author                 `json:"ava"`
	Release              Author                 `json:"release"`
	Jscpd                Author                 `json:"jscpd"`
	Pnpm                 Config                 `json:"pnpm"`
	Stackblitz           Config                 `json:"stackblitz"`
}

type Bin struct {
	Type                 []TypeElement `json:"type"`
	AdditionalProperties EngineStrict  `json:"additionalProperties"`
}

type Bugs struct {
	Description string         `json:"description"`
	Type        []TypeElement  `json:"type"`
	Properties  BugsProperties `json:"properties"`
}

type BugsProperties struct {
	URL   FundingURL `json:"url"`
	Email FundingURL `json:"email"`
}

type BundleDependencies struct {
	Description string  `json:"description"`
	OneOf       []OneOf `json:"oneOf"`
}

type OneOf struct {
	Type  string        `json:"type"`
	Items *EngineStrict `json:"items,omitempty"`
}

type CPUProperties struct {
	Packages CPUElement `json:"packages"`
	Nohoist  CPUElement `json:"nohoist"`
}

type CPUElement struct {
	Description *string                    `json:"description,omitempty"`
	Type        PackageExportsFallbackType `json:"type"`
	Items       *EngineStrict              `json:"items,omitempty"`
	Properties  *CPUProperties             `json:"properties,omitempty"`
}

type ConfigProperties struct {
	Overrides                   *Description             `json:"overrides,omitempty"`
	PackageExtensions           *Config                  `json:"packageExtensions,omitempty"`
	PeerDependencyRules         *PeerDependencyRules     `json:"peerDependencyRules,omitempty"`
	NeverBuiltDependencies      *CPUElement              `json:"neverBuiltDependencies,omitempty"`
	OnlyBuiltDependencies       *CPUElement              `json:"onlyBuiltDependencies,omitempty"`
	OnlyBuiltDependenciesFile   *Description             `json:"onlyBuiltDependenciesFile,omitempty"`
	IgnoredBuiltDependencies    *CPUElement              `json:"ignoredBuiltDependencies,omitempty"`
	AllowedDeprecatedVersions   *Description             `json:"allowedDeprecatedVersions,omitempty"`
	PatchedDependencies         *Description             `json:"patchedDependencies,omitempty"`
	AllowNonAppliedPatches      *Description             `json:"allowNonAppliedPatches,omitempty"`
	AllowUnusedPatches          *Description             `json:"allowUnusedPatches,omitempty"`
	UpdateConfig                *UpdateConfig            `json:"updateConfig,omitempty"`
	ConfigDependencies          *Description             `json:"configDependencies,omitempty"`
	AuditConfig                 *AuditConfig             `json:"auditConfig,omitempty"`
	RequiredScripts             *CPUElement              `json:"requiredScripts,omitempty"`
	SupportedArchitectures      *Config                  `json:"supportedArchitectures,omitempty"`
	IgnoredOptionalDependencies *CPUElement              `json:"ignoredOptionalDependencies,omitempty"`
	ExecutionEnv                *ExecutionEnv            `json:"executionEnv,omitempty"`
	OS                          *OneOf                   `json:"os,omitempty"`
	CPU                         *OneOf                   `json:"cpu,omitempty"`
	Libc                        *OneOf                   `json:"libc,omitempty"`
	InstallDependencies         *Description             `json:"installDependencies,omitempty"`
	StartCommand                *PackageImportsEntryPath `json:"startCommand,omitempty"`
	CompileTrigger              *Private                 `json:"compileTrigger,omitempty"`
	Env                         *Description             `json:"env,omitempty"`
}

type Config struct {
	Description          string                   `json:"description"`
	Type                 TypeElement              `json:"type"`
	AdditionalProperties bool                     `json:"additionalProperties"`
	PatternProperties    *ConfigPatternProperties `json:"patternProperties,omitempty"`
	Properties           *ConfigProperties        `json:"properties,omitempty"`
}

type AuditConfig struct {
	Type                 TypeElement           `json:"type"`
	Properties           AuditConfigProperties `json:"properties"`
	AdditionalProperties bool                  `json:"additionalProperties"`
}

type AuditConfigProperties struct {
	IgnoreCves  IgnoreCvesClass `json:"ignoreCves"`
	IgnoreGhsas IgnoreCvesClass `json:"ignoreGhsas"`
}

type IgnoreCvesClass struct {
	Description string                     `json:"description"`
	Type        PackageExportsFallbackType `json:"type"`
	Items       Items                      `json:"items"`
}

type Items struct {
	Type    TypeElement `json:"type"`
	Pattern string      `json:"pattern"`
}

type Private struct {
	Description string         `json:"description"`
	OneOf       []OneOfElement `json:"oneOf"`
}

type ExecutionEnv struct {
	Type                 TypeElement            `json:"type"`
	Properties           ExecutionEnvProperties `json:"properties"`
	AdditionalProperties bool                   `json:"additionalProperties"`
}

type ExecutionEnvProperties struct {
	NodeVersion Description `json:"nodeVersion"`
}

type PeerDependencyRules struct {
	Type                 TypeElement                   `json:"type"`
	Properties           PeerDependencyRulesProperties `json:"properties"`
	AdditionalProperties bool                          `json:"additionalProperties"`
}

type PeerDependencyRulesProperties struct {
	IgnoreMissing   CPUElement  `json:"ignoreMissing"`
	AllowedVersions Description `json:"allowedVersions"`
	AllowAny        CPUElement  `json:"allowAny"`
}

type UpdateConfig struct {
	Type                 TypeElement            `json:"type"`
	Properties           UpdateConfigProperties `json:"properties"`
	AdditionalProperties bool                   `json:"additionalProperties"`
}

type UpdateConfigProperties struct {
	IgnoreDependencies CPUElement `json:"ignoreDependencies"`
}

type ConfigPatternProperties struct {
	Empty             *LicenseValue `json:"^#.+$,omitempty"`
	PatternProperties *Class        `json:"^.+$,omitempty"`
}

type Class struct {
	Type                 TypeElement `json:"type"`
	Properties           Properties  `json:"properties"`
	AdditionalProperties bool        `json:"additionalProperties"`
}

type Properties struct {
	Dependencies         Author `json:"dependencies"`
	OptionalDependencies Author `json:"optionalDependencies"`
	PeerDependencies     Author `json:"peerDependencies"`
	PeerDependenciesMeta Author `json:"peerDependenciesMeta"`
}

type DevEngines struct {
	Description string               `json:"description"`
	Type        TypeElement          `json:"type"`
	Properties  DevEnginesProperties `json:"properties"`
}

type DevEnginesProperties struct {
	OS             LibcClass `json:"os"`
	CPU            LibcClass `json:"cpu"`
	Libc           LibcClass `json:"libc"`
	Runtime        LibcClass `json:"runtime"`
	PackageManager LibcClass `json:"packageManager"`
}

type LibcClass struct {
	OneOf       []CPUOneOf `json:"oneOf"`
	Description string     `json:"description"`
}

type CPUOneOf struct {
	Ref   *string                     `json:"$ref,omitempty"`
	Type  *PackageExportsFallbackType `json:"type,omitempty"`
	Items *Author                     `json:"items,omitempty"`
}

type Directories struct {
	Type       TypeElement           `json:"type"`
	Properties DirectoriesProperties `json:"properties"`
}

type DirectoriesProperties struct {
	Bin     Description  `json:"bin"`
	Doc     Description  `json:"doc"`
	Example Description  `json:"example"`
	LIB     Description  `json:"lib"`
	Man     Description  `json:"man"`
	Test    EngineStrict `json:"test"`
}

type Dist struct {
	Type       TypeElement    `json:"type"`
	Properties DistProperties `json:"properties"`
}

type DistProperties struct {
	Shasum  EngineStrict `json:"shasum"`
	Tarball EngineStrict `json:"tarball"`
}

type Engines struct {
	Type                 TypeElement       `json:"type"`
	Properties           EnginesProperties `json:"properties"`
	AdditionalProperties EngineStrict      `json:"additionalProperties"`
}

type EnginesProperties struct {
	Node EngineStrict `json:"node"`
}

type Esnext struct {
	Description          string           `json:"description"`
	Type                 []TypeElement    `json:"type"`
	Properties           EsnextProperties `json:"properties"`
	AdditionalProperties EngineStrict     `json:"additionalProperties"`
}

type EsnextProperties struct {
	Main    EngineStrict `json:"main"`
	Browser EngineStrict `json:"browser"`
}

type Exports struct {
	Description string         `json:"description"`
	OneOf       []ExportsOneOf `json:"oneOf"`
}

type ExportsOneOf struct {
	Ref                  *string                 `json:"$ref,omitempty"`
	Description          *string                 `json:"description,omitempty"`
	Type                 *TypeElement            `json:"type,omitempty"`
	Properties           *OneOfProperties        `json:"properties,omitempty"`
	PatternProperties    *OneOfPatternProperties `json:"patternProperties,omitempty"`
	AdditionalProperties *bool                   `json:"additionalProperties,omitempty"`
}

type OneOfPatternProperties struct {
	Empty LicenseValue `json:"^\\./.+"`
}

type OneOfProperties struct {
	Empty LicenseValue `json:"."`
}

type Funding struct {
	OneOf []FundingOneOf `json:"oneOf"`
}

type FundingOneOf struct {
	Ref         *string                     `json:"$ref,omitempty"`
	Type        *PackageExportsFallbackType `json:"type,omitempty"`
	Items       *PackageExportsEntry        `json:"items,omitempty"`
	MinItems    *int64                      `json:"minItems,omitempty"`
	UniqueItems *bool                       `json:"uniqueItems,omitempty"`
}

type Licenses struct {
	Description string                     `json:"description"`
	Type        PackageExportsFallbackType `json:"type"`
	Items       LicensesItems              `json:"items"`
}

type LicensesItems struct {
	Type       TypeElement     `json:"type"`
	Properties ItemsProperties `json:"properties"`
}

type ItemsProperties struct {
	Type Author `json:"type"`
	URL  Email  `json:"url"`
}

type Man struct {
	Type        []string     `json:"type"`
	Description string       `json:"description"`
	Items       EngineStrict `json:"items"`
}

type Name struct {
	Description string      `json:"description"`
	Type        TypeElement `json:"type"`
	MaxLength   int64       `json:"maxLength"`
	MinLength   int64       `json:"minLength"`
	Pattern     string      `json:"pattern"`
}

type PackageManager struct {
	Description string      `json:"description"`
	Type        TypeElement `json:"type"`
	Pattern     string      `json:"pattern"`
}

type PublishConfig struct {
	Type                 TypeElement             `json:"type"`
	Properties           PublishConfigProperties `json:"properties"`
	AdditionalProperties bool                    `json:"additionalProperties"`
}

type PublishConfigProperties struct {
	Access     OneOfElement `json:"access"`
	Tag        EngineStrict `json:"tag"`
	Registry   Email        `json:"registry"`
	Provenance EngineStrict `json:"provenance"`
}

type Repository struct {
	Description string               `json:"description"`
	Type        []TypeElement        `json:"type"`
	Properties  RepositoryProperties `json:"properties"`
}

type RepositoryProperties struct {
	Type      EngineStrict `json:"type"`
	URL       EngineStrict `json:"url"`
	Directory EngineStrict `json:"directory"`
}

type ScriptsClass struct {
	Description          string                      `json:"description"`
	Type                 TypeElement                 `json:"type"`
	Properties           ScriptsProperties           `json:"properties"`
	AdditionalProperties ScriptsAdditionalProperties `json:"additionalProperties"`
}

type ScriptsAdditionalProperties struct {
	Type                       TypeElement `json:"type"`
	TsType                     string      `json:"tsType"`
	XIntellijLanguageInjection string      `json:"x-intellij-language-injection"`
}

type ScriptsProperties struct {
	Lint           Description `json:"lint"`
	Prepublish     Description `json:"prepublish"`
	Prepare        Description `json:"prepare"`
	PrepublishOnly Description `json:"prepublishOnly"`
	Prepack        Description `json:"prepack"`
	Postpack       Description `json:"postpack"`
	Publish        Description `json:"publish"`
	Postpublish    Author      `json:"postpublish"`
	Preinstall     Description `json:"preinstall"`
	Install        Author      `json:"install"`
	Postinstall    Author      `json:"postinstall"`
	Preuninstall   Author      `json:"preuninstall"`
	Uninstall      Author      `json:"uninstall"`
	Postuninstall  Description `json:"postuninstall"`
	Preversion     Author      `json:"preversion"`
	Version        Author      `json:"version"`
	Postversion    Description `json:"postversion"`
	Pretest        Author      `json:"pretest"`
	Test           Author      `json:"test"`
	Posttest       Author      `json:"posttest"`
	Prestop        Author      `json:"prestop"`
	Stop           Author      `json:"stop"`
	Poststop       Author      `json:"poststop"`
	Prestart       Author      `json:"prestart"`
	Start          Author      `json:"start"`
	Poststart      Author      `json:"poststart"`
	Prerestart     Author      `json:"prerestart"`
	Restart        Author      `json:"restart"`
	Postrestart    Author      `json:"postrestart"`
	Serve          Description `json:"serve"`
}

type TypesVersions struct {
	Description          string                            `json:"description"`
	Type                 TypeElement                       `json:"type"`
	AdditionalProperties TypesVersionsAdditionalProperties `json:"additionalProperties"`
}

type TypesVersionsAdditionalProperties struct {
	Description          string                                `json:"description"`
	Type                 TypeElement                           `json:"type"`
	Properties           FluffyProperties                      `json:"properties"`
	PatternProperties    AdditionalPropertiesPatternProperties `json:"patternProperties"`
	AdditionalProperties bool                                  `json:"additionalProperties"`
}

type AdditionalPropertiesPatternProperties struct {
	PatternProperties CPUElement      `json:"^[^*]+$"`
	Empty             IgnoreCvesClass `json:"^[^*]*\\*[^*]*$"`
}

type FluffyProperties struct {
	Empty IgnoreCvesClass `json:"*"`
}

type Volta struct {
	Description       string                 `json:"description"`
	Type              TypeElement            `json:"type"`
	Properties        VoltaProperties        `json:"properties"`
	PatternProperties VoltaPatternProperties `json:"patternProperties"`
}

type VoltaPatternProperties struct {
	NodeNpmPnpmYarn EngineStrict `json:"(node|npm|pnpm|yarn)"`
}

type VoltaProperties struct {
	Extends Description `json:"extends"`
}

type Workspaces struct {
	Description string       `json:"description"`
	AnyOf       []CPUElement `json:"anyOf"`
}

type TypeElement string

const (
	Boolean      TypeElement = "boolean"
	PurpleObject TypeElement = "object"
	String       TypeElement = "string"
)

type Ref string

const (
	DefinitionsLicense                       Ref = "#/definitions/license"
	DefinitionsPackageExportsEntryOrFallback Ref = "#/definitions/packageExportsEntryOrFallback"
	DefinitionsPackageImportsEntryOrFallback Ref = "#/definitions/packageImportsEntryOrFallback"
)

type PackageExportsFallbackType string

const (
	Array        PackageExportsFallbackType = "array"
	FluffyObject PackageExportsFallbackType = "object"
)
```

## File: internal/cmd/env.go
```go
package cmd

import (
	"github.com/urfave/cli/v3"
)

var envCmd = &cli.Command{
	Name:  "env",
	Usage: "Generate .env files for local development",
	Description: "Decrypts SOPS files and generates .env files in each app directory. " +
		"Resolves all environment variable types (value, resource, sops) for the development environment. " +
		"Use this for local development setup.",
}
```

## File: internal/config/config_test.go
```go
package config

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestDir(t *testing.T) {
	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	dir, err := Dir()
	require.NoError(t, err)

	expected := filepath.Join(tmpHome, ".config", "webkit")
	assert.Equal(t, expected, dir)
}

func TestPath(t *testing.T) {
	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	t.Run("Single File", func(t *testing.T) {
		path, err := Path("age.key")
		require.NoError(t, err)

		expected := filepath.Join(tmpHome, ".config", "webkit", "age.key")
		assert.Equal(t, expected, path)
	})

	t.Run("Nested File", func(t *testing.T) {
		path, err := Path("secrets/prod.yaml")
		require.NoError(t, err)

		expected := filepath.Join(tmpHome, ".config", "webkit", "secrets", "prod.yaml")
		assert.Equal(t, expected, path)
	})
}

func TestReadWrite(t *testing.T) {
	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	t.Run("Write And Read", func(t *testing.T) {
		content := []byte("test content")

		err := Write("test.txt", content, 0600)
		require.NoError(t, err)

		read, err := Read("test.txt")
		require.NoError(t, err)
		assert.Equal(t, content, read)
	})

	t.Run("Creates Config Dir Automatically", func(t *testing.T) {
		// Config dir shouldn't exist yet for this test
		newHome := t.TempDir()
		t.Setenv("HOME", newHome)

		err := Write("auto-create.txt", []byte("test"), 0600)
		require.NoError(t, err)

		// Dir should exist now
		dir, err := Dir()
		require.NoError(t, err)

		info, err := os.Stat(dir)
		require.NoError(t, err)
		assert.True(t, info.IsDir())
	})

	t.Run("Overwrites Existing File", func(t *testing.T) {
		err := Write("overwrite.txt", []byte("first"), 0600)
		require.NoError(t, err)

		err = Write("overwrite.txt", []byte("second"), 0600)
		require.NoError(t, err)

		read, err := Read("overwrite.txt")
		require.NoError(t, err)
		assert.Equal(t, []byte("second"), read)
	})

	t.Run("Read Non-Existent File", func(t *testing.T) {
		_, err := Read("does-not-exist.txt")
		assert.Error(t, err)
	})

	t.Run("File Permissions", func(t *testing.T) {
		err := Write("perms.txt", []byte("test"), 0600)
		require.NoError(t, err)

		path, err := Path("perms.txt")
		require.NoError(t, err)

		info, err := os.Stat(path)
		require.NoError(t, err)
		assert.Equal(t, os.FileMode(0600), info.Mode().Perm())
	})
}

func TestEnsureDir(t *testing.T) {
	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	// Directory shouldn't exist yet
	dir, err := Dir()
	require.NoError(t, err)
	_, err = os.Stat(dir)
	assert.True(t, os.IsNotExist(err))

	// Create it
	err = ensureDir()
	require.NoError(t, err)

	// Should exist now
	info, err := os.Stat(dir)
	require.NoError(t, err)
	assert.True(t, info.IsDir())

	// Should be idempotent
	err = ensureDir()
	assert.NoError(t, err)
}
```

## File: internal/config/config.go
```go
package config

import (
	"fmt"
	"os"
	"path/filepath"
)

const (
	// AppName is the name of the application
	AppName = "webkit"

	// DirName is the config directory name under user's home
	DirName = ".config"
)

// Read reads a file from the WebKit config directory.
func Read(filename string) ([]byte, error) {
	path, err := Path(filename)
	if err != nil {
		return nil, err
	}
	return os.ReadFile(path)
}

// Write writes a file to the WebKit config directory.
// Creates the config directory if it doesn't exist.
func Write(filename string, data []byte, perm os.FileMode) error {
	if err := ensureDir(); err != nil {
		return fmt.Errorf("creating config directory: %w", err)
	}

	path, err := Path(filename)
	if err != nil {
		return err
	}

	return os.WriteFile(path, data, perm)
}

// Dir returns the WebKit configuration directory path.
// Returns: ~/.config/webkit
func Dir() (string, error) {
	home, err := os.UserHomeDir()
	if err != nil {
		return "", fmt.Errorf("getting home directory: %w", err)
	}
	return filepath.Join(home, DirName, AppName), nil
}

// Path returns the full path to a file in the WebKit config directory.
// Example: config.Path("age.key") returns ~/.config/webkit/age.key
func Path(filename string) (string, error) {
	dir, err := Dir()
	if err != nil {
		return "", err
	}
	return filepath.Join(dir, filename), nil
}

// ensureDir creates the WebKit config directory if it doesn't exist.
func ensureDir() error {
	dir, err := Dir()
	if err != nil {
		return err
	}
	return os.MkdirAll(dir, 0755)
}
```

## File: internal/executil/exec_test.go
```go
package executil

import (
	"bytes"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestExecRunner_Run(t *testing.T) {
	t.Parallel()

	tmpDir := t.TempDir()

	tt := map[string]struct {
		input       Command
		wantOutput  []string
		wantCmdLine string
	}{
		"Simple": {
			input:       NewCommand("echo", "hello", "world"),
			wantOutput:  []string{"hello world"},
			wantCmdLine: "echo hello world",
		},
		"With Stdout": {
			input: func() Command {
				var buf bytes.Buffer
				c := NewCommand("echo", "test")
				c.Stdout = &buf
				return c
			}(),
			wantOutput:  []string{"test"},
			wantCmdLine: "echo test",
		},
		"With Stderr": {
			input: func() Command {
				var buf bytes.Buffer
				c := NewCommand("sh", "-c", "echo error >&2")
				c.Stderr = &buf
				return c
			}(),
			wantOutput:  []string{"error"},
			wantCmdLine: "sh -c echo error >&2",
		},
		"With Env": {
			input: func() Command {
				c := NewCommand("sh", "-c", "echo $TEST_VAR")
				c.Env = map[string]string{"TEST_VAR": "hello"}
				return c
			}(),
			wantOutput:  []string{"hello"},
			wantCmdLine: "sh -c echo $TEST_VAR",
		},
		"With Dir": {
			input: func() Command {
				c := NewCommand("pwd")
				c.Dir = tmpDir
				return c
			}(),
			wantOutput:  []string{tmpDir},
			wantCmdLine: "pwd",
		},
		"With Stdin": {
			input: func() Command {
				c := NewCommand("cat")
				c.Stdin = strings.NewReader("test input\n")
				return c
			}(),
			wantOutput:  []string{"test input"},
			wantCmdLine: "cat",
		},
		"With Stdout & Stderr": {
			input: func() Command {
				var stdoutBuf, stderrBuf bytes.Buffer
				c := NewCommand("sh", "-c", "echo stdout; echo stderr >&2")
				c.Stdout = &stdoutBuf
				c.Stderr = &stderrBuf
				return c
			}(),
			wantOutput:  []string{"stdout", "stderr"},
			wantCmdLine: "sh -c echo stdout; echo stderr >&2",
		},
		"Multiple Env Vars": {
			input: func() Command {
				c := NewCommand("sh", "-c", "echo $VAR1 $VAR2")
				c.Env = map[string]string{"VAR1": "hello", "VAR2": "world"}
				return c
			}(),
			wantOutput:  []string{"hello", "world"},
			wantCmdLine: "sh -c echo $VAR1 $VAR2",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			t.Parallel()
			runner := DefaultRunner()

			got, err := runner.Run(t.Context(), test.input)
			assert.NoError(t, err)
			assert.Equal(t, test.wantCmdLine, got.CmdLine)
			for _, w := range test.wantOutput {
				assert.Contains(t, got.Output, w)
			}
		})
	}

	t.Run("Bad Exit Code", func(t *testing.T) {
		t.Parallel()

		runner := DefaultRunner()
		cmd := NewCommand("sh", "-c", "exit 42")

		_, err := runner.Run(t.Context(), cmd)
		assert.Error(t, err)
		assert.ErrorContains(t, err, "exit status 42")
	})

	t.Run("Command Not Found", func(t *testing.T) {
		t.Parallel()

		runner := DefaultRunner()
		cmd := NewCommand("this-command-does-not-exist")

		_, err := runner.Run(t.Context(), cmd)
		assert.Error(t, err)
	})
}
```

## File: internal/executil/exec.go
```go
package executil

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"os"
	"os/exec"
)

// ExecRunner implements Runner by using cmd.Execute to
// run a Command.
type ExecRunner struct{}

// DefaultRunner returns a real command runner.
func DefaultRunner() Runner {
	return &ExecRunner{}
}

func (e ExecRunner) Run(ctx context.Context, cmd Command) (Result, error) {
	result := Result{
		CmdLine: cmd.String(),
	}

	// Prepare command
	c := exec.CommandContext(ctx, cmd.Name, cmd.Args...)
	c.Dir = cmd.Dir
	c.Stdin = cmd.Stdin

	// Merge env
	env := os.Environ()
	for k, v := range cmd.Env {
		env = append(env, fmt.Sprintf("%s=%s", k, v))
	}
	c.Env = env

	var stdoutBuf, stderrBuf bytes.Buffer

	// Set output
	if cmd.Stdout != nil {
		c.Stdout = io.MultiWriter(cmd.Stdout, &stdoutBuf)
	} else {
		c.Stdout = &stdoutBuf
	}

	if cmd.Stderr != nil {
		c.Stderr = io.MultiWriter(cmd.Stderr, &stderrBuf)
	} else {
		c.Stderr = &stderrBuf
	}

	// Run
	err := c.Run()
	result.Output = stdoutBuf.String() + stderrBuf.String()
	return result, err
}
```

## File: internal/executil/mem_test.go
```go
package executil

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestMemRunner_Run(t *testing.T) {
	t.Parallel()

	t.Run("With Stub", func(t *testing.T) {
		t.Parallel()

		runner := NewMemRunner()
		runner.AddStub("git status", Result{Output: "nothing to commit"}, nil)
		cmd := NewCommand("git", "status")

		got, err := runner.Run(t.Context(), cmd)
		assert.NoError(t, err)
		assert.Equal(t, "git status", got.CmdLine)
		assert.Equal(t, "nothing to commit", got.Output)
	})

	t.Run("No Stub", func(t *testing.T) {
		t.Parallel()

		runner := NewMemRunner()
		cmd := NewCommand("git", "status")

		got, err := runner.Run(t.Context(), cmd)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "no stub for command")
		assert.Equal(t, "git status", got.CmdLine)
	})

	t.Run("Prefix Matching", func(t *testing.T) {
		t.Parallel()

		runner := NewMemRunner()
		runner.AddStub("git", Result{Output: "git output"}, nil)
		cmd := NewCommand("git", "status")

		got, err := runner.Run(t.Context(), cmd)
		assert.NoError(t, err)
		assert.Equal(t, "git output", got.Output)
		assert.Equal(t, "git status", got.CmdLine)
	})

	t.Run("With Error", func(t *testing.T) {
		t.Parallel()

		runner := NewMemRunner()
		runner.AddStub("fail", Result{
			Output: "error output",
		}, fmt.Errorf("command failed"))

		cmd := NewCommand("fail")
		got, err := runner.Run(t.Context(), cmd)

		assert.Error(t, err)
		assert.ErrorContains(t, err, "command failed")
		assert.Equal(t, "error output", got.Output)
		assert.Equal(t, "fail", got.CmdLine)
	})
}

func TestMemRunner_Calls(t *testing.T) {
	t.Parallel()

	runner := NewMemRunner()
	runner.AddStub("echo", Result{Output: "test"}, nil)

	cmd1 := NewCommand("echo", "hello")
	cmd2 := NewCommand("echo", "world")

	runner.Run(t.Context(), cmd1)
	runner.Run(t.Context(), cmd2)

	calls := runner.Calls()

	assert.Len(t, calls, 2)
	assert.Equal(t, "echo hello", calls[0].String())
	assert.Equal(t, "echo world", calls[1].String())
}

func TestMemRunner_Reset(t *testing.T) {
	t.Parallel()

	runner := NewMemRunner()
	runner.AddStub("test", Result{Output: "output"}, nil)

	cmd := NewCommand("test", "arg")
	runner.Run(t.Context(), cmd)

	assert.Len(t, runner.Calls(), 1)

	runner.Reset()

	assert.Len(t, runner.Calls(), 0)

	// Stubs should be cleared too
	_, err := runner.Run(t.Context(), cmd)
	assert.Error(t, err)
}
```

## File: internal/executil/mem.go
```go
package executil

import (
	"context"
	"fmt"
	"strings"
	"sync"
)

// MemRunner implements Runner by stubbing calls when
// a command is run.
type MemRunner struct {
	mu    sync.Mutex
	calls []Command
	stubs map[string]Result
	errs  map[string]error
}

// NewMemRunner creates a new runner that stubs calls.
func NewMemRunner() *MemRunner {
	return &MemRunner{
		stubs: make(map[string]Result),
		errs:  make(map[string]error),
	}
}

func (r *MemRunner) Run(_ context.Context, cmd Command) (Result, error) {
	r.mu.Lock()
	defer r.mu.Unlock()

	r.calls = append(r.calls, cmd)

	cmdLine := cmd.String()
	for prefix, stub := range r.stubs {
		if strings.HasPrefix(cmdLine, prefix) {
			stub.CmdLine = cmdLine
			return stub, r.errs[prefix] // Returns error if set
		}
	}

	return Result{
		CmdLine: cmdLine,
		Output:  "",
	}, fmt.Errorf("no stub for command: %s", cmdLine)
}

// AddStub registers a command prefix and a fake result.
func (r *MemRunner) AddStub(prefix string, result Result, err error) {
	r.mu.Lock()
	defer r.mu.Unlock()
	r.stubs[prefix] = result
	if err != nil {
		r.errs[prefix] = err
	} else {
		delete(r.errs, prefix)
	}
}

// Calls returns all commands that were executed.
func (r *MemRunner) Calls() []Command {
	r.mu.Lock()
	defer r.mu.Unlock()
	return append([]Command(nil), r.calls...)
}

// Reset clears recorded calls.
func (r *MemRunner) Reset() {
	r.mu.Lock()
	defer r.mu.Unlock()
	r.calls = nil
	r.stubs = make(map[string]Result)
}
```

## File: internal/fsext/copier_test.go
```go
package fsext

import (
	"embed"
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

//go:embed testdata/*
var testFS embed.FS

func TestCopyAllEmbed(t *testing.T) {
	t.Parallel()

	dest, err := os.MkdirTemp("", "copy-all")
	require.NoError(t, err)

	err = CopyAllEmbed(testFS, dest)
	assert.NoError(t, err)

	var files []string
	_ = filepath.Walk(dest, func(path string, info os.FileInfo, err error) error {
		if err == nil && !info.IsDir() {
			files = append(files, filepath.Base(path))
		}
		return nil
	})

	assert.Contains(t, files, "one.txt")
	assert.Contains(t, files, "nested.txt")
}

func TestCopyFromEmbed(t *testing.T) {
	t.Parallel()

	t.Run("Valid Copy", func(t *testing.T) {
		t.Parallel()

		dest, err := os.MkdirTemp("", "copy-ok")
		require.NoError(t, err)

		err = CopyFromEmbed(testFS, "testdata", dest)
		assert.NoError(t, err)

		var files []string
		_ = filepath.Walk(dest, func(path string, info os.FileInfo, err error) error {
			if err == nil && !info.IsDir() {
				files = append(files, filepath.Base(path))
			}
			return nil
		})

		assert.Contains(t, files, "one.txt")
		assert.Contains(t, files, "nested.txt")
	})

	t.Run("Missing Source", func(t *testing.T) {
		t.Parallel()

		dest, err := os.MkdirTemp("", "copy-missing")
		require.NoError(t, err)

		err = CopyFromEmbed(testFS, "does-not-exist", dest)
		assert.Error(t, err)
	})

	t.Run("Permission Error", func(t *testing.T) {
		t.Parallel()

		dir := t.TempDir()
		noWrite := filepath.Join(dir, "readonly")
		err := os.Mkdir(noWrite, 0o500)
		require.NoError(t, err)

		err = CopyFromEmbed(testFS, "testdata", noWrite)
		assert.Error(t, err)
	})

	t.Run("Bad Relative Path", func(t *testing.T) {
		t.Parallel()

		dest, err := os.MkdirTemp("", "copy-rel")
		require.NoError(t, err)

		err = CopyFromEmbed(testFS, "testdata", dest)
		assert.NoError(t, err)
	})
}
```

## File: internal/fsext/copier.go
```go
package fsext

import (
	"embed"
	"io/fs"
	"os"
	"path/filepath"
)

// CopyAllEmbed copies everything from the root of the embedded
// FS to destDir.
func CopyAllEmbed(efs embed.FS, destDir string) error {
	return CopyFromEmbed(efs, ".", destDir)
}

// CopyFromEmbed recursively copies all files from an embed.FS
// directory to a destination.
func CopyFromEmbed(efs embed.FS, srcDir, destDir string) error {
	return fs.WalkDir(efs, srcDir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		rel, err := filepath.Rel(srcDir, path)
		if err != nil {
			return err
		}

		target := filepath.Join(destDir, rel)

		if d.IsDir() {
			return os.MkdirAll(target, os.ModePerm)
		}

		data, err := efs.ReadFile(path)
		if err != nil {
			return err
		}

		return os.WriteFile(target, data, 0o644)
	})
}
```

## File: internal/print/print.go
```go
package print

// See: https://github.com/hay-kot/scaffold/blob/main/internal/printer/printer.go
// See: https://github.com/charmbracelet/lipgloss
```

## File: internal/scaffold/generate_test.go
```go
package scaffold

import (
	"fmt"
	"os"
	"testing"
	"text/template"

	"github.com/goccy/go-json"
	"github.com/goccy/go-yaml"
	"github.com/spf13/afero"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestFileGenerator_Bytes(t *testing.T) {
	t.Parallel()

	tt := map[string]struct {
		fs      afero.Fs
		path    string
		data    []byte
		wantErr bool
	}{
		"MkdirAll Fails (read-only fs)": {
			fs:      afero.NewReadOnlyFs(afero.NewMemMapFs()),
			path:    "dir/file.txt",
			data:    []byte("hello"),
			wantErr: true,
		},
		//"WriteFile fails (path is directory)": {
		//	fs:      failWriteFs{afero.NewMemMapFs()},
		//	path:    "dir/file.txt",
		//	data:    []byte("hello"),
		//	wantErr: true,
		//},
		"Valid Write": {
			fs:      afero.NewMemMapFs(),
			path:    "dir/file.txt",
			data:    []byte("hello"),
			wantErr: false,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			t.Parallel()

			gen := New(test.fs)

			err := gen.Bytes(test.path, test.data)
			assert.Equal(t, test.wantErr, err != nil)

			fmt.Println(err)

			if !test.wantErr {
				got, _ := afero.ReadFile(test.fs, test.path)
				assert.Equal(t, test.data, got)
			}
		})
	}
}

func TestFileGenerator_Template(t *testing.T) {
	t.Parallel()

	path := "file.txt"
	gitIgnoreTpl := template.Must(template.New("gitignore").Parse(".DS_Store"))

	t.Run("Skips Scaffolding", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()
		gen := New(fs)

		err := afero.WriteFile(fs, path, []byte("data"), os.ModePerm)
		require.NoError(t, err)

		err = gen.Template(path, gitIgnoreTpl, nil, WithScaffoldMode())
		assert.NoError(t, err, "Scaffold is skipped, file exists")
	})

	t.Run("Template Fails", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()
		gen := New(fs)
		tpl := template.Must(template.New("test").Parse("{{.NonExistentField.Method}}"))

		err := gen.Template(path, tpl, struct{}{})
		assert.Error(t, err, "Should return error when template execution fails")
		assert.ErrorContains(t, err, "executing template")
	})

	t.Run("Generates Successfully", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()
		gen := New(fs)
		err := gen.Template(".gitignore", gitIgnoreTpl, nil)
		assert.NoError(t, err)

		got, err := afero.ReadFile(fs, ".gitignore")
		assert.NoError(t, err)

		want := "# Code generated by webkit; DO NOT EDIT.\n.DS_Store"
		assert.Equal(t, want, string(got))
	})
}

func TestFileGenerator_JSON(t *testing.T) {
	t.Parallel()

	path := "file.json"
	jsonData := map[string]any{"project": "ainsley.dev"}
	jsonDataBytes, err := json.Marshal(jsonData)
	require.NoError(t, err)

	t.Run("Skips Scaffolding", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()
		gen := New(fs)

		err = afero.WriteFile(fs, path, jsonDataBytes, os.ModePerm)
		require.NoError(t, err)

		err = gen.JSON(path, "", WithScaffoldMode())
		assert.NoError(t, err, "Scaffold is skipped, file exists")
	})

	t.Run("Encoder Failure", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()
		gen := New(fs)

		err = gen.JSON(path, make(chan int))
		assert.Error(t, err)
		assert.ErrorContains(t, err, "encoding file.json")
	})

	t.Run("Generates Successfully", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()
		gen := New(fs)

		err = gen.JSON(path, jsonData)
		assert.NoError(t, err)

		got, err := afero.ReadFile(fs, path)
		assert.NoError(t, err)
		assert.JSONEq(t, string(jsonDataBytes), string(got))
	})
}

type badYAML struct{}

func (b badYAML) MarshalYAML() (interface{}, error) {
	return nil, fmt.Errorf("simulated failure")
}

func TestFileGenerator_YAML(t *testing.T) {
	t.Parallel()

	path := "file.yaml"
	yamlData := map[string]any{"project": "ainsley.dev"}
	yamlDataBytes, err := yaml.Marshal(yamlData)
	require.NoError(t, err)

	t.Run("Skips Scaffolding", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()
		gen := New(fs)

		err = afero.WriteFile(fs, path, yamlDataBytes, os.ModePerm)
		require.NoError(t, err)

		err = gen.YAML(path, "", WithScaffoldMode())
		assert.NoError(t, err, "Scaffold is skipped, file exists")
	})

	t.Run("Encoder Failure", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()
		gen := New(fs)

		err := gen.YAML("file.yaml", badYAML{})
		assert.Error(t, err)
		assert.ErrorContains(t, err, "encoding file.yaml")
	})

	t.Run("Generates Successfully", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()
		gen := New(fs)

		err = gen.YAML(path, yamlData)
		assert.NoError(t, err)

		got, err := afero.ReadFile(fs, path)
		assert.NoError(t, err)

		want := "# Code generated by webkit; DO NOT EDIT.\nproject: ainsley.dev\n"
		assert.Equal(t, string(want), string(got))
	})
}
```

## File: internal/scaffold/notice_test.go
```go
package scaffold

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestNoticeForFile(t *testing.T) {
	t.Parallel()

	tt := map[string]struct {
		input string
		want  string
	}{
		"Go File": {
			input: "main.go",
			want:  "// Code generated by webkit; DO NOT EDIT.\n",
		},
		"YAML File": {
			input: "config.yaml",
			want:  "# Code generated by webkit; DO NOT EDIT.\n",
		},
		"YML File": {
			input: "config.yml",
			want:  "# Code generated by webkit; DO NOT EDIT.\n",
		},
		"Editorconfig File": {
			input: ".editorconfig",
			want:  "# Code generated by webkit; DO NOT EDIT.\n",
		},
		"Toml File": {
			input: "settings.toml",
			want:  "# Code generated by webkit; DO NOT EDIT.\n",
		},
		"JS File": {
			input: "script.js",
			want:  "// Code generated by webkit; DO NOT EDIT.\n",
		},
		"HTML File": {
			input: "index.html",
			want:  "<!-- Code generated by webkit; DO NOT EDIT. -->\n",
		},
		"Markdown File": {
			input: "README.md",
			want:  "<!-- Code generated by webkit; DO NOT EDIT. -->\n",
		},
		"Unknown Extension File": {
			input: "file.unknown",
			want:  "# Code generated by webkit; DO NOT EDIT.\n",
		},
		"No Extension File": {
			input: "LICENSE",
			want:  "# Code generated by webkit; DO NOT EDIT.\n",
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			t.Parallel()
			got := noticeForFile(test.input)
			assert.Equal(t, test.want, got)
		})
	}
}
```

## File: internal/secrets/age/age_test.go
```go
package age

import (
	"os"
	"path/filepath"
	"testing"

	"filippo.io/age"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/ainsleydev/webkit/internal/config"
)

func TestReadIdentity(t *testing.T) {
	identity, err := age.GenerateX25519Identity()
	require.NoError(t, err)

	t.Run("From Environment Variable", func(t *testing.T) {
		t.Setenv(KeyEnvVar, identity.String())

		got, err := ReadIdentity()
		require.NoError(t, err)
		assert.Equal(t, identity.String(), got.String())
	})

	t.Run("From Config File", func(t *testing.T) {
		tmpHome := t.TempDir()
		t.Setenv("HOME", tmpHome)
		require.NoError(t, os.Unsetenv(KeyEnvVar))

		// Write key to config
		err := WritePrivateKey(identity.String())
		require.NoError(t, err)

		// Read it back
		got, err := ReadIdentity()
		require.NoError(t, err)
		assert.Equal(t, identity.String(), got.String())
	})

	t.Run("Environment Takes Precedence Over File", func(t *testing.T) {
		tmpHome := t.TempDir()
		t.Setenv("HOME", tmpHome)

		// Write one key to file
		fileIdentity, err := age.GenerateX25519Identity()
		require.NoError(t, err)
		err = WritePrivateKey(fileIdentity.String())
		require.NoError(t, err)

		// Set different key in environment
		envIdentity, err := age.GenerateX25519Identity()
		require.NoError(t, err)
		t.Setenv(KeyEnvVar, envIdentity.String())

		// Should get the env key
		got, err := ReadIdentity()
		require.NoError(t, err)
		assert.Equal(t, envIdentity.String(), got.String())
		assert.NotEqual(t, fileIdentity.String(), got.String())
	})

	t.Run("File Not Found", func(t *testing.T) {
		tmpHome := t.TempDir()
		t.Setenv("HOME", tmpHome)
		require.NoError(t, os.Unsetenv(KeyEnvVar))

		_, err = ReadIdentity()
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "reading age key from")
		assert.Contains(t, err.Error(), "age.key")
	})

	t.Run("Invalid Key From Environment", func(t *testing.T) {
		t.Setenv(KeyEnvVar, "not-a-valid-age-key")

		_, err = ReadIdentity()
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "invalid age key format")
		assert.Contains(t, err.Error(), "SOPS_AGE_KEY environment variable")
	})

	t.Run("Invalid Key From File", func(t *testing.T) {
		tmpHome := t.TempDir()
		t.Setenv("HOME", tmpHome)
		require.NoError(t, os.Unsetenv(KeyEnvVar))

		// Write invalid key directly to bypass validation
		err = config.Write(KeyFileName, []byte("not-a-valid-age-key"), 0600)
		require.NoError(t, err)

		_, err = ReadIdentity()
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "invalid age key format")
		assert.Contains(t, err.Error(), "age.key")
	})

	t.Run("Empty Key From Environment", func(t *testing.T) {
		t.Setenv(KeyEnvVar, "")
		tmpHome := t.TempDir()
		t.Setenv("HOME", tmpHome)

		// Empty env var should fall through to file
		_, err = ReadIdentity()
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "reading age key")
	})

	t.Run("Empty File From Environment", func(t *testing.T) {
		t.Setenv(KeyEnvVar, "")
		tmpHome := t.TempDir()
		t.Setenv("HOME", tmpHome)

		err = config.Write(KeyFileName, []byte(""), os.ModePerm)
		require.NoError(t, err)

		_, err = ReadIdentity()
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "no SOPS_AGE_KEY key found")
	})
}

func TestWritePrivateKey(t *testing.T) {
	identity, err := age.GenerateX25519Identity()
	require.NoError(t, err)

	t.Run("Invalid Key Format", func(t *testing.T) {
		tmpHome := t.TempDir()
		t.Setenv("HOME", tmpHome)

		err = WritePrivateKey("not-a-valid-age-key")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "invalid age key format")

		// File should not have been created
		_, err = config.Read(KeyFileName)
		assert.Error(t, err)
	})

	t.Run("Empty Key", func(t *testing.T) {
		tmpHome := t.TempDir()
		t.Setenv("HOME", tmpHome)

		err = WritePrivateKey("")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "invalid age key format")
	})

	t.Run("Write Error", func(t *testing.T) {
		tmpHome := t.TempDir()
		t.Setenv("HOME", tmpHome)

		dir, err := config.Dir()
		require.NoError(t, err)
		require.NoError(t, os.MkdirAll(dir, 0755))

		// Create a directory where the file should go
		filePath := filepath.Join(dir, KeyFileName)
		require.NoError(t, os.Mkdir(filePath, 0755)) // <-- Dir instead of a file

		err = WritePrivateKey(identity.String())
		require.Error(t, err)
		assert.Contains(t, err.Error(), "writing age key")
	})

	t.Run("Success", func(t *testing.T) {
		tmpHome := t.TempDir()
		t.Setenv("HOME", tmpHome)

		err = WritePrivateKey(identity.String())
		require.NoError(t, err)

		// Verify it was written correctly
		data, err := config.Read(KeyFileName)
		require.NoError(t, err)
		assert.Equal(t, identity.String(), string(data))
	})
}

//func TestAgeKey_ReadWriteRoundTrip(t *testing.T) {
//	identity, err := age.GenerateX25519Identity()
//	require.NoError(t, err)
//
//	tmpHome := t.TempDir()
//	t.Setenv("HOME", tmpHome)
//	require.NoError(t, os.Unsetenv(KeyEnvVar))
//
//	err = WritePrivateKey(identity.String())
//	require.NoError(t, err)
//
//	key, err := ReadIdentity()
//	require.NoError(t, err)
//
//	assert.Equal(t, identity.String(), key)
//
//	parsedIdentity, err := age.ParseX25519Identity(key)
//	require.NoError(t, err)
//	assert.Equal(t, identity.Recipient().String(), parsedIdentity.Recipient().String())
//}

func TestExtractPublicKey(t *testing.T) {
	t.Parallel()

	validIdentity, _ := age.GenerateX25519Identity()
	validPrivateKey := validIdentity.String()
	validPublicKey := validIdentity.Recipient().String()

	tt := map[string]struct {
		input   string
		want    string
		wantErr bool
	}{
		"Valid Age Private Key": {
			input:   validPrivateKey,
			want:    validPublicKey,
			wantErr: false,
		},
		"Empty String": {
			input:   "",
			want:    "",
			wantErr: true,
		},
		"Random String": {
			input:   "not-a-valid-key",
			want:    "",
			wantErr: true,
		},
		"Whitespace Only": {
			input:   "   \n\t",
			want:    "",
			wantErr: true,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			t.Parallel()
			got, err := extractPublicKey(test.input)
			assert.Equal(t, test.want, got)
			assert.Equal(t, test.wantErr, err != nil)
		})
	}
}
```

## File: internal/secrets/age/age.go
```go
package age

import (
	"errors"
	"fmt"
	"os"
	"strings"

	"filippo.io/age"

	"github.com/ainsleydev/webkit/internal/config"
)

const (
	// KeyFileName is the name of the age private key file.
	KeyFileName = "age.key"
	// KeyEnvVar is the environment variable name for the age key.
	KeyEnvVar = "SOPS_AGE_KEY"
)

// ReadIdentity returns the age identity key from environment or file.
//
// Checks in order:
// 1. SOPS_AGE_KEY environment variable.
// 2. ~/.config/webkit/age.key (local dev)
func ReadIdentity() (*age.X25519Identity, error) {
	key := ""
	source := ""

	// Check environment variable first (used in CI/CD)
	if envKey := os.Getenv(KeyEnvVar); envKey != "" {
		key = envKey
		source = fmt.Sprintf("%s environment variable", KeyEnvVar)
	} else {
		// Try reading from config file
		data, err := config.Read(KeyFileName)
		if err != nil {
			path, _ := config.Path(KeyFileName)
			return nil, fmt.Errorf("reading age key from %s: %w", path, err)
		}
		key = string(data)
		keyPath, _ := config.Path(KeyFileName)
		source = keyPath
	}

	if key == "" {
		return nil, errors.New("no SOPS_AGE_KEY key found")
	}

	// Sometimes editors add some random stuff.
	key = strings.ReplaceAll(strings.TrimSpace(key), "\n", "")
	identity, err := age.ParseX25519Identity(strings.TrimSpace(key))
	if err != nil {
		return nil, fmt.Errorf("invalid age key format in %s: %w", source, err)
	}

	return identity, nil
}

// WritePrivateKey writes an age private key to the config directory.
func WritePrivateKey(key string) error {
	// Validate it's a proper age key before writing
	if _, err := age.ParseX25519Identity(key); err != nil {
		return fmt.Errorf("invalid age key format: %w", err)
	}

	if err := config.Write(KeyFileName, []byte(key), os.ModePerm); err != nil {
		return fmt.Errorf("writing age key: %w", err)
	}

	return nil
}

// extractPublicKey extracts the public key from an age private key
func extractPublicKey(privateKey string) (string, error) {
	identity, err := age.ParseX25519Identity(privateKey)
	if err != nil {
		return "", fmt.Errorf("parsing age identity: %w", err)
	}
	return identity.Recipient().String(), nil
}
```

## File: internal/secrets/age/provider_test.go
```go
package age

import (
	"testing"

	"filippo.io/age"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestNewProvider(t *testing.T) {
	identity, err := age.GenerateX25519Identity()
	require.NoError(t, err)

	t.Run("Private Key Error", func(t *testing.T) {
		t.Setenv(KeyEnvVar, "invalid-key-format")

		provider, err := NewProvider()
		assert.Error(t, err)
		assert.Nil(t, provider)
		assert.Contains(t, err.Error(), "invalid age key format")
	})

	t.Run("Success", func(t *testing.T) {
		t.Setenv(KeyEnvVar, identity.String())

		provider, err := NewProvider()
		require.NoError(t, err)
		assert.NotNil(t, provider)
		assert.Equal(t, identity.String(), provider.privateKey)
		assert.Equal(t, identity.Recipient().String(), provider.publicKey)
	})
}

func TestProvider_EncryptArgs(t *testing.T) {
	t.Parallel()

	identity, err := age.GenerateX25519Identity()
	require.NoError(t, err)

	provider := &Provider{
		privateKey: identity.String(),
		publicKey:  identity.Recipient().String(),
	}

	got, err := provider.EncryptArgs()
	require.NoError(t, err)

	t.Log("Returns correct arguments")
	{
		assert.Equal(t, []string{"--age", identity.Recipient().String()}, got)
	}

	t.Log("Is deterministic on multiple calls")
	{
		got2, err2 := provider.EncryptArgs()
		require.NoError(t, err2)
		assert.Equal(t, got, got2)
	}
}

func TestProvider_DecryptArgs(t *testing.T) {
	t.Parallel()

	provider := &Provider{}

	got, err := provider.DecryptArgs()
	require.NoError(t, err)
	assert.Empty(t, got)
}

func TestProvider_Environment(t *testing.T) {
	t.Parallel()

	identity, err := age.GenerateX25519Identity()
	require.NoError(t, err)

	provider := &Provider{
		privateKey: identity.String(),
		publicKey:  identity.Recipient().String(),
	}

	env := provider.Environment()

	require.NotNil(t, env)
	assert.Len(t, env, 1)
	assert.Contains(t, env, "SOPS_AGE_KEY")

	val := env["SOPS_AGE_KEY"]
	assert.Equal(t, identity.String(), val, "Should return the private key")
	assert.NotContains(t, val, identity.Recipient().String(), "Should not include public key")
	assert.Equal(t, env, provider.Environment(), "Should return same result on multiple calls")
}
```

## File: internal/secrets/age/provider.go
```go
package age

import "github.com/ainsleydev/webkit/internal/secrets/sops"

// Provider implements the SOPS Provider interface for
// age encryption, keys are lazy loaded.
type Provider struct {
	privateKey string
	publicKey  string
}

// NewProvider creates a new age provider by reading keys.
//
// Returns an error if it couldn't extract/read public
// and private keys.
func NewProvider() (*Provider, error) {
	identity, err := ReadIdentity()
	if err != nil {
		return nil, err
	}
	return &Provider{
		privateKey: identity.String(),
		publicKey:  identity.Recipient().String(),
	}, nil
}

var _ sops.Provider = (*Provider)(nil)

func (p *Provider) EncryptArgs() ([]string, error) {
	return []string{"--age", p.publicKey}, nil
}

func (p *Provider) DecryptArgs() ([]string, error) {
	return []string{}, nil // Decrypt uses environment variable
}

func (p *Provider) Environment() map[string]string {
	return map[string]string{
		"SOPS_AGE_KEY": p.privateKey,
	}
}
```

## File: internal/secrets/sops/map_test.go
```go
package sops

import (
	"errors"
	"os"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/ainsleydev/webkit/internal/executil"
)

func TestDecryptFileToMap(t *testing.T) {
	t.Parallel()

	setup := func(t *testing.T) (*os.File, func()) {
		t.Helper()

		file, err := os.CreateTemp("", "secrets-*.yaml")
		require.NoError(t, err)

		return file, func() {
			require.NoError(t, file.Close())
			require.NoError(t, os.Remove(file.Name()))
		}
	}

	t.Run("Decryption fails", func(t *testing.T) {
		t.Parallel()

		file, teardown := setup(t)
		defer teardown()

		client, mem := newClient(&fakeProvider{})
		mem.AddStub("sops --decrypt", executil.Result{},
			errors.New("sops metadata not found"))

		got, err := DecryptFileToMap(client, file.Name())
		assert.Nil(t, got)
		assert.ErrorIs(t, err, ErrNotEncrypted)
	})

	t.Run("Read File Error", func(t *testing.T) {
		t.Parallel()

		client, mem := newClient(&fakeProvider{})
		mem.AddStub("sops --decrypt", executil.Result{}, nil)

		got, err := DecryptFileToMap(client, "wrong-path.yaml")
		assert.Nil(t, got)
		assert.ErrorContains(t, err, "failed to read sops file")
	})

	t.Run("Invalid YAML", func(t *testing.T) {
		t.Parallel()

		file, teardown := setup(t)
		defer teardown()

		_, err := file.WriteString("key: value\nunbalanced")
		require.NoError(t, err)

		client, mem := newClient(&fakeProvider{})
		mem.AddStub("sops --decrypt", executil.Result{
			Output: "key: value\nunbalanced",
		}, nil)

		got, err := DecryptFileToMap(client, file.Name())
		assert.Nil(t, got)
		assert.ErrorContains(t, err, "failed to parse sops content")
	})

	t.Run("Successful Decryption", func(t *testing.T) {
		t.Parallel()

		file, teardown := setup(t)
		defer teardown()
		_, err := file.WriteString("key: value\n")
		require.NoError(t, err)

		client, mem := newClient(&fakeProvider{})
		mem.AddStub("sops --decrypt --in-place", executil.Result{
			Output: "",
		}, nil)

		mem.AddStub("sops --encrypt --age test-key --in-place", executil.Result{
			Output: "",
		}, nil)

		data, err := DecryptFileToMap(client, file.Name())
		require.NoError(t, err)
		require.NotNil(t, data)
		assert.Equal(t, "value", data["key"])
	})
}
```

## File: internal/secrets/sops/provider.go
```go
package sops

// Provider abstracts different key management strategies for
// SOPS encryption. Implementations provide the necessary CLI
// arguments and environment variables for SOPS to execute.
type Provider interface {
	// EncryptArgs returns the CLI args needed for encryption.
	// e.g. ["--age", "age1abc..."] or ["--kms", "arn:aws:kms:..."]
	EncryptArgs() ([]string, error)

	// DecryptArgs returns the CLI args needed for decryption.
	// e.g. ["--age", "age1abc..."] or ["--kms", "arn:aws:kms:..."]
	DecryptArgs() ([]string, error)

	// Environment returns environment variables needed for SOPS operations
	// e.g., ["SOPS_AGE_KEY=AGE-SECRET-KEY-1..."]
	Environment() map[string]string
}
```

## File: internal/secrets/sops/sops_test.go
```go
package sops

import (
	"errors"
	"fmt"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/ainsleydev/webkit/internal/executil"
)

type fakeProvider struct {
	err error
}

func (f *fakeProvider) DecryptArgs() ([]string, error) {
	return []string{"--age", "test-key"}, f.err
}

func (f *fakeProvider) EncryptArgs() ([]string, error) {
	return []string{"--age", "test-key"}, f.err
}

func (f *fakeProvider) Environment() map[string]string {
	return map[string]string{"SOPS_AGE_KEY": "fake"}
}

func newClient(provider Provider) (*Client, *executil.MemRunner) {
	mem := executil.NewMemRunner()
	client := NewClient(provider)
	client.runner = mem
	return client, mem
}

func TestClient_Encrypt(t *testing.T) {
	t.Parallel()

	t.Run("Already Encrypted", func(t *testing.T) {
		t.Parallel()
		client, mem := newClient(&fakeProvider{})

		mem.AddStub("sops --encrypt", executil.Result{},
			errors.New("contains a top-level entry called 'sops'"))
		
		err := client.Encrypt("file.yaml")
		assert.ErrorIs(t, err, ErrAlreadyEncrypted)
	})

	t.Run("Provider Error", func(t *testing.T) {
		t.Parallel()
		client, _ := newClient(&fakeProvider{err: fmt.Errorf("provider failure")})

		err := client.Encrypt("file.yaml")
		assert.Error(t, err)
		assert.EqualError(t, err, "provider failure")
	})

	t.Run("Encrypt CLI Failure", func(t *testing.T) {
		t.Parallel()
		client, mem := newClient(&fakeProvider{})

		mem.AddStub("sops --encrypt", executil.Result{
			Output: "some error",
		}, fmt.Errorf("exit status 1"))

		err := client.Encrypt("file.yaml")
		assert.Error(t, err)
		assert.ErrorContains(t, err, "sops encrypt failed")
	})

	t.Run("Success", func(t *testing.T) {
		t.Parallel()
		client, mem := newClient(&fakeProvider{})

		mem.AddStub("sops --encrypt", executil.Result{
			Output: "encrypted",
		}, nil)

		err := client.Encrypt("file.yaml")
		assert.NoError(t, err)
	})
}

func TestClient_Decrypt(t *testing.T) {
	t.Parallel()

	t.Run("Already Decrypted", func(t *testing.T) {
		t.Parallel()
		client, mem := newClient(&fakeProvider{})

		mem.AddStub("sops --decrypt", executil.Result{},
			errors.New("sops metadata not found"))

		err := client.Decrypt("file.yaml")
		assert.ErrorIs(t, err, ErrNotEncrypted)
	})

	t.Run("CLI Failure", func(t *testing.T) {
		t.Parallel()
		client, mem := newClient(&fakeProvider{})

		mem.AddStub("sops --decrypt", executil.Result{
			Output: "unexpected error",
		}, fmt.Errorf("exit status 1"))

		err := client.Decrypt("file.yaml")
		require.Error(t, err)
		assert.True(t, strings.Contains(err.Error(), "sops decrypt failed"))
	})

	t.Run("Success", func(t *testing.T) {
		t.Parallel()
		client, mem := newClient(&fakeProvider{})

		mem.AddStub("sops --decrypt", executil.Result{
			Output: "decrypted",
		}, nil)

		err := client.Decrypt("file.yaml")
		assert.NoError(t, err)
	})
}
```

## File: internal/secrets/sops/sops.go
```go
package sops

import (
	"context"
	"errors"
	"fmt"
	"os"
	"os/exec"
	"strings"

	"github.com/ainsleydev/webkit/internal/executil"
)

type (
	// Encrypter encrypts a SOPS file using the CLI with the specified
	// provider. Uses the SOPS CLI, assumes it's installed.
	//
	// Example:
	//
	//	err := sops.Encrypt("secrets/production.yaml")
	Encrypter interface {
		Encrypt(filePath string) error
	}
	// Decrypter decrypts a SOPS file using the CLI with the specified
	// provider. Uses the SOPS cli, assumes it's installed.
	//
	// Example:
	//
	//	err := sops.Decrypter("secrets/production.yaml")
	Decrypter interface {
		Decrypt(filePath string) error
	}
	// EncrypterDecrypter combines encryption and decryption operations.
	EncrypterDecrypter interface {
		Encrypter
		Decrypter
	}
)

// Client executes SOPS operations using a configured provider.
type Client struct {
	provider Provider
	runner   executil.Runner
	exec     func(ctx context.Context, name string, arg ...string) *exec.Cmd
}

// NewClient creates a SOPS client with the specified provider
func NewClient(provider Provider) *Client {
	return &Client{
		provider: provider,
		runner:   executil.DefaultRunner(),
		exec:     exec.CommandContext,
	}
}

var (
	// ErrAlreadyEncrypted is returned when Encrypt is called on a file
	// that is already encrypted.
	ErrAlreadyEncrypted = errors.New("file is already encrypted")

	// ErrNotEncrypted is returned when Decrypt is called on a file that
	// is not encrypted.
	ErrNotEncrypted = errors.New("file is not encrypted")
)

func (c Client) Decrypt(filePath string) error {
	outStr, err := c.runSopsCommand("--decrypt", "--in-place", filePath)

	if err != nil && strings.Contains(err.Error(), "sops metadata not found") {
		return ErrNotEncrypted
	} else if err != nil {
		return fmt.Errorf("sops decrypt failed: %s: %w", outStr, err)
	}

	return nil
}

func (c Client) Encrypt(filePath string) error {
	encryptArgs, err := c.provider.EncryptArgs()
	if err != nil {
		return err
	}

	args := append([]string{"--encrypt"}, encryptArgs...)
	args = append(args, "--in-place", filePath)

	outStr, err := c.runSopsCommand(args...)
	outStr = strings.TrimSpace(outStr)

	if err != nil && strings.Contains(err.Error(), "contains a top-level entry called 'sops'") {
		return ErrAlreadyEncrypted
	} else if err != nil {
		return fmt.Errorf("sops encrypt failed: %s: %w", outStr, err)
	}

	return nil
}

func (c Client) runSopsCommand(args ...string) (string, error) {
	cmd := executil.NewCommand("sops", args...)

	// Start with OS environment
	cmd.Env = make(map[string]string)
	for _, kv := range os.Environ() {
		parts := strings.SplitN(kv, "=", 2)
		if len(parts) == 2 {
			cmd.Env[parts[0]] = parts[1]
		}
	}

	// Overlay provider environment (overrides OS vars if needed).
	for k, v := range c.provider.Environment() {
		cmd.Env[k] = v
	}

	result, err := c.runner.Run(context.Background(), cmd)
	if err != nil {
		return "", fmt.Errorf("%w: %s", err, result.Output)
	}

	return result.Output, nil
}
```

## File: internal/secrets/sops/util_test.go
```go
package sops

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestIsContentEncrypted(t *testing.T) {
	t.Parallel()

	tt := map[string]struct {
		input []byte
		want  bool
	}{
		"Empty Content": {
			input: []byte(""),
			want:  false,
		},
		"No SOPS Markers": {
			input: []byte("plain text without encryption markers"),
			want:  false,
		},
		"Contains SOPS Metadata": {
			input: []byte("some content\nsops:\n  kms: ..."),
			want:  true,
		},
		"Contains ENC Marker": {
			input: []byte("some content ENC[AES256_GCM,data...] more text"),
			want:  true,
		},
		"Both SOPS and ENC": {
			input: []byte("sops:\nENC[AES256_GCM,data...]"),
			want:  true,
		},
		"SOPS Lowercase Only": {
			input: []byte("sops: something else"),
			want:  true,
		},
		"ENC Lowercase Only": {
			input: []byte("enc[data]"),
			want:  false, // Function is case-sensitive
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			t.Parallel()
			got := IsContentEncrypted(test.input)
			assert.Equal(t, test.want, got)
		})
	}
}
```

## File: internal/secrets/sops/util.go
```go
package sops

import "bytes"

// IsContentEncrypted checks if file contents contain SOPS encryption markers.
func IsContentEncrypted(content []byte) bool {
	// Check for SOPS metadata section
	return bytes.Contains(content, []byte("sops:")) ||
		bytes.Contains(content, []byte("ENC["))
}
```

## File: internal/secrets/sync_result.go
```go
package secrets

type (
	// SyncResult represents the outcome of syncing one
	// SOPS YAML file.
	SyncResult struct {
		FilePath     string
		Added        int
		Skipped      int
		WasEncrypted bool
		WasMissing   bool
		Error        error
		AddedSecrets []SecretInfo
	}
	// SyncResults aggregates all file results together
	// for analytics.
	SyncResults struct {
		Files []SyncResult
	}
)

// TotalAdded returns total secrets added across all files
func (r *SyncResults) TotalAdded() int {
	return r.sumInts(func(f SyncResult) int { return f.Added })
}

// TotalSkipped returns total secrets skipped
func (r *SyncResults) TotalSkipped() int {
	return r.sumInts(func(f SyncResult) int { return f.Skipped })
}

// EncryptedCount returns count of encrypted files encountered
func (r *SyncResults) EncryptedCount() int {
	return r.countTrue(func(f SyncResult) bool { return f.WasEncrypted })
}

// MissingCount returns count of missing files
func (r *SyncResults) MissingCount() int {
	return r.countTrue(func(f SyncResult) bool { return f.WasMissing })
}

// HasErrors returns true if any file had an error
func (r *SyncResults) HasErrors() bool {
	return r.countTrue(func(f SyncResult) bool { return f.Error != nil }) > 0
}

// sumInts sums a specific integer field across all files
func (r *SyncResults) sumInts(getter func(SyncResult) int) int {
	total := 0
	for _, f := range r.Files {
		total += getter(f)
	}
	return total
}

// countTrue counts how many files satisfy the predicate
func (r *SyncResults) countTrue(predicate func(SyncResult) bool) int {
	count := 0
	for _, f := range r.Files {
		if predicate(f) {
			count++
		}
	}
	return count
}
```

## File: internal/secrets/sync_test.go
```go
package secrets

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/spf13/afero"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/ainsleydev/webkit/internal/appdef"
	"github.com/ainsleydev/webkit/pkg/env"
)

func TestSync(t *testing.T) {
	t.Parallel()

	t.Run("No Apps", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()
		cfg := SyncConfig{
			FS:     fs,
			AppDef: &appdef.Definition{Apps: []appdef.App{}},
		}

		results, err := Sync(cfg)
		require.NoError(t, err)
		assert.Empty(t, results.Files)
		assert.Equal(t, 0, results.TotalAdded())
	})

	t.Run("No SOPS References", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()
		def := &appdef.Definition{
			Apps: []appdef.App{
				{
					Name: "web",
					Type: appdef.AppTypeGoLang,
				},
			},
		}
		require.NoError(t, def.ApplyDefaults())

		cfg := SyncConfig{
			FS:     fs,
			AppDef: def,
		}

		results, err := Sync(cfg)
		require.NoError(t, err)
		assert.Empty(t, results.Files)
	})

	t.Run("Single App Single Secret", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()

		// Create secret file
		secretPath := FilePath + "/production.yaml"
		err := fs.MkdirAll("FilePath", 0755)
		require.NoError(t, err)
		err = afero.WriteFile(fs, secretPath, []byte("EXISTING_KEY: value\n"), 0644)
		require.NoError(t, err)

		def := &appdef.Definition{
			Apps: []appdef.App{
				{
					Name: "cms",
					Type: appdef.AppTypePayload,
					Env: appdef.Environment{
						Production: appdef.EnvVar{
							"PAYLOAD_SECRET": {
								Source: appdef.EnvSourceSOPS,
								Path:   "secrets/production.yaml:PAYLOAD_SECRET",
							},
						},
					},
				},
			},
		}
		require.NoError(t, def.ApplyDefaults())

		cfg := SyncConfig{
			FS:     fs,
			AppDef: def,
		}

		results, err := Sync(cfg)
		require.NoError(t, err)
		assert.Len(t, results.Files, 1)
		assert.Equal(t, 1, results.TotalAdded())
		assert.Equal(t, 0, results.TotalSkipped())

		// Verify file was updated
		content, err := afero.ReadFile(fs, secretPath)
		require.NoError(t, err)
		assert.Contains(t, string(content), "PAYLOAD_SECRET: \"REPLACE_ME_PAYLOAD_SECRET\"")
		assert.Contains(t, string(content), "EXISTING_KEY: value")
	})

	t.Run("Multiple Apps Same Secret", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()
		secretPath := filepath.Join(FilePath, "production.yaml")
		err := fs.MkdirAll("FilePath", 0755)
		require.NoError(t, err)
		err = afero.WriteFile(fs, secretPath, []byte(""), 0644)
		require.NoError(t, err)

		def := &appdef.Definition{
			Apps: []appdef.App{
				{
					Name: "cms",
					Type: appdef.AppTypePayload,
					Env: appdef.Environment{
						Production: appdef.EnvVar{
							"DATABASE_URL": {
								Source: appdef.EnvSourceSOPS,
								Path:   "secrets/production.yaml:DATABASE_URL",
							},
						},
					},
				},
				{
					Name: "web",
					Type: appdef.AppTypeGoLang,
					Env: appdef.Environment{
						Production: appdef.EnvVar{
							"DATABASE_URL": {
								Source: appdef.EnvSourceSOPS,
								Path:   "secrets/production.yaml:DATABASE_URL",
							},
						},
					},
				},
			},
		}
		require.NoError(t, def.ApplyDefaults())

		cfg := SyncConfig{
			FS:     fs,
			AppDef: def,
		}

		results, err := Sync(cfg)
		require.NoError(t, err)
		assert.Len(t, results.Files, 1)
		assert.Equal(t, 1, results.TotalAdded())

		// Verify both apps are listed
		result := results.Files[0]
		assert.Len(t, result.AddedSecrets, 1)
		assert.ElementsMatch(t, []string{"cms", "web"}, result.AddedSecrets[0].AppNames)
	})

	t.Run("Multiple Environments", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()
		err := fs.MkdirAll(FilePath, 0755)
		require.NoError(t, err)

		// Create files for each environment
		for _, env := range []string{"development", "staging", "production"} {
			path := filepath.Join(FilePath, env+".yaml")
			err = afero.WriteFile(fs, path, []byte(""), 0644)
			require.NoError(t, err)
		}

		def := &appdef.Definition{
			Apps: []appdef.App{
				{
					Name: "cms",
					Type: appdef.AppTypePayload,
					Env: appdef.Environment{
						Dev: appdef.EnvVar{
							"DEV_SECRET": {
								Source: appdef.EnvSourceSOPS,
								Path:   "secrets/development.yaml:DEV_SECRET",
							},
						},
						Staging: appdef.EnvVar{
							"STAGING_SECRET": {
								Source: appdef.EnvSourceSOPS,
								Path:   "secrets/staging.yaml:STAGING_SECRET",
							},
						},
						Production: appdef.EnvVar{
							"PROD_SECRET": {
								Source: appdef.EnvSourceSOPS,
								Path:   "secrets/production.yaml:PROD_SECRET",
							},
						},
					},
				},
			},
		}
		require.NoError(t, def.ApplyDefaults())

		cfg := SyncConfig{
			FS:     fs,
			AppDef: def,
		}

		results, err := Sync(cfg)
		require.NoError(t, err)
		assert.Len(t, results.Files, 3)
		assert.Equal(t, 3, results.TotalAdded())
	})

	t.Run("Skip Existing Keys", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()
		secretPath := filepath.Join(FilePath, "production.yaml")
		err := fs.MkdirAll(FilePath, os.ModePerm)
		require.NoError(t, err)

		// Pre-populate with existing secret
		err = afero.WriteFile(fs, secretPath, []byte("API_KEY: existing_value\n"), 0644)
		require.NoError(t, err)

		def := &appdef.Definition{
			Apps: []appdef.App{
				{
					Name: "web",
					Type: appdef.AppTypeGoLang,
					Env: appdef.Environment{
						Production: appdef.EnvVar{
							"API_KEY": {
								Source: appdef.EnvSourceSOPS,
								Path:   "secrets/production.yaml:API_KEY",
							},
							"NEW_KEY": {
								Source: appdef.EnvSourceSOPS,
								Path:   "secrets/production.yaml:NEW_KEY",
							},
						},
					},
				},
			},
		}
		require.NoError(t, def.ApplyDefaults())

		cfg := SyncConfig{
			FS:     fs,
			AppDef: def,
		}

		results, err := Sync(cfg)
		require.NoError(t, err)
		assert.Equal(t, 1, results.TotalAdded())
		assert.Equal(t, 1, results.TotalSkipped())

		content, err := afero.ReadFile(fs, secretPath)
		require.NoError(t, err)
		assert.Contains(t, string(content), "API_KEY: existing_value")
		assert.Contains(t, string(content), "NEW_KEY: \"REPLACE_ME_NEW_KEY\"")
	})

	t.Run("File Missing", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()

		def := &appdef.Definition{
			Apps: []appdef.App{
				{
					Name: "cms",
					Type: appdef.AppTypePayload,
					Env: appdef.Environment{
						Production: appdef.EnvVar{
							"SECRET": {
								Source: appdef.EnvSourceSOPS,
								Path:   "secrets/production.yaml:SECRET",
							},
						},
					},
				},
			},
		}
		require.NoError(t, def.ApplyDefaults())

		cfg := SyncConfig{
			FS:     fs,
			AppDef: def,
		}

		results, err := Sync(cfg)
		require.NoError(t, err)
		assert.Len(t, results.Files, 1)
		assert.True(t, results.Files[0].WasMissing)
		assert.Equal(t, 1, results.MissingCount())
	})

	t.Run("File Encrypted", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()
		secretPath := filepath.Join(FilePath, "production.yaml")
		err := fs.MkdirAll(FilePath, os.ModePerm)
		require.NoError(t, err)

		// Write encrypted content
		encryptedContent := []byte("sops:\n  kms: encrypted_data\nENC[AES256_GCM,data:...]")
		err = afero.WriteFile(fs, secretPath, encryptedContent, 0644)
		require.NoError(t, err)

		def := &appdef.Definition{
			Apps: []appdef.App{
				{
					Name: "cms",
					Type: appdef.AppTypePayload,
					Env: appdef.Environment{
						Production: appdef.EnvVar{
							"SECRET": {
								Source: appdef.EnvSourceSOPS,
								Path:   "secrets/production.yaml:SECRET",
							},
						},
					},
				},
			},
		}
		require.NoError(t, def.ApplyDefaults())

		cfg := SyncConfig{
			FS:     fs,
			AppDef: def,
		}

		results, err := Sync(cfg)
		require.NoError(t, err)
		assert.Len(t, results.Files, 1)
		assert.True(t, results.Files[0].WasEncrypted)
		assert.Equal(t, 1, results.EncryptedCount())
	})

	t.Run("Mixed Value and SOPS Sources", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()
		secretPath := filepath.Join(FilePath, "production.yaml")
		err := fs.MkdirAll(FilePath, 0755)
		require.NoError(t, err)
		err = afero.WriteFile(fs, secretPath, []byte(""), 0644)
		require.NoError(t, err)

		def := &appdef.Definition{
			Apps: []appdef.App{
				{
					Name: "web",
					Type: appdef.AppTypeGoLang,
					Env: appdef.Environment{
						Production: appdef.EnvVar{
							"PUBLIC_KEY": {
								Source: appdef.EnvSourceValue,
								Value:  "public_value",
							},
							"SECRET_KEY": {
								Source: appdef.EnvSourceSOPS,
								Path:   "secrets/production.yaml:SECRET_KEY",
							},
						},
					},
				},
			},
		}
		require.NoError(t, def.ApplyDefaults())

		cfg := SyncConfig{
			FS:     fs,
			AppDef: def,
		}

		results, err := Sync(cfg)
		require.NoError(t, err)
		assert.Equal(t, 1, results.TotalAdded())

		// Only SOPS secret should be added
		result := results.Files[0]
		assert.Len(t, result.AddedSecrets, 1)
		assert.Equal(t, "SECRET_KEY", result.AddedSecrets[0].Key)
	})

	t.Run("Invalid YAML", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()
		secretPath := filepath.Join(FilePath, "production.yaml")
		err := fs.MkdirAll(FilePath, os.ModePerm)
		require.NoError(t, err)

		// Write invalid YAML
		err = afero.WriteFile(fs, secretPath, []byte("invalid: yaml: content: bad"), 0644)
		require.NoError(t, err)

		def := &appdef.Definition{
			Apps: []appdef.App{
				{
					Name: "cms",
					Type: appdef.AppTypePayload,
					Env: appdef.Environment{
						Production: appdef.EnvVar{
							"SECRET": {
								Source: appdef.EnvSourceSOPS,
								Path:   "secrets/production.yaml:SECRET",
							},
						},
					},
				},
			},
		}
		require.NoError(t, def.ApplyDefaults())

		cfg := SyncConfig{
			FS:     fs,
			AppDef: def,
		}

		results, err := Sync(cfg)
		require.NoError(t, err)
		assert.True(t, results.HasErrors())
		assert.NotNil(t, results.Files[0].Error)
	})
}

func TestDeduplicateByKey(t *testing.T) {
	t.Parallel()

	tt := map[string]struct {
		input []reference
		want  []reference
	}{
		"Empty Input": {
			input: []reference{},
			want:  []reference{},
		},
		"No Duplicates": {
			input: []reference{
				{Key: "KEY1", Environment: "production", AppNames: []string{"app1"}},
				{Key: "KEY2", Environment: "production", AppNames: []string{"app2"}},
			},
			want: []reference{
				{Key: "KEY1", Environment: "production", AppNames: []string{"app1"}},
				{Key: "KEY2", Environment: "production", AppNames: []string{"app2"}},
			},
		},
		"Same Key Different Environments": {
			input: []reference{
				{Key: "API_KEY", Environment: "staging", AppNames: []string{"app1"}},
				{Key: "API_KEY", Environment: "production", AppNames: []string{"app1"}},
			},
			want: []reference{
				{Key: "API_KEY", Environment: "staging", AppNames: []string{"app1"}},
				{Key: "API_KEY", Environment: "production", AppNames: []string{"app1"}},
			},
		},
		"Merge Apps for Same Key": {
			input: []reference{
				{Key: "DATABASE_URL", Environment: "production", AppNames: []string{"cms"}},
				{Key: "DATABASE_URL", Environment: "production", AppNames: []string{"web"}},
				{Key: "DATABASE_URL", Environment: "production", AppNames: []string{"api"}},
			},
			want: []reference{
				{Key: "DATABASE_URL", Environment: "production", AppNames: []string{"cms", "web", "api"}},
			},
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			t.Parallel()
			got := deduplicateByKey(test.input)

			assert.Len(t, got, len(test.want))
			for i := range got {
				assert.Equal(t, test.want[i].Key, got[i].Key)
				assert.Equal(t, test.want[i].Environment, got[i].Environment)
				assert.ElementsMatch(t, test.want[i].AppNames, got[i].AppNames)
			}
		})
	}
}

func TestReference_GetFilePath(t *testing.T) {
	t.Parallel()

	tt := map[string]struct {
		environment string
		want        string
	}{
		"Production": {
			environment: env.Production,
			want:        filepath.Join(FilePath, env.Production+".yaml"),
		},
		"Staging": {
			environment: env.Staging,
			want:        filepath.Join(FilePath, env.Staging+".yaml"),
		},
		"Development": {
			environment: env.Development,
			want:        filepath.Join(FilePath, env.Development+".yaml"),
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			t.Parallel()

			ref := reference{
				Key:         "TEST_KEY",
				Environment: test.environment,
				AppNames:    []string{"test"},
			}

			got := ref.GetFilePath()
			assert.Equal(t, test.want, got)
		})
	}
}
```

## File: internal/secrets/sync.go
```go
package secrets

import (
	"bytes"
	"fmt"
	"path/filepath"
	"strings"

	"github.com/spf13/afero"
	"gopkg.in/yaml.v3"

	"github.com/ainsleydev/webkit/internal/appdef"
	"github.com/ainsleydev/webkit/internal/secrets/sops"
)

// SyncConfig configures the sync operation
type SyncConfig struct {
	FS     afero.Fs
	AppDef *appdef.Definition
}

// SecretInfo contains metadata about an added secret
type SecretInfo struct {
	Key      string
	AppNames []string
}

// Sync performs the secrets sync operation.
// It extracts SOPS references from app.json, groups them by file,
// and adds missing placeholders to each secret file.
func Sync(cfg SyncConfig) (*SyncResults, error) {
	def := cfg.AppDef

	// 1. Merge all the environment variables and gather them as
	// individual references.
	var refs []reference
	for _, app := range def.Apps {
		e, ok := def.MergeAppEnvironment(app.Name)
		if !ok {
			return &SyncResults{}, nil
		}
		e.Walk(func(env string, name string, val appdef.EnvValue) {
			if val.Source != appdef.EnvSourceSOPS {
				return
			}
			refs = append(refs, reference{
				Key:         name,
				Environment: env,
				AppNames:    []string{app.Name},
			})
		})
	}

	// 2. Deduplicate (same key in same env used by multiple apps).
	refs = deduplicateByKey(refs)
	if len(refs) == 0 {
		return &SyncResults{}, nil
	}

	// 3. Group by file (environment determines the file).
	grouped := make(map[string][]reference)
	for _, ref := range refs {
		grouped[ref.GetFilePath()] = append(grouped[ref.GetFilePath()], ref)
	}

	// 4. Process each file
	results := &SyncResults{Files: make([]SyncResult, 0, len(grouped))}
	for filePath, secrets := range grouped {
		results.Files = append(results.Files, processFile(cfg.FS, filePath, secrets))
	}

	return results, nil
}

type reference struct {
	Key         string   // e.g., "PAYLOAD_SECRET"
	Environment string   // e.g., "production", "staging", "development"
	AppNames    []string // Apps using this secret
}

// GetFilePath returns the SOPS file path for this reference
func (r reference) GetFilePath() string {
	return filepath.Join(FilePath, r.Environment+".yaml")
}

// DeduplicateByKey removes duplicate keys (same key used by multiple apps)
// and merges their app names
func deduplicateByKey(refs []reference) []reference {
	keyMap := make(map[string]*reference)

	for _, ref := range refs {
		key := fmt.Sprintf("%s:%s", ref.Environment, ref.Key)
		if existing, ok := keyMap[key]; ok {
			existing.AppNames = append(existing.AppNames, ref.AppNames...)
		} else {
			refCopy := ref
			keyMap[key] = &refCopy
		}
	}

	result := make([]reference, 0, len(keyMap))
	for _, ref := range keyMap {
		result = append(result, *ref)
	}

	return result
}

// processFile processes a single secret file by adding missing placeholders.
// It checks if the file exists, is encrypted, and adds any missing secret keys.
func processFile(fs afero.Fs, filePath string, secrets []reference) SyncResult {
	result := SyncResult{
		FilePath:     filePath,
		AddedSecrets: []SecretInfo{},
	}

	exists, err := afero.Exists(fs, filePath)
	if err != nil {
		result.Error = fmt.Errorf("checking file existence: %w", err)
		return result
	}

	if !exists {
		result.WasMissing = true
		return result
	}

	content, err := afero.ReadFile(fs, filePath)
	if err != nil {
		result.Error = fmt.Errorf("reading file: %w", err)
		return result
	}

	if sops.IsContentEncrypted(content) {
		result.WasEncrypted = true
		return result
	}

	// Parse existing keys
	var data map[string]any
	if err := yaml.Unmarshal(content, &data); err != nil {
		result.Error = fmt.Errorf("parsing YAML: %w", err)
		return result
	}

	if data == nil {
		data = make(map[string]any)
	}

	// Process each secret reference and check if they exist
	// in the file; if they don't add a placeholder.
	var additions bytes.Buffer
	for _, secret := range secrets {
		if _, exists = data[secret.Key]; exists {
			result.Skipped++
			continue
		}

		result.Added++
		result.AddedSecrets = append(result.AddedSecrets, SecretInfo{
			Key:      secret.Key,
			AppNames: secret.AppNames,
		})

		additions.WriteString(fmt.Sprintf("%s: \"REPLACE_ME_%s\"\n",
			secret.Key, strings.ToUpper(secret.Key)))
	}

	// Write back to the file if any of the secrets
	// need scaffolding to the file.
	if result.Added > 0 {
		updatedContent := append(content, []byte(additions.String())...)
		if err = afero.WriteFile(fs, filePath, updatedContent, 0644); err != nil {
			result.Error = fmt.Errorf("writing file: %w", err)
			return result
		}
	}

	return result
}
```

## File: internal/secrets/validate.go
```go
package secrets

import (
	"fmt"
	"strings"

	"github.com/spf13/afero"
	"gopkg.in/yaml.v3"

	"github.com/ainsleydev/webkit/internal/appdef"
	"github.com/ainsleydev/webkit/internal/secrets/sops"
)

// ValidationResult contains the results of validating secrets
type ValidationResult struct {
	Valid          bool
	MissingSecrets []MissingSecret
	OrphanedKeys   []OrphanedKey
	Files          []FileValidation
}

// MissingSecret represents a secret referenced in app.json but not found in SOPS files
type MissingSecret struct {
	Key         string
	Environment string
	AppName     string
	ExpectedIn  string // Which SOPS file it should be in
}

// OrphanedKey represents a key in SOPS files not referenced in app.json
type OrphanedKey struct {
	Key      string
	FilePath string
}

// FileValidation contains validation results for a single file
type FileValidation struct {
	FilePath     string
	Exists       bool
	IsEncrypted  bool
	MissingKeys  []string
	OrphanedKeys []string
	Error        error
}

// ValidateConfig holds configuration for secret validation
type ValidateConfig struct {
	FS               afero.Fs
	AppDef           *appdef.Definition
	CheckOrphans     bool // Whether to report keys in SOPS files not in app.json
	AllowEncrypted   bool // Whether encrypted files should be validated
	SecretsDirectory string
}

// Validate checks that all secrets referenced in app.json exist in their respective SOPS files
func Validate(cfg ValidateConfig) (*ValidationResult, error) {
	if cfg.SecretsDirectory == "" {
		cfg.SecretsDirectory = "FilePath"
	}

	result := &ValidationResult{
		Valid:          true,
		MissingSecrets: []MissingSecret{},
		OrphanedKeys:   []OrphanedKey{},
		Files:          []FileValidation{},
	}

	// Build map of all secrets that should exist
	expectedSecrets := buildExpectedSecretsMap(cfg.AppDef)

	// Validate each environment's secret file
	environments := []string{"development", "staging", "production"}

	for _, env := range environments {
		filePath := fmt.Sprintf("%s/%s.yaml", cfg.SecretsDirectory, env)
		fileResult := validateSecretFile(cfg.FS, filePath, expectedSecrets[env], cfg)

		result.Files = append(result.Files, fileResult)

		// Aggregate missing secrets
		for _, key := range fileResult.MissingKeys {
			result.MissingSecrets = append(result.MissingSecrets, MissingSecret{
				Key:         key,
				Environment: env,
				AppName:     findAppForSecret(cfg.AppDef, env, key),
				ExpectedIn:  filePath,
			})
			result.Valid = false
		}

		// Aggregate orphaned keys if checking
		if cfg.CheckOrphans {
			for _, key := range fileResult.OrphanedKeys {
				result.OrphanedKeys = append(result.OrphanedKeys, OrphanedKey{
					Key:      key,
					FilePath: filePath,
				})
			}
		}

		if fileResult.Error != nil {
			result.Valid = false
		}
	}

	return result, nil
}

// buildExpectedSecretsMap creates a map of environment -> set of expected secret keys
func buildExpectedSecretsMap(def *appdef.Definition) map[string]map[string]bool {
	expected := map[string]map[string]bool{
		"development": make(map[string]bool),
		"staging":     make(map[string]bool),
		"production":  make(map[string]bool),
	}

	// Collect secrets from shared environment
	def.Shared.Env.Walk(func(env string, name string, value appdef.EnvValue) {
		if value.Source == appdef.EnvSourceSOPS {
			expected[env][name] = true
		}
	})

	// Collect secrets from each app's environment
	for _, app := range def.Apps {
		app.Env.Walk(func(env string, name string, value appdef.EnvValue) {
			if value.Source == appdef.EnvSourceSOPS {
				expected[env][name] = true
			}
		})
	}

	return expected
}

// validateSecretFile validates a single SOPS file against expected secrets
func validateSecretFile(fs afero.Fs, filePath string, expectedKeys map[string]bool, cfg ValidateConfig) FileValidation {
	result := FileValidation{
		FilePath:     filePath,
		MissingKeys:  []string{},
		OrphanedKeys: []string{},
	}

	// Check if file exists
	exists, err := afero.Exists(fs, filePath)
	if err != nil {
		result.Error = fmt.Errorf("checking file existence: %w", err)
		return result
	}
	result.Exists = exists

	if !exists {
		// All expected keys are missing
		for key := range expectedKeys {
			result.MissingKeys = append(result.MissingKeys, key)
		}
		return result
	}

	// Read file
	data, err := afero.ReadFile(fs, filePath)
	if err != nil {
		result.Error = fmt.Errorf("reading file: %w", err)
		return result
	}

	// Check if encrypted
	result.IsEncrypted = sops.IsContentEncrypted(data)

	if result.IsEncrypted && !cfg.AllowEncrypted {
		result.Error = fmt.Errorf("file is encrypted - cannot validate (decrypt first or use --allow-encrypted)")
		return result
	}

	// Parse YAML to get actual keys
	actualKeys, err := extractYAMLKeys(data)
	if err != nil {
		result.Error = fmt.Errorf("parsing YAML: %w", err)
		return result
	}

	// Find missing keys
	for expectedKey := range expectedKeys {
		if !actualKeys[expectedKey] {
			result.MissingKeys = append(result.MissingKeys, expectedKey)
		}
	}

	// Find orphaned keys (if checking)
	if cfg.CheckOrphans {
		for actualKey := range actualKeys {
			if !expectedKeys[actualKey] {
				result.OrphanedKeys = append(result.OrphanedKeys, actualKey)
			}
		}
	}

	return result
}

// findAppForSecret finds which app uses a given secret
func findAppForSecret(def *appdef.Definition, env string, key string) string {
	// Check shared first
	sharedEnv := getEnvForEnvironment(def.Shared.Env, env)
	if sharedEnv != nil {
		if val, exists := sharedEnv[key]; exists && val.Source == appdef.EnvSourceSOPS {
			return "shared"
		}
	}

	// Check each app
	for _, app := range def.Apps {
		appEnv := getEnvForEnvironment(app.Env, env)
		if appEnv != nil {
			if val, exists := appEnv[key]; exists && val.Source == appdef.EnvSourceSOPS {
				return app.Name
			}
		}
	}

	return "unknown"
}

// getEnvForEnvironment extracts the appropriate EnvVar for an environment name
func getEnvForEnvironment(env appdef.Environment, envName string) appdef.EnvVar {
	switch envName {
	case "development":
		return env.Dev
	case "staging":
		return env.Staging
	case "production":
		return env.Production
	default:
		return nil
	}
}

// extractYAMLKeys parses YAML and returns all top-level keys
func extractYAMLKeys(data []byte) (map[string]bool, error) {
	// Reuse existing YAML parsing logic
	parsed := make(map[string]interface{})
	if err := yaml.Unmarshal(data, &parsed); err != nil {
		return nil, err
	}

	keys := make(map[string]bool)
	for k := range parsed {
		// Skip SOPS metadata keys
		if !strings.HasPrefix(k, "sops_") && k != "sops" {
			keys[k] = true
		}
	}

	return keys, nil
}
```

## File: internal/templates/funcs.go
```go
package templates

import "fmt"

// secret wraps a secret name in GitHub Actions syntax
func secret(name string) string {
	return fmt.Sprintf("{{ secrets.%s }}", name)
}
```

## File: internal/testutil/action_validator.go
```go
package testutil

import (
	"errors"
	"fmt"
	"os"
	"os/exec"
	"testing"

	"github.com/stretchr/testify/assert"
	"gopkg.in/yaml.v3"
)

// ValidateYAML checks whether the bytes contain valid YAML syntax.
func ValidateYAML(t *testing.T, data []byte) error {
	t.Helper()
	var out any
	if err := yaml.Unmarshal(data, &out); err != nil {
		return fmt.Errorf("invalid YAML: %w", err)
	}
	return nil
}

// ValidateGithubAction validates a GitHub Actions YAML file using
// action-validator. If it conforms to GitHub actions spec,
// no error will be returned.
//
// Ref: https://github.com/mpalmer/action-validator
func ValidateGithubAction(t *testing.T, data []byte) error {
	t.Helper()

	// Check if action-validator is installed
	if _, err := exec.LookPath("action-validator"); err != nil {
		return errors.New("action-validator is not installed; see: https://github.com/mpalmer/action-validator")
	}

	// Write the YAML to a temporary file
	tmpFile, err := os.CreateTemp("", "action-validate-*.yml")
	if err != nil {
		return fmt.Errorf("failed to create temp file: %w", err)
	}
	defer func(name string) {
		assert.NoError(t, os.Remove(name))
	}(tmpFile.Name()) // Ensure cleanup

	if _, err := tmpFile.Write(data); err != nil {
		return fmt.Errorf("failed to write temp file: %w", err)
	}
	tmpFile.Close()

	// Run the action-validator command
	cmd := exec.Command("action-validator", tmpFile.Name())
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("validation failed:\n%s", string(output))
	}

	return nil
}
```

## File: internal/testutil/afero.go
```go
package testutil

import (
	"fmt"
	"os"

	"github.com/spf13/afero"
)

type AferoErrCreateFs struct {
	afero.Fs
}

func (e *AferoErrCreateFs) Create(_ string) (afero.File, error) {
	return nil, fmt.Errorf("create error")
}

func (e *AferoErrCreateFs) OpenFile(_ string, _ int, _ os.FileMode) (afero.File, error) {
	return nil, fmt.Errorf("openfile error")
}
```

## File: internal/appdef/apps_test.go
```go
package appdef

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestAppType_String(t *testing.T) {
	t.Parallel()

	got := AppTypeGoLang.String()
	assert.Equal(t, "golang", got)
	assert.IsType(t, "", got)
}

func TestApp_Language(t *testing.T) {
	t.Parallel()

	tt := []struct {
		input AppType
		want  string
	}{
		{input: AppTypeGoLang, want: "go"},
		{input: AppTypePayload, want: "js"},
		{input: AppTypeSvelteKit, want: "js"},
	}

	for _, test := range tt {
		t.Run(test.input.String(), func(t *testing.T) {
			t.Parallel()
			a := App{Type: test.input}
			got := a.Language()
			assert.Equal(t, test.want, got)
		})
	}
}

func TestDomainType_String(t *testing.T) {
	t.Parallel()

	got := DomainTypePrimary.String()
	assert.Equal(t, "primary", got)
	assert.IsType(t, "", got)
}

func TestApp_OrderedCommands(t *testing.T) {
	t.Parallel()

	app := &App{
		Name: "web",
		Type: AppTypeGoLang,
		Path: "./",
	}

	err := app.applyDefaults()
	require.NoError(t, err)

	commands := app.OrderedCommands()
	require.Len(t, commands, 4)

	t.Log("In Order")
	{
		assert.Equal(t, "format", commands[0].Name)
		assert.Equal(t, "lint", commands[1].Name)
		assert.Equal(t, "test", commands[2].Name)
		assert.Equal(t, "build", commands[3].Name)
	}

	t.Log("Check CMD is Populated")
	{
		assert.Equal(t, "gofmt -w .", commands[0].Cmd)
		assert.Equal(t, "golangci-lint run", commands[1].Cmd)
		assert.Equal(t, "go test ./...", commands[2].Cmd)
		assert.Equal(t, "go build main.go", commands[3].Cmd)
	}
}
```

## File: internal/appdef/resources_test.go
```go
package appdef

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestResourceType_String(t *testing.T) {
	t.Parallel()

	got := ResourceTypePostgres.String()
	assert.Equal(t, "postgres", got)
	assert.IsType(t, "", got)

}

func TestResourceProvider_String(t *testing.T) {
	t.Parallel()

	got := ResourceProviderDigitalOcean.String()
	assert.Equal(t, "digital-ocean", got)
	assert.IsType(t, "", got)
}

func TestResourceApplyDefaults(t *testing.T) {
	t.Parallel()

	tt := map[string]struct {
		input Resource
		want  Resource
	}{
		"Nil Config And Outputs": {
			input: Resource{},
			want: Resource{
				Config:  make(map[string]any),
				Outputs: []string{},
				Backup: ResourceBackupConfig{
					Enabled: true,
				},
			},
		},
		"Existing Config And Outputs": {
			input: Resource{
				Config:  map[string]any{"size": "small"},
				Outputs: []string{"url"},
			},
			want: Resource{
				Config:  map[string]any{"size": "small"},
				Outputs: []string{"url"},
				Backup: ResourceBackupConfig{
					Enabled: true,
				},
			},
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			t.Parallel()
			err := test.input.applyDefaults()
			assert.NoError(t, err)
			assert.Equal(t, test.want, test.input)
		})
	}
}
```

## File: internal/appdef/resources.go
```go
package appdef

type (
	// Resource represents an infrastructure component that an application
	// depends on, such as databases, storage buckets or caches.
	Resource struct {
		Name     string               `json:"name"`
		Type     ResourceType         `json:"type"`
		Provider ResourceProvider     `json:"provider"`
		Config   map[string]any       `json:"config"` // Conforms to Terraform
		Outputs  []string             `json:"outputs"`
		Backup   ResourceBackupConfig `json:"backup,omitempty"`
	}
	// ResourceBackupConfig defines optional backup behavior for a resource.
	// Backup is enabled by default.
	ResourceBackupConfig struct {
		Enabled bool `json:"enabled"`
	}
)

// ResourceType defines the type of resource to be provisioned.
type ResourceType string

// ResourceType constants.
const (
	ResourceTypePostgres ResourceType = "postgres"
	ResourceTypeS3       AppType      = "s3"
)

// String implements fmt.Stringer on the ResourceType.
func (r ResourceType) String() string {
	return string(r)
}

// ResourceProvider defines a provider of cloud infra.
type ResourceProvider string

// ResourceProvider constants.
const (
	ResourceProviderDigitalOcean ResourceProvider = "digital-ocean"
	ResourceProviderBackBlaze    ResourceProvider = "backblaze"
)

// String implements fmt.Stringer on the ResourceProvider.
func (r ResourceProvider) String() string {
	return string(r)
}

// applyDefaults applies default values to a Resource.
func (r *Resource) applyDefaults() error {
	if r.Config == nil {
		r.Config = make(map[string]any)
	}

	if r.Outputs == nil {
		r.Outputs = []string{}
	}

	r.Backup = ResourceBackupConfig{
		Enabled: true,
	}

	// Apply type-specific defaults
	// TODO: These types should be nicely hardcoded.
	switch r.Type {
	case "postgres":
		if _, ok := r.Config["engine_version"]; !ok {
			r.Config["engine_version"] = "17"
		}
	case "s3":
		if _, ok := r.Config["acl"]; !ok {
			r.Config["acl"] = "private"
		}
	}

	return nil
}
```

## File: internal/cmd/internal/operations/ci_cd_test.go
```go
package operations

import (
	"fmt"
	"strings"
	"testing"

	"github.com/spf13/afero"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/ainsleydev/webkit/internal/appdef"
	"github.com/ainsleydev/webkit/internal/cmd/internal/cmdtools"
	"github.com/ainsleydev/webkit/internal/testutil"
)

func TestCreateCICD(t *testing.T) {
	t.Parallel()

	t.Run("PRs", func(t *testing.T) {
		t.Parallel()

		tt := map[string]struct {
			input appdef.App
			want  string
		}{
			"Javascript": {
				input: appdef.App{
					Name:  "cms",
					Title: "CMS",
					Path:  "./cms",
					Type:  appdef.AppTypePayload,
				},
				want: ".github/workflows/pr-cms.yaml",
			},
			"Go": {
				input: appdef.App{
					Name:  "web",
					Title: "Web",
					Path:  "./web",
					Type:  appdef.AppTypeGoLang,
				},
				want: ".github/workflows/pr-web.yaml",
			},
		}

		for name, test := range tt {
			t.Run(name, func(t *testing.T) {
				t.Parallel()

				fs := afero.NewMemMapFs()
				def := &appdef.Definition{Apps: []appdef.App{test.input}}
				require.NoError(t, def.ApplyDefaults())

				err := CreateCICD(t.Context(), cmdtools.CommandInput{
					FS:          fs,
					AppDefCache: def,
				})
				require.NoError(t, err)

				file, err := afero.ReadFile(fs, test.want)
				require.NoError(t, err)

				t.Log("YAML is valid")
				{
					err = testutil.ValidateYAML(t, file)
					assert.NoError(t, err)
				}

				content := string(file)
				fmt.Print(string(content))

				t.Log("Github Action is validated")
				{
					err = testutil.ValidateGithubAction(t, file)
					require.NoError(t, err)
				}

				t.Log("Commands are in order")
				{
					content := string(file)

					// Get positions for each command in the canonical order
					var positions []int
					for _, cmd := range appdef.Commands {
						pos := strings.Index(content, "name: "+strings.Title(cmd.String()))
						if pos != -1 {
							positions = append(positions, pos)
						}
					}

					// Verify positions are in ascending order
					for i := 0; i < len(positions)-1; i++ {
						assert.Less(t, positions[i], positions[i+1],
							"commands should appear in order defined by appdef.Commands")
					}
				}
			})
		}
	})
}
```

## File: internal/cmd/internal/operations/git_settings.go
```go
package operations

import (
	"context"

	"github.com/ainsleydev/webkit/internal/cmd/internal/cmdtools"
	"github.com/ainsleydev/webkit/internal/cmd/internal/schemas/github"
	"github.com/ainsleydev/webkit/internal/scaffold"
	"github.com/ainsleydev/webkit/internal/templates"
)

var gitSettingsTemplates = map[string]string{
	".gitignore":              ".gitignore",
	".github/dependabot.yaml": ".github/dependabot.yaml.tmpl",
}

// CreateGitSettings scaffolds the repo settings and ignore files.
//
// TODO: Stale, Pull Request Template.
func CreateGitSettings(_ context.Context, input cmdtools.CommandInput) error {
	gen := scaffold.New(input.FS)
	app := input.AppDef()

	for file, template := range gitSettingsTemplates {
		tpl := templates.MustLoadTemplate(template)
		err := gen.Template(file, tpl, app)
		if err != nil {
			return err
		}
	}

	return gen.YAML(".github/settings.yaml", repoSettings(input))
}

func repoSettings(input cmdtools.CommandInput) github.RepoSettings {
	return github.RepoSettings{
		Repository: github.Repository{
			AllowMergeCommit:    false,
			DeleteBranchOnMerge: true,
			Topics:              input.AppDef().GithubLabels(),
			Private:             true,
			HasWiki:             false,
			HasDownloads:        false,
		},
		Branches: []github.Branch{
			{
				Name: "main",
				Protection: &github.BranchProtection{
					RequiredPullRequestReviews: &github.RequiredPullRequestReviews{
						DismissStaleReviews:          true,
						RequireCodeOwnerReviews:      true,
						RequiredApprovingReviewCount: 1,
					},
					EnforceAdmins: true,
				},
			},
		},
	}
}
```

## File: internal/cmd/internal/operations/package_json_test.go
```go
package operations

import (
	"testing"

	"github.com/spf13/afero"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/ainsleydev/webkit/internal/appdef"
	"github.com/ainsleydev/webkit/internal/cmd/internal/cmdtools"
	"github.com/ainsleydev/webkit/internal/testutil"
)

func TestCreatePackageJson(t *testing.T) {
	t.Parallel()

	fs := afero.NewMemMapFs()

	appDef := &appdef.Definition{
		Project: appdef.Project{Name: "my-website"},
		Apps: []appdef.App{
			{
				Name: "cms",
				Type: appdef.AppTypePayload,
				Path: "cms",
			},
		},
	}

	err := CreatePackageJson(t.Context(), cmdtools.CommandInput{
		FS:          fs,
		AppDefCache: appDef,
	})
	assert.NoError(t, err)

	t.Log("File Exists")
	{
		exists, err := afero.Exists(fs, "package.json")
		assert.NoError(t, err)
		assert.True(t, exists)
	}

	t.Log("Conforms to Schema")
	{
		schema, err := testutil.SchemaFromURL(t, "https://www.schemastore.org/package.json")
		require.NoError(t, err)

		file, err := afero.ReadFile(fs, "package.json")
		require.NoError(t, err)

		err = schema.ValidateJSON(file)
		assert.NoError(t, err, "Package.json file conforms to schema")
	}
}
```

## File: internal/git/git_integration_test.go
```go
//go:build integration
// +build integration

package git_test

import (
	"context"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/ainsleydev/webkit/internal/executil"
	"github.com/ainsleydev/webkit/internal/git"
)

func TestIntegration_Clone(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test")
	}

	ctx, cancel := context.WithTimeout(t.Context(), 2*time.Minute)
	defer cancel()

	client, err := git.New(executil.DefaultRunner())
	require.NoError(t, err)

	tmpDir := t.TempDir()
	repoPath := filepath.Join(tmpDir, "webkit")

	t.Log("Clone Repo")
	{
		cfg := git.CloneConfig{
			URL:       "https://github.com/ainsleydev/webkit.git",
			LocalPath: repoPath,
			Ref:       "main",
			Depth:     1,
		}

		err = client.Clone(ctx, cfg)
		require.NoError(t, err)
	}

	t.Logf("Verify the repository was cloned at %s", repoPath)
	{
		assert.True(t, git.IsRepository(repoPath))
	}

	t.Log("Verify .git directory exists")
	{
		gitDir := filepath.Join(repoPath, ".git")
		_, err = os.Stat(gitDir)
		require.NoError(t, err)
	}

	t.Log("Verify some WebKit files exist")
	{
		readmePath := filepath.Join(repoPath, "README.md")
		_, err = os.Stat(readmePath)
		assert.NoError(t, err, "README.md should exist")
	}

	if testing.Verbose() {
		logTopLevelContents(t, repoPath)
	}
}

func TestIntegration_Update(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test")
	}

	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
	defer cancel()

	client, err := git.New(executil.DefaultRunner())
	require.NoError(t, err)

	tmpDir := t.TempDir()
	repoPath := filepath.Join(tmpDir, "webkit")

	t.Log("Clone repository initially")
	{
		cfg := git.CloneConfig{
			URL:       "https://github.com/ainsleydev/webkit.git",
			LocalPath: repoPath,
			Ref:       "main",
			Depth:     1,
		}

		err = client.Clone(ctx, cfg)
		require.NoError(t, err)
	}

	t.Log("Update the repository")
	{
		err = client.Update(ctx, repoPath, "main")
		require.NoError(t, err)
	}

	t.Log("Verify repository is still valid")
	{
		assert.True(t, git.IsRepository(repoPath))
	}

	if testing.Verbose() {
		logTopLevelContents(t, repoPath)
	}
}

func TestIntegration_CloneOrUpdate(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test")
	}

	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
	defer cancel()

	client, err := git.New(executil.DefaultRunner())
	require.NoError(t, err)

	tmpDir := t.TempDir()
	repoPath := filepath.Join(tmpDir, "webkit")

	cfg := git.CloneConfig{
		URL:       "https://github.com/ainsleydev/webkit.git",
		LocalPath: repoPath,
		Ref:       "main",
		Depth:     1,
	}

	t.Log("First call should clone")
	{
		err = client.CloneOrUpdate(ctx, cfg)
		require.NoError(t, err)
		assert.True(t, git.IsRepository(repoPath))
	}

	t.Log("Second call should update existing repository")
	{
		err = client.CloneOrUpdate(ctx, cfg)
		require.NoError(t, err)
		assert.True(t, git.IsRepository(repoPath))
	}

	if testing.Verbose() {
		logTopLevelContents(t, repoPath)
	}
}

func logTopLevelContents(t *testing.T, path string) {
	t.Helper()

	entries, err := os.ReadDir(path)
	if err != nil {
		t.Logf("Error reading directory: %v", err)
		return
	}

	t.Logf("Contents of %s:", path)
	for _, entry := range entries {
		if entry.IsDir() {
			t.Logf("  %s/", entry.Name())
		} else {
			t.Logf("  %s", entry.Name())
		}
	}
}
```

## File: internal/scaffold/options.go
```go
package scaffold

// Option is a function that configures write options
type Option func(*writeOptions)

// writeOptions holds configuration for write operations
type writeOptions struct {
	mode WriteMode
}

// WithScaffoldMode sets the write mode for the operation
func WithScaffoldMode() Option {
	return func(opts *writeOptions) {
		opts.mode = ModeScaffold
	}
}

// defaultOptions returns the default write options
func defaultOptions() *writeOptions {
	return &writeOptions{
		mode: ModeGenerate,
	}
}

// applyOptions applies the given options to writeOptions
func applyOptions(opts ...Option) *writeOptions {
	o := defaultOptions()
	for _, opt := range opts {
		opt(o)
	}
	return o
}
```

## File: internal/secrets/sops/map.go
```go
package sops

import (
	"fmt"
	"os"

	"gopkg.in/yaml.v3"
)

// DecryptFileToMap decrypts a file using the provided Decrypter and
// returns the content as a map[string]any.
func DecryptFileToMap(ec EncrypterDecrypter, filePath string) (map[string]any, error) {
	if err := ec.Decrypt(filePath); err != nil {
		return nil, err
	}

	content, err := os.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read sops file: %w", err)
	}

	var data map[string]any
	if err = yaml.Unmarshal(content, &data); err != nil {
		return nil, fmt.Errorf("failed to parse sops content: %w", err)
	}

	// Make sure the file is encrypted after we've
	return data, ec.Encrypt(filePath)
}
```

## File: internal/secrets/resolve.go
```go
package secrets

import (
	"fmt"

	"github.com/ainsleydev/webkit/internal/appdef"
	"github.com/ainsleydev/webkit/internal/secrets/age"
	"github.com/ainsleydev/webkit/internal/secrets/sops"
)

// ResolvedEnvVar represents an environment variable that has been
// fully resolved (decrypted if necessary) and is ready for Terraform.
type ResolvedEnvVar struct {
	Key   string
	Value string
	Type  EnvVarType
}

// EnvVarType indicates how Terraform should handle the variable
type EnvVarType string

const (
	EnvVarTypeGeneral EnvVarType = "GENERAL"
	EnvVarTypeSecret  EnvVarType = "SECRET"
)

// Resolver decrypts and resolves environment variables from the app definition
type Resolver struct {
	sopsClient sops.EncrypterDecrypter
}

// NewResolver creates a new environment variable resolver with SOPS support
func NewResolver() (*Resolver, error) {
	// Initialize age provider (checks SOPS_AGE_KEY env var or ~/.config/webkit/age.key)
	ageProvider, err := age.NewProvider()
	if err != nil {
		return nil, fmt.Errorf("failed to initialize age provider: %w", err)
	}

	return &Resolver{
		sopsClient: sops.NewClient(ageProvider),
	}, nil
}

// ResolveEnvironmentVariables resolves all environment variables for a given environment.
// It handles three source types:
// - "value": static string value (pass through)
// - "resource": Terraform resource reference (formatted as "resource:name.output")
// - "sops": encrypted secret (decrypted using SOPS)
func (r *Resolver) ResolveEnvironmentVariables(envVars appdef.EnvVar) (appdef.EnvVar, error) {
	resolved := make([]ResolvedEnvVar, 0, len(envVars))

	for key, config := range envVars {
		var resolvedVar ResolvedEnvVar
		var err error

		switch config.Source {
		case appdef.EnvSourceValue:
			// Static value - use as-is
			resolvedVar = ResolvedEnvVar{
				Key:   key,
				Value: config.Value,
				Type:  EnvVarTypeGeneral,
			}

		case appdef.EnvSourceResource:
			// Resource reference - format for Terraform to resolve later
			// e.g., "db.connection_url" → "resource:db.connection_url"
			resolvedVar = ResolvedEnvVar{
				Key:   key,
				Value: fmt.Sprintf("resource:%s", config.Value),
				Type:  EnvVarTypeGeneral,
			}

		case appdef.EnvSourceSOPS:
			// SOPS secret - decrypt now
			//resolvedVar, err = r.decryptSOPSSecret(key, config.Value)
			if err != nil {
				return nil, fmt.Errorf("failed to decrypt %s: %w", key, err)
			}

		default:
			return nil, fmt.Errorf("unknown env var source type: %s for key: %s", config.Source, key)
		}

		resolved = append(resolved, resolvedVar)
	}

	return nil, nil
	//return resolved, nil
}
```

## File: internal/secrets/secrets.go
```go
package secrets

import "path/filepath"

// AgePublicKey is the public key for encrypting SOPS files.
const AgePublicKey = "age1ql3z7hjy54pw3hyww5ayyfg7zqgvc7w3j2elw8zmrj2kg5sfn9aqmcac8p"

// FilePath defines the path where SOPS encrypted YAML files
// reside in the Webkit app. Needs a base path prepended.
var FilePath = filepath.Join("resources", "secrets")
```

## File: internal/cmd/internal/operations/code_style.go
```go
package operations

import (
	"context"

	"github.com/ainsleydev/webkit/internal/cmd/internal/cmdtools"
	"github.com/ainsleydev/webkit/internal/scaffold"
	"github.com/ainsleydev/webkit/internal/templates"
)

var codeStyleTemplates = map[string]string{
	".editorconfig":    ".editorconfig",
	".prettierrc":      ".prettierrc",
	".prettierignore":  ".prettierignore",
	"eslint.config.js": "eslint.config.js.tmpl",
	// TODO: .stylelintrc
}

// CreateCodeStyleFiles scaffolds' developer and formatting files for
// the project, mainly dotfiles.
//
// IDEA: Might be good in the AppDef if we could specify what files
// we want to generate or exclude from this.
func CreateCodeStyleFiles(_ context.Context, input cmdtools.CommandInput) error {
	gen := scaffold.New(input.FS)
	app := input.AppDef()

	for file, template := range codeStyleTemplates {
		tpl := templates.MustLoadTemplate(template)
		err := gen.Template(file, tpl, app)
		if err != nil {
			return err
		}
	}

	return nil
}
```

## File: internal/cmd/internal/operations/git_settings_test.go
```go
package operations

import (
	"testing"

	"github.com/spf13/afero"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/ainsleydev/webkit/internal/appdef"
	"github.com/ainsleydev/webkit/internal/cmd/internal/cmdtools"
	"github.com/ainsleydev/webkit/internal/testutil"
)

func TestCreateGitSettings(t *testing.T) {
	t.Parallel()

	appDef := &appdef.Definition{
		Project: appdef.Project{Name: "my-website"},
		Apps: []appdef.App{
			{
				Name: "cms",
				Type: appdef.AppTypePayload,
				Path: "cms",
			},
		},
	}

	t.Run("Creates Successfully", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()

		err := CreateGitSettings(t.Context(), cmdtools.CommandInput{
			FS:          fs,
			AppDefCache: appDef,
		})
		assert.NoError(t, err)

		for path := range gitSettingsTemplates {
			file, err := afero.ReadFile(fs, path)
			assert.NoError(t, err)
			assert.NotEmpty(t, file)
		}

		// Check settings.yaml exists
		settingsFile, err := afero.ReadFile(fs, ".github/settings.yaml")
		assert.NoError(t, err)
		assert.NotEmpty(t, settingsFile)
		assert.NoError(t, testutil.ValidateYAML(t, settingsFile))
	})

	t.Run("Validates dependabot.yaml schema", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()
		err := CreateGitSettings(t.Context(), cmdtools.CommandInput{
			FS:          fs,
			AppDefCache: appDef,
		})
		assert.NoError(t, err)

		schema, err := testutil.SchemaFromURL(t, "https://www.schemastore.org/dependabot-2.0.json")
		require.NoError(t, err)

		dep, err := afero.ReadFile(fs, ".github/dependabot.yaml")
		require.NoError(t, err)

		err = schema.ValidateYAML(dep)
		assert.NoError(t, err, "Dependabot file conforms to schema")
	})

	t.Run("Errors on FS Failure", func(t *testing.T) {
		t.Parallel()

		err := CreateGitSettings(t.Context(), cmdtools.CommandInput{
			FS:          &testutil.AferoErrCreateFs{Fs: afero.NewMemMapFs()},
			AppDefCache: &appdef.Definition{},
		})
		assert.Error(t, err)
	})
}
```

## File: internal/cmd/internal/operations/package_json.go
```go
package operations

import (
	"context"

	"github.com/ainsleydev/webkit/internal/cmd/internal/cmdtools"
	"github.com/ainsleydev/webkit/internal/scaffold"
)

// CreatePackageJson scaffolds a root JSON file to act as a
// starting point for repos.
func CreatePackageJson(_ context.Context, input cmdtools.CommandInput) error {
	gen := scaffold.New(input.FS)
	app := input.AppDef()

	p := packageJSON{
		Name:        app.Project.Name,
		Description: app.Project.Description,
		Version:     "1.0.0",
		Private:     "false",
		License:     "BSD-3-Clause",
		Type:        "module",
		Scripts: map[string]string{
			"preinstall": "npx only-allow pnpm",
			"test":       "turbo test",
			"lint":       "eslint .",
			"lint:fix":   "eslint . --fix",
			"format":     "prettier --write .",
		},
		DevDependencies: map[string]string{
			"@ainsleydev/eslint-config":   "^0.0.6",
			"@ainsleydev/prettier-config": "^0.0.2",
			"@eslint/compat":              "^1.4.0",
			"@payloadcms/eslint-config":   "^3.28.0",
			"@payloadcms/eslint-plugin":   "^3.28.0",
			"eslint":                      "^9.37.0",
			"eslint-plugin-perfectionist": "^4.15.1",
			"globals":                     "^16.0.0",
			"prettier":                    "^3.6.0",
			"prettier-plugin-svelte":      "^3.4.0",
			"turbo":                       "^2.5.8",
			"typescript":                  "5.8.2",
		},
		PackageManager: "pnpm@10.15.0",
		Engines:        nil,
		Pnpm:           packagePnpm{},
		Author: packageAuthor{
			Name:  "ainsley.dev LTD",
			Email: "hello@ainsley.dev",
			URL:   "https://ainsley.dev",
		},
		Maintainers: []packageAuthor{
			{
				Name:  "Ainsley Clark",
				Email: "hello@ainsley.dev",
				URL:   "https://ainsley.dev",
			},
		},
	}

	return gen.JSON("package.json", p)
}

type (
	packageJSON struct {
		Name            string            `json:"name"`
		Version         string            `json:"version"`
		Description     string            `json:"description,omitempty"`
		Private         string            `json:"private"`
		License         string            `json:"license"`
		Type            string            `json:"type"`
		Scripts         map[string]string `json:"scripts"`
		DevDependencies map[string]string `json:"devDependencies"`
		PackageManager  string            `json:"packageManager"`
		Engines         map[string]string `json:"engines,omitempty"`
		Pnpm            packagePnpm       `json:"pnpm,omitzero"`
		Author          packageAuthor     `json:"author"`
		Maintainers     []packageAuthor   `json:"maintainers"`
	}
	packageAuthor struct {
		Name  string `json:"name"`
		Email string `json:"email"`
		URL   string `json:"url"`
	}
	packagePnpm struct {
		OnlyBuiltDependencies []string `json:"onlyBuiltDependencies,omitempty"`
	}
)
```

## File: internal/git/git_test.go
```go
package git

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/ainsleydev/webkit/internal/executil"
)

func setupClient(t *testing.T) (*Client, *executil.MemRunner) {
	t.Helper()
	mock := executil.NewMemRunner()
	client, err := New(mock)
	require.NoError(t, err)
	return client, mock
}

//func TestNewGitCommandMissing(t *testing.T) {
//	t.Parallel()
//
//	t.Run("Git Not Found In PATH", func(t *testing.T) {
//		t.Parallel()
//
//		// Patch cmdutil.Exists to simulate git missing
//		origExists := cmdutil.Exists
//		cmdutil.Exists = func(name string) bool { return false }
//		defer func() { cmdutil.Exists = origExists }()
//
//		_, err := New(nil)
//		assert.Error(t, err)
//		assert.Contains(t, err.Error(), "git command not found")
//	})
//}

func TestIsRepository(t *testing.T) {
	t.Parallel()

	t.Run("Git Directory Exists", func(t *testing.T) {
		t.Parallel()
		tmpDir := t.TempDir()
		err := os.Mkdir(filepath.Join(tmpDir, ".git"), os.ModePerm)
		require.NoError(t, err)

		got := IsRepository(tmpDir)
		assert.True(t, got)
	})

	t.Run("Git Directory Does Not Exist", func(t *testing.T) {
		t.Parallel()
		tmpDir := t.TempDir()

		got := IsRepository(tmpDir)
		assert.False(t, got)
	})
}
```

## File: internal/scaffold/notice.go
```go
package scaffold

import (
	"fmt"
	"path/filepath"
)

// WebKitNotice is the notice outputted to all generated
// files within WebKit.
const WebKitNotice = "Code generated by webkit; DO NOT EDIT."

var commentMap = map[string]string{
	".go":           "//",
	".yaml":         "#",
	".yml":          "#",
	".editorconfig": "#",
	".toml":         "#",
	".js":           "//",
	".html":         "<!-- %s -->",
	".md":           "<!-- %s -->",
}

// noticeForFile prepends a file-type-appropriate “do not edit”
// header to generated files dependent on the file type.
func noticeForFile(path string) string {
	ext := filepath.Ext(path)
	comment := commentMap[ext]
	if comment == "" {
		comment = "#" // fallback
	}

	noticeText := WebKitNotice

	// handle HTML-style comments
	if comment == "<!-- %s -->" {
		return fmt.Sprintf(comment, noticeText) + "\n"
	}

	return fmt.Sprintf("%s %s\n", comment, noticeText)
}
```

## File: internal/appdef/commands_test.go
```go
package appdef

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestCommandSpecUnmarshalJSON(t *testing.T) {
	t.Parallel()

	tt := map[string]struct {
		input   []byte
		want    CommandSpec
		wantErr bool
	}{
		"Bool True": {
			input: []byte(`true`),
			want:  CommandSpec{Disabled: false},
		},
		"Bool False": {
			input: []byte(`false`),
			want:  CommandSpec{Disabled: true},
		},
		"String Override": {
			input: []byte(`"custom command"`),
			want:  CommandSpec{Cmd: "custom command"},
		},
		"Full Object": {
			input: []byte(`{"command":"run tests","skip_ci":true,"timeout":"5m"}`),
			want:  CommandSpec{Cmd: "run tests", SkipCI: true, Timeout: "5m"},
		},
		"Invalid JSON": {
			input:   []byte(`{"invalid":`),
			wantErr: true,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			t.Parallel()

			var got CommandSpec
			err := got.UnmarshalJSON(test.input)

			assert.Equal(t, test.want, got)
			assert.Equal(t, test.wantErr, err != nil)
		})
	}
}

func TestCommand_String(t *testing.T) {
	t.Parallel()

	got := CommandLint.String()
	assert.Equal(t, "lint", got)
	assert.IsType(t, "", got)
}
```

## File: internal/cmd/internal/cmdtools/input.go
```go
package cmdtools

import (
	"context"
	"os"

	"github.com/spf13/afero"
	"github.com/urfave/cli/v3"

	"github.com/ainsleydev/webkit/internal/appdef"
	"github.com/ainsleydev/webkit/internal/secrets/sops"
	"github.com/ainsleydev/webkit/pkg/env"
)

// RunCommand is the signature for command handlers. Each command
// should implement this function signature to run.
type RunCommand func(ctx context.Context, input CommandInput) error

// CommandInput provides dependencies and context to command handlers.
type CommandInput struct {
	FS          afero.Fs
	Command     *cli.Command
	AppDefCache *appdef.Definition
	BaseDir     string
	SOPS        *sops.Client
}

// Wrap wraps a RunCommand to work with urfave/cli.
func Wrap(command RunCommand) cli.ActionFunc {
	return func(ctx context.Context, c *cli.Command) error {
		fs := afero.NewOsFs()
		dir := "./"

		if os.Getenv("APP_ENV") == env.Development {
			// Let's temporarily use playground so we don't override any shit.
			path := "./internal/playground"
			fs = afero.NewBasePathFs(afero.NewOsFs(), path)
			dir = path
		}

		input := CommandInput{
			Command: c,
			FS:      fs,
			BaseDir: dir,
		}
		return command(ctx, input)
	}
}

// AppDef retrieves the main app manifest from the root
// of the project. Exits without it.
func (c *CommandInput) AppDef() *appdef.Definition {
	if c.AppDefCache != nil {
		return c.AppDefCache
	}

	read, err := appdef.Read(c.FS)
	if err != nil {
		Exit(err)
	}
	c.AppDefCache = read

	return read
}
```

## File: internal/cmd/drift.go
```go
package cmd

import (
	"bytes"
	"context"
	"fmt"
	goFs "io/fs"

	"github.com/pmezard/go-difflib/difflib"
	"github.com/spf13/afero"
	"github.com/urfave/cli/v3"

	"github.com/ainsleydev/webkit/internal/cmd/internal/cmdtools"
)

var driftCmd = &cli.Command{
	Name:        "drift",
	Description: "Detect file drift caused by outdated WebKit templates",
	Action:      cmdtools.Wrap(driftDetection),
}

func driftDetection(ctx context.Context, input cmdtools.CommandInput) error {
	fs := input.FS

	// Capture all of the files and their contents so we have
	// something to compare it too.
	before := map[string][]byte{}
	err := afero.Walk(fs, ".", func(path string, info goFs.FileInfo, err error) error {
		if err != nil || info.IsDir() {
			return nil
		}
		b, _ := afero.ReadFile(fs, path)
		before[path] = b
		return nil
	})
	if err != nil {
		return fmt.Errorf("snapshot failed: %w", err)
	}

	// Run update so we can see if the user has made any changes
	// to the root templates.
	if err = update(ctx, input); err != nil {
		return fmt.Errorf("update failed: %w", err)
	}

	// Check if anything has changed after we've updated.
	var driftFound bool
	_ = afero.Walk(fs, ".", func(path string, info goFs.FileInfo, err error) error {
		if err != nil || info.IsDir() {
			return nil
		}
		after, _ := afero.ReadFile(fs, path)
		beforeBytes, ok := before[path]
		if !ok {
			fmt.Printf("🆕 New file: %s\n", path)
			driftFound = true
			return nil
		}

		if !bytes.Equal(beforeBytes, after) {
			driftFound = true
			//printDiff(path, beforeBytes, after) // 👈 replaces cmp.Diff
			fmt.Println("-------")
			printUnifiedDiff(path, beforeBytes, after)
			//fmt.Printf("\n🔍 Diff for %s:\n%s\n", filepath.Clean(path), cmp.Diff(string(beforeBytes), string(after)))
		}
		return nil
	})

	if driftFound {
		fmt.Println("⚠️  Drift detected! Run `webkit update` and commit changes if correct.")
		return fmt.Errorf("drift detected")
	}

	fmt.Println("✅ No drift detected — files are up to date.")
	return nil
}

//func printDiff(path string, before, after []byte) {
//	dmp := diffmatchpatch.New()
//	diffs := dmp.DiffMain(string(before), string(after), false)
//	fmt.Printf("\n🔍 %s\n%s\n", filepath.Clean(path), dmp.(diffs))
//}

func printUnifiedDiff(path string, before, after []byte) {
	diff := difflib.UnifiedDiff{
		A:        difflib.SplitLines(string(before)),
		B:        difflib.SplitLines(string(after)),
		FromFile: path + " (before)",
		ToFile:   path + " (after)",
		Context:  3,
	}
	text, _ := difflib.GetUnifiedDiffString(diff)
	fmt.Println(text)
}
```

## File: internal/git/clone_test.go
```go
package git

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/ainsleydev/webkit/internal/executil"
)

func TestCloneConfigValidate(t *testing.T) {
	t.Parallel()

	tt := map[string]struct {
		input   CloneConfig
		wantErr bool
	}{
		"Valid Config": {
			input: CloneConfig{
				URL:       "https://github.com/user/repo.git",
				LocalPath: "/tmp/repo",
				Ref:       "main",
				Depth:     0,
			},
			wantErr: false,
		},
		"Missing URL": {
			input: CloneConfig{
				URL:       "",
				LocalPath: "/tmp/repo",
				Ref:       "main",
				Depth:     0,
			},
			wantErr: true,
		},
		"Missing LocalPath": {
			input: CloneConfig{
				URL:       "https://github.com/user/repo.git",
				LocalPath: "",
				Ref:       "main",
				Depth:     0,
			},
			wantErr: true,
		},
		"Missing URL And LocalPath": {
			input: CloneConfig{
				URL:       "",
				LocalPath: "",
				Ref:       "main",
				Depth:     0,
			},
			wantErr: true,
		},
	}

	for name, test := range tt {
		t.Run(name, func(t *testing.T) {
			t.Parallel()
			err := test.input.Validate()
			assert.Equal(t, test.wantErr, err != nil)
		})
	}
}

func TestClone(t *testing.T) {
	t.Parallel()

	t.Run("Successful Clone", func(t *testing.T) {
		t.Parallel()

		client, mock := setupClient(t)
		mock.AddStub("git clone", executil.Result{Output: "cloned!"})

		cfg := CloneConfig{
			URL:       "https://example.com/repo.git",
			LocalPath: "/tmp/repo",
			Ref:       "main",
			Depth:     1,
		}

		err := client.Clone(t.Context(), cfg)
		assert.NoError(t, err)
	})

	t.Run("Validation Error", func(t *testing.T) {
		t.Parallel()

		client, _ := setupClient(t)

		cfg := CloneConfig{
			URL:       "",
			LocalPath: "/tmp/repo",
		}

		err := client.Clone(t.Context(), cfg)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "URL is required")
	})

	t.Run("MkdirAll Failure", func(t *testing.T) {
		t.Parallel()

		client, _ := setupClient(t)
		cfg := CloneConfig{
			URL:       "https://example.com/repo.git",
			LocalPath: "/invalid/\x00path/repo", // Illegal path
		}

		err := client.Clone(t.Context(), cfg)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "creating parent dir")
	})

	t.Run("Runner Error", func(t *testing.T) {
		t.Parallel()

		client, mock := setupClient(t)
		mock.AddStub("git clone", executil.Result{Err: assert.AnError})

		cfg := CloneConfig{
			URL:       "https://example.com/repo.git",
			LocalPath: "/tmp/repo",
		}

		err := client.Clone(t.Context(), cfg)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "git clone failed")
	})

}

func TestCloneOrUpdate(t *testing.T) {
	t.Parallel()

	t.Run("Clone When Repository Does Not Exist", func(t *testing.T) {
		t.Parallel()

		client, mock := setupClient(t)
		localPath := t.TempDir() + "/repo"
		cfg := CloneConfig{
			URL:       "https://example.com/repo.git",
			LocalPath: localPath,
			Ref:       "main",
		}

		mock.AddStub("git clone", executil.Result{Output: "cloned"})

		err := client.CloneOrUpdate(t.Context(), cfg)
		assert.NoError(t, err)
	})

	t.Run("Ref Empty Defaults To Main", func(t *testing.T) {
		t.Parallel()

		client, mock := setupClient(t)
		localPath := t.TempDir() + "/repo"
		touchGitDir(t, localPath)

		mock.AddStub("git fetch", executil.Result{Output: "fetched"})
		mock.AddStub("git reset", executil.Result{Output: "reset"})

		cfg := CloneConfig{
			URL:       "https://example.com/repo.git",
			LocalPath: localPath,
			Ref:       "", // Empty ref
		}

		err := client.CloneOrUpdate(t.Context(), cfg)
		assert.NoError(t, err)
	})

	t.Run("Update When Repository Exists", func(t *testing.T) {
		t.Parallel()

		client, mock := setupClient(t)
		localPath := t.TempDir() + "/repo"
		touchGitDir(t, localPath)

		mock.AddStub("git fetch", executil.Result{Output: "fetched"})
		mock.AddStub("git reset", executil.Result{Output: "reset"})

		cfg := CloneConfig{
			URL:       "https://example.com/repo.git",
			LocalPath: localPath,
			Ref:       "main",
		}

		err := client.CloneOrUpdate(t.Context(), cfg)
		assert.NoError(t, err)
	})

	t.Run("Validation Error", func(t *testing.T) {
		t.Parallel()

		client, _ := setupClient(t)
		localPath := t.TempDir() + "/repo"

		cfg := CloneConfig{
			URL:       "",
			LocalPath: localPath,
		}

		err := client.CloneOrUpdate(t.Context(), cfg)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "URL is required")
	})

	t.Run("Runner Clone Error", func(t *testing.T) {
		t.Parallel()

		client, mock := setupClient(t)
		localPath := t.TempDir() + "/repo"

		cfg := CloneConfig{
			URL:       "https://example.com/repo.git",
			LocalPath: localPath,
			Ref:       "main",
		}

		mock.AddStub("git clone", executil.Result{Err: assert.AnError})

		err := client.CloneOrUpdate(t.Context(), cfg)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "git clone failed")
	})

	t.Run("Runner Update Error", func(t *testing.T) {
		t.Parallel()

		client, mock := setupClient(t)
		localPath := t.TempDir() + "/repo"
		touchGitDir(t, localPath)

		mock.AddStub("git fetch", executil.Result{Err: assert.AnError})

		cfg := CloneConfig{
			URL:       "https://example.com/repo.git",
			LocalPath: localPath,
			Ref:       "main",
		}

		err := client.CloneOrUpdate(t.Context(), cfg)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "git fetch failed")
	})
}

func TestUpdate(t *testing.T) {
	t.Parallel()

	t.Run("Successful Update", func(t *testing.T) {
		t.Parallel()

		client, mock := setupClient(t)
		mock.AddStub("git fetch", executil.Result{Output: "fetched"})
		mock.AddStub("git reset", executil.Result{Output: "reset"})

		repoPath := t.TempDir()
		touchGitDir(t, repoPath)

		err := client.Update(t.Context(), repoPath, "main")
		assert.NoError(t, err)
	})

	t.Run("Not a Git Repository", func(t *testing.T) {
		t.Parallel()

		client, _ := setupClient(t)
		repoPath := t.TempDir()

		err := client.Update(t.Context(), repoPath, "main")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "not a git repository")
	})

	t.Run("Runner Fetch Error", func(t *testing.T) {
		t.Parallel()

		client, mock := setupClient(t)
		mock.AddStub("git fetch", executil.Result{Err: assert.AnError})

		repoPath := t.TempDir()
		touchGitDir(t, repoPath)

		err := client.Update(t.Context(), repoPath, "main")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "git fetch failed")
	})

	t.Run("Runner Reset Error", func(t *testing.T) {
		t.Parallel()

		client, mock := setupClient(t)
		mock.AddStub("git fetch", executil.Result{Output: "fetched"})
		mock.AddStub("git reset", executil.Result{Err: assert.AnError})

		repoPath := t.TempDir()
		touchGitDir(t, repoPath)

		err := client.Update(t.Context(), repoPath, "main")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "git reset failed")
	})
}

func touchGitDir(t *testing.T, path string) {
	t.Helper()
	err := os.MkdirAll(filepath.Join(path, ".git"), 0o755)
	require.NoError(t, err)
}
```

## File: internal/git/clone.go
```go
package git

import (
	"context"
	"fmt"
	"os"
	"path/filepath"

	"github.com/ainsleydev/webkit/internal/executil"
)

// CloneConfig configures repository cloning
type CloneConfig struct {
	URL       string // URL of the git repository.
	Ref       string // Branch, tag, or commit to checkout.
	LocalPath string // LocalPath where to clone the repository
	Depth     int    // Depth for shallow clone (0 = full clone)
}

// Validate config before using it
func (cfg CloneConfig) Validate() error {
	if cfg.URL == "" {
		return fmt.Errorf("URL is required")
	}
	if cfg.LocalPath == "" {
		return fmt.Errorf("LocalPath is required")
	}
	return nil
}

// Clone creates a new local copy of a remote repository.
// Parent directories are created automatically to avoid manual setup.
func (c Client) Clone(ctx context.Context, cfg CloneConfig) error {
	if err := cfg.Validate(); err != nil {
		return err
	}

	// Create parent directory to avoid "no such file or directory" errors
	if err := os.MkdirAll(filepath.Dir(cfg.LocalPath), os.ModePerm); err != nil {
		return fmt.Errorf("creating parent dir: %w", err)
	}

	args := []string{"clone"}

	// Shallow clone reduces download time and disk usage for large repos
	if cfg.Depth > 0 {
		args = append(args, "--depth", fmt.Sprintf("%d", cfg.Depth))
	}

	// Allows cloning specific branches/tags without fetching all refs
	if cfg.Ref != "" {
		args = append(args, "--branch", cfg.Ref)
	}

	args = append(args, cfg.URL, cfg.LocalPath)

	cmd := executil.NewCommand("git", args...)
	_, err := c.Runner.Run(ctx, cmd)
	if err != nil {
		return fmt.Errorf("git clone failed: %w", err)
	}

	return nil
}

// CloneOrUpdate ensures a repository exists and is up to date.
// Useful for idempotent operations where initial state
// is not important.
func (c Client) CloneOrUpdate(ctx context.Context, cfg CloneConfig) error {
	if IsRepository(cfg.LocalPath) {
		ref := cfg.Ref
		if ref == "" {
			// Defaults to main to match conventions.
			ref = "main"
		}
		return c.Update(ctx, cfg.LocalPath, ref)
	}
	return c.Clone(ctx, cfg)
}

// Update synchronizes a local repository with the remote ref.
// Uses reset --hard to discard local changes, ensuring a
// clean state matching remote.
func (c Client) Update(ctx context.Context, repoPath, ref string) error {
	if !IsRepository(repoPath) {
		return fmt.Errorf("not a git repository: %s", repoPath)
	}

	// Fetch updates the remote tracking branch without modifying working directory
	fetchCmd := executil.NewCommand("git", "fetch", "origin", ref)
	fetchCmd.Dir = repoPath
	_, err := c.Runner.Run(ctx, fetchCmd)
	if err != nil {
		return fmt.Errorf("git fetch failed: %w", err)
	}

	// Hard reset discards local changes to ensure consistency with remote
	resetCmd := executil.NewCommand("git", "reset", "--hard", "origin/"+ref)
	resetCmd.Dir = repoPath
	_, err = c.Runner.Run(ctx, resetCmd)
	if err != nil {
		return fmt.Errorf("git reset failed: %w", err)
	}

	return nil
}
```

## File: internal/git/git.go
```go
package git

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"

	"github.com/ainsleydev/webkit/internal/executil"
)

type Client struct {
	Runner executil.Runner
}

// New creates a git client with the provided command runner.
// Validates git is available to fail fast rather than on first operation.
func New(runner executil.Runner) (*Client, error) {
	if !executil.Exists("git") {
		return nil, errors.New("git command not found in $PATH")
	}
	return &Client{Runner: runner}, nil
}

var (
	ErrNotRepository = fmt.Errorf("not a git repository")
	ErrInvalidConfig = fmt.Errorf("invalid configuration")
)

// IsRepository checks for .git directory presence to verify
// repository status.
func IsRepository(path string) bool {
	gitDir := filepath.Join(path, ".git")
	_, err := os.Stat(gitDir)
	return err == nil
}
```

## File: internal/testutil/schema.go
```go
package testutil

import (
	"encoding/json"
	"errors"
	"fmt"
	"testing"

	"github.com/goccy/go-yaml"
	"github.com/kaptinlin/jsonschema"
	"github.com/stretchr/testify/require"
)

// SchemaValidator wraps a compiled JSON Schema for validation.
type SchemaValidator struct {
	schema *jsonschema.Schema
}

// SchemaFromURL fetches a JSON Schema from the given URL and compiles it.
func SchemaFromURL(t *testing.T, url string) (*SchemaValidator, error) {
	t.Helper()

	compiler := jsonschema.NewCompiler()
	schema, err := compiler.GetSchema(url)
	require.NoError(t, err)

	return &SchemaValidator{schema: schema}, nil
}

// SchemaFromBytes compiles a JSON Schema from a byte slice.
func SchemaFromBytes(t *testing.T, data []byte) (*SchemaValidator, error) {
	t.Helper()

	compiler := jsonschema.NewCompiler()
	schema, err := compiler.Compile(data)
	require.NoError(t, err)

	return &SchemaValidator{schema: schema}, nil
}

// ValidateYAML validates YAML bytes against the schema.
func (v *SchemaValidator) ValidateYAML(yamlData []byte) error {
	jsonData, err := yaml.YAMLToJSON(yamlData)
	if err != nil {
		return fmt.Errorf("failed to convert YAML to JSON: %w", err)
	}
	return v.ValidateJSON(jsonData)
}

// ValidateJSON validates JSON bytes against the schema.
func (v *SchemaValidator) ValidateJSON(jsonData []byte) error {
	return handleResult(v.schema.ValidateJSON(jsonData))
}

// ValidateMap validates a map against the schema.
func (v *SchemaValidator) ValidateMap(data map[string]any) error {
	return handleResult(v.schema.ValidateMap(data))
}

// Validate validates any data against the schema.
func (v *SchemaValidator) Validate(data any) error {
	return handleResult(v.schema.Validate(data))
}

func handleResult(result *jsonschema.EvaluationResult) error {
	if result.IsValid() {
		return nil
	}

	// Only get errors if actually invalid
	details := result.GetDetailedErrors()
	if len(details) > 0 {
		indent, _ := json.MarshalIndent(details, "", "  ")
		return fmt.Errorf("schema validation failed:\n%s", indent)
	}

	return errors.New("schema is invalid")
}
```

## File: internal/appdef/apps.go
```go
package appdef

import (
	"fmt"
	"path/filepath"
)

type (
	App struct {
		Name        string                  `json:"name"`
		Title       string                  `json:"title"`
		Type        AppType                 `json:"type"`
		Description string                  `json:"description,omitempty"`
		Path        string                  `json:"path"`
		Build       Build                   `json:"build"`
		Infra       Infra                   `json:"infra"`
		Env         Environment             `json:"env"`
		Domains     []Domain                `json:"domains,omitempty"`
		Commands    map[Command]CommandSpec `json:"Commands,omitempty" jsonschema:"oneof_type=boolean;object;string"`
	}
	Build struct {
		Dockerfile string `json:"dockerfile"`
	}
	Infra struct {
		Provider string         `json:"provider"`
		Type     string         `json:"type"`
		Config   map[string]any `json:"config"`
	}
	Domain struct {
		Name     string `json:"name"`
		Type     string `json:"type"`
		Zone     string `json:"zone,omitempty"`
		Wildcard bool   `json:"wildcard,omitempty"`
	}
)

// AppType defines the type of application being run.
type AppType string

// AppType constants.
const (
	AppTypeSvelteKit AppType = "svelte-kit"
	AppTypeGoLang    AppType = "golang"
	AppTypePayload   AppType = "payload"
)

// String implements fmt.Stringer on the AppType.
func (a AppType) String() string {
	return string(a)
}

var appTypeToLanguages = map[AppType]string{
	AppTypeGoLang:    "go",
	AppTypeSvelteKit: "js",
	AppTypePayload:   "js",
}

// Language determines what language ecosystem a given app is.
// Either "go" or "js".
func (a *App) Language() string {
	return appTypeToLanguages[a.Type]
}

// DomainType defines the type of domain that should be provisioned.
type DomainType string

// DomainType constants.
const (
	DomainTypePrimary   DomainType = "primary"
	DomainTypeAlias     DomainType = "alias"
	DomainTypeUnmanaged DomainType = "unmanaged"
)

// String implements fmt.Stringer on the DomainType.
func (d DomainType) String() string {
	return string(d)
}

// OrderedCommands returns the app's commands in canonical order
// with Name populated.
func (a *App) OrderedCommands() []CommandSpec {
	var ordered []CommandSpec

	for _, cmd := range Commands {
		spec, exists := a.Commands[cmd]
		if !exists {
			// Should not happen because applyDefaults populates them
			continue
		}
		spec.Name = cmd.String() // Populate name for templates.
		ordered = append(ordered, spec)
	}

	return ordered
}

func (a *App) applyDefaults() error {
	if a.Commands == nil {
		a.Commands = make(map[Command]CommandSpec)
	}

	// Get default Commands for this app type
	defaults, hasDefaults := defaultCommands[a.Type]
	if !hasDefaults {
		return fmt.Errorf("no default Commands defined for app type %q", a.Type)
	}

	for _, cmd := range Commands {
		// Skip if user has explicitly configured this command.
		if _, exists := a.Commands[cmd]; exists {
			continue
		}

		// Apply default command if available.
		if defaultCmd, ok := defaults[cmd]; ok {
			a.Commands[cmd] = CommandSpec{
				Cmd: defaultCmd,
			}
		}
	}

	if a.Build.Dockerfile == "" {
		a.Build.Dockerfile = "Dockerfile"
	}

	if a.Path != "" {
		a.Path = filepath.Clean(a.Path)
	}

	return nil
}
```

## File: internal/appdef/commands.go
```go
package appdef

import (
	"encoding/json"
	"fmt"

	"github.com/swaggest/jsonschema-go"
)

// CommandSpec defines an action for an App, this can run in
// CI or locally.
type CommandSpec struct {
	Name     string `json:"-"`
	Cmd      string `json:"command,omitempty"`
	SkipCI   bool   `json:"skip_ci,omitempty"`
	Timeout  string `json:"timeout,omitempty"`
	Disabled bool   `json:"-"` // Set during unmarshal
}

// Ensure CommandSpec implements jsonschema.OneOfExposer
var _ jsonschema.OneOfExposer = &CommandSpec{}

// JSONSchemaOneOf returns the polymorphic schema options.
func (*CommandSpec) JSONSchemaOneOf() []interface{} {
	return []interface{}{
		true,          // boolean option
		"",            // string option
		CommandSpec{}, // object option
	}
}

// Command defines the type of action that will be actioned.
type Command string

// Command constants.
const (
	CommandLint   Command = "lint"
	CommandTest   Command = "test"
	CommandFormat Command = "format"
	CommandBuild  Command = "build"
)

// Commands defines all the Commands available that should be
// run in order.
var Commands = []Command{
	CommandFormat,
	CommandLint,
	CommandTest,
	CommandBuild,
}

// defaultCommands defines the default actions for each
// application type. If not overridden, these Commands
// will be used.
var defaultCommands = map[AppType]map[Command]string{
	AppTypePayload: {
		CommandFormat: "pnpm format",
		CommandLint:   "pnpm lint",
		CommandTest:   "pnpm test",
		CommandBuild:  "pnpm build",
	},
	AppTypeSvelteKit: {
		CommandFormat: "pnpm format",
		CommandLint:   "pnpm lint",
		CommandTest:   "pnpm test",

		CommandBuild: "pnpm build",
	},
	AppTypeGoLang: {
		CommandFormat: "gofmt -w .",
		CommandLint:   "golangci-lint run",
		CommandTest:   "go test ./...",
		CommandBuild:  "go build main.go",
	},
}

// UnmarshalJSON implements json.Unmarshaler to
func (c *CommandSpec) UnmarshalJSON(data []byte) error {
	// Try bool (false = disabled)
	var b bool
	if err := json.Unmarshal(data, &b); err == nil {
		c.Disabled = !b
		return nil
	}

	// Try string (override)
	var str string
	if err := json.Unmarshal(data, &str); err == nil {
		c.Cmd = str
		return nil
	}

	// Try object (full control)
	type Alias CommandSpec
	var aux Alias
	if err := json.Unmarshal(data, &aux); err != nil {
		return fmt.Errorf("invalid command format: expected bool, string, or object")
	}

	*c = CommandSpec(aux)
	return nil
}

// String implements fmt.Stringer on Command.
func (c Command) String() string {
	return string(c)
}
```

## File: internal/appdef/env_test.go
```go
package appdef

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestEnvSource_String(t *testing.T) {
	t.Parallel()

	got := EnvSourceValue.String()
	assert.Equal(t, "value", got)
	assert.IsType(t, "", got)
}

func TestEnvironment_Walk(t *testing.T) {
	t.Parallel()

	e := Environment{
		Dev:        EnvVar{"DEBUG": {Value: "true"}},
		Staging:    EnvVar{"DEBUG": {Value: "true"}},
		Production: EnvVar{"DEBUG": {Value: "false"}},
	}

	var got []string
	e.Walk(func(envName string, name string, value EnvValue) {
		got = append(got, envName+":"+name+"="+value.Value)
	})

	want := []string{
		"development:DEBUG=true",
		"staging:DEBUG=true",
		"production:DEBUG=false",
	}

	assert.ElementsMatch(t, want, got)
}
```

## File: internal/appdef/env.go
```go
package appdef

import (
	"github.com/ainsleydev/webkit/pkg/env"
)

type (
	// Environment contains environment-specific variable configurations.
	Environment struct {
		Dev        EnvVar `json:"dev,omitempty"`
		Staging    EnvVar `json:"staging,omitempty"`
		Production EnvVar `json:"production,omitempty"`
	}
	// EnvVar is a map of variable names to their configurations.
	EnvVar map[string]EnvValue
	// EnvValue represents a single environment variable configuration
	EnvValue struct {
		Source EnvSource `json:"source"`          // See below
		Value  string    `json:"value,omitempty"` // Used for "value" and "resource" sources
		Path   string    `json:"path,omitempty"`  // Used for "sops" source (format: "file:key")
	}
)

// EnvSource defines the type of application being run.
type EnvSource string

const (
	// EnvSourceValue is a static string value (default).
	// Example: "https://api.example.com"
	EnvSourceValue EnvSource = "value"

	// EnvSourceResource references a Terraform resource output.
	// Example: "db.connection_url"
	EnvSourceResource EnvSource = "resource"

	// EnvSourceSOPS is an encrypted secret stored in a SOPS file.
	// Example: "secrets/production.yaml:API_KEY"
	EnvSourceSOPS EnvSource = "sops"
)

// String implements fmt.Stringer on the EnvSource.
func (e EnvSource) String() string {
	return string(e)
}

// Walk walks through each non-nil environment (dev, staging, production),
// calling fn(envName, envVars) for each one.
func (e Environment) Walk(fn func(env string, name string, value EnvValue)) {
	if e.Dev != nil {
		for name, val := range e.Dev {
			fn(env.Development, name, val)
		}
	}
	if e.Staging != nil {
		for name, val := range e.Staging {
			fn(env.Staging, name, val)
		}
	}
	if e.Production != nil {
		for name, val := range e.Production {
			fn(env.Production, name, val)
		}
	}
}

// mergeVars merges `override` into `base`, with `override`
// taking precedence (usually app/shared).
func mergeVars(base, override EnvVar) EnvVar {
	if base == nil {
		base = make(EnvVar)
	}
	for k, v := range override {
		base[k] = v
	}
	return base
}
```

## File: internal/cmd/internal/operations/ci_cd.go
```go
package operations

import (
	"context"
	"fmt"

	"github.com/goccy/go-json"
	"github.com/spf13/afero"

	"github.com/ainsleydev/webkit/internal/appdef"
	"github.com/ainsleydev/webkit/internal/cmd/internal/cmdtools"
	"github.com/ainsleydev/webkit/internal/scaffold"
	"github.com/ainsleydev/webkit/internal/templates"
)

// CreateCICD bootstraps all of the GitHub workflows for a
// WebKit application.
func CreateCICD(_ context.Context, input cmdtools.CommandInput) error {
	gen := scaffold.New(afero.NewBasePathFs(input.FS, "./.github"))
	appDef := input.AppDef()

	for _, app := range appDef.Apps {

		tpl := templates.MustLoadTemplate(".github/workflows/pr.yaml.tmpl")
		file := fmt.Sprintf("./workflows/pr-%s.yaml", app.Name)

		if err := gen.Template(file, tpl, &app); err != nil {
			return err
		}
	}

	// TODO: After Terraform
	//for _, resource := range appDef.Resources {
	//	backupEnabled := resource.Backup.Enabled
	//
	//	if resource.Type == appdef.ResourceTypePostgres && backupEnabled {
	//		tpl := templates.MustLoadTemplate(".github/workflows/backup-postgres.yaml.tmpl")
	//		file := fmt.Sprintf("./workflows/resource-backup-%s.yaml", resource.Name)
	//
	//		if err := gen.Template(file, tpl, &resource); err != nil {
	//			return err
	//		}
	//	}
	//}

	// Generate Terraform (temp, scratch)
	//if err := gen.Template(
	//	"./workflows/infra-terraform-plan.yaml",
	//	templates.MustLoadTemplate(".github/workflows/terraform-plan.yaml.tmpl"),
	//	&app,
	//); err != nil {
	//	return err
	//}

	return nil
}

func temp(definition appdef.Definition) (string, error) {
	apps := definition.Apps

	str, err := json.Marshal(apps)
	if err != nil {
		return "", err
	}

	return string(str), nil
}
```

## File: internal/cmd/internal/operations/code_style_test.go
```go
package operations

import (
	"testing"

	"github.com/spf13/afero"
	"github.com/stretchr/testify/assert"

	"github.com/ainsleydev/webkit/internal/appdef"
	"github.com/ainsleydev/webkit/internal/cmd/internal/cmdtools"
	"github.com/ainsleydev/webkit/internal/testutil"
)

func TestCreateCodeStyleFiles(t *testing.T) {
	t.Parallel()

	t.Run("Success", func(t *testing.T) {
		t.Parallel()

		fs := afero.NewMemMapFs()

		got := CreateCodeStyleFiles(t.Context(), cmdtools.CommandInput{
			FS:          fs,
			AppDefCache: &appdef.Definition{},
		})
		assert.NoError(t, got)

		for path, _ := range codeStyleTemplates {
			file, err := afero.ReadFile(fs, path)
			assert.NoError(t, err)
			assert.NotEmpty(t, file)
		}
	})

	t.Run("Error", func(t *testing.T) {
		t.Parallel()

		got := CreateCodeStyleFiles(t.Context(), cmdtools.CommandInput{
			FS:          &testutil.AferoErrCreateFs{Fs: afero.NewMemMapFs()},
			AppDefCache: &appdef.Definition{},
		})
		assert.Error(t, got)
	})
}
```

## File: internal/templates/embed.go
```go
package templates

import (
	"embed"
	"text/template"

	"github.com/Masterminds/sprig/v3"
)

//go:embed *
var embeddedTemplates embed.FS

// LoadTemplate returns a parsed template from embedded FS
func LoadTemplate(name string) (*template.Template, error) {
	content, err := embeddedTemplates.ReadFile(name)
	if err != nil {
		return nil, err
	}

	funcs := sprig.FuncMap()
	funcs["secret"] = secret

	return template.New(name).Funcs(funcs).Parse(string(content))
}

// MustLoadTemplate calls LoadTemplate but panics if the
// template could not be parsed.
func MustLoadTemplate(name string) *template.Template {
	t, err := LoadTemplate(name)
	if err != nil {
		panic(err)
	}
	return t
}
```

## File: internal/cmd/cli.go
```go
package cmd

import (
	"context"
	"fmt"
	"os"

	"github.com/urfave/cli/v3"

	"github.com/ainsleydev/webkit/pkg/log"
)

func Run() {
	cmd := &cli.Command{
		Name:  "webkit",
		Usage: "make an explosive entrance",
		Before: func(ctx context.Context, _ *cli.Command) (context.Context, error) {
			log.Bootstrap("Webkit")
			return ctx, nil
		},
		Commands: []*cli.Command{
			updateCmd,
			scaffoldCmd,
			secretsCmd,
			driftCmd,
			scratchCmd,
		},
	}

	if err := cmd.Run(context.Background(), os.Args); err != nil {
		fmt.Println(err.Error())
	}
}
```

## File: internal/cmd/scratch.go
```go
package cmd

import (
	"context"
	"fmt"
	"path/filepath"

	"github.com/urfave/cli/v3"

	"github.com/ainsleydev/webkit/internal/cmd/internal/cmdtools"
	"github.com/ainsleydev/webkit/internal/cmd/internal/operations/infra"
	"github.com/ainsleydev/webkit/internal/secrets"
	"github.com/ainsleydev/webkit/internal/secrets/age"
	"github.com/ainsleydev/webkit/internal/secrets/sops"
)

var scratchCmd = &cli.Command{
	Name:   "scratch",
	Hidden: true,
	Action: cmdtools.Wrap(func(ctx context.Context, input cmdtools.CommandInput) error {

		prov, err := age.NewProvider()
		if err != nil {
			return err
		}

		client := sops.NewClient(prov)

		path := filepath.Join(input.BaseDir, secrets.FilePath, "production.yaml")
		toMap, err := sops.DecryptFileToMap(client, path)

		fmt.Print(toMap, err)

		return nil

		return infra.Test(ctx, input)
		return nil

		//// Create reflector with custom configuration
		//reflector := &jsonschema.Reflector{
		//	AllowAdditionalProperties: false,
		//	DoNotReference:            false,
		//	ExpandedStruct:            true,
		//}
		//
		//// Generate schema from Definition struct
		//schema := reflector.Reflect(&appdef.Definition{})
		//
		//// Add metadata
		//schema.Title = "WebKit Application Manifest"
		//schema.Description = "Schema for webkit app.json configuration file"
		//schema.Version = "1.0.0"
		//
		//data, err := json.MarshalIndent(schema, "", "  ")
		//if err != nil {
		//	return err
		//}
		//
		//// Write to file
		//return os.WriteFile("schema-test-2.json", data, 0644)

		//input.AppDef()
		//
		//reflector := jsonschema.Reflector{}
		//
		//schema, err := reflector.Reflect(appdef.Definition{})
		//if err != nil {
		//	return err
		//}
		//
		//j, err := json.MarshalIndent(schema, "", " ")
		//if err != nil {
		//	return err
		//}
		//
		//return os.WriteFile("schema-test.json", j, 0600)
	}),
}
```

## File: internal/cmd/scaffold.go
```go
package cmd

import (
	"github.com/urfave/cli/v3"

	"github.com/ainsleydev/webkit/internal/cmd/internal/cmdtools"
	"github.com/ainsleydev/webkit/internal/cmd/internal/operations"
	"github.com/ainsleydev/webkit/internal/cmd/internal/operations/secrets"
)

var scaffoldCmd = &cli.Command{
	Name:        "scaffold",
	Usage:       "Scaffold individual project components",
	Description: "Generate standalone project files without modifying existing generated templates.",
	Commands: []*cli.Command{
		{
			Name:   "code-style",
			Usage:  "Generate code style configuration files",
			Action: cmdtools.Wrap(operations.CreateCodeStyleFiles),
		},
		{
			Name:   "git",
			Usage:  "Generate Git and GitHub configuration files",
			Action: cmdtools.Wrap(operations.CreateGitSettings),
		},
		{
			Name:   "package-json",
			Usage:  "Generate root package.json file",
			Action: cmdtools.Wrap(operations.CreatePackageJson),
		},
		{
			Name:   "cicd",
			Usage:  "Generate GitHub Actions workflow files",
			Action: cmdtools.Wrap(operations.CreateCICD),
		},
		{
			Name:   "secrets",
			Usage:  "Generate empty SOPS secret files and configuration",
			Action: cmdtools.Wrap(secrets.CreateFiles),
		},
	},
}
```

## File: internal/scaffold/generate.go
```go
package scaffold

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"text/template"

	"github.com/spf13/afero"
	"gopkg.in/yaml.v3"
)

type (
	// Generator is used for scaffolding files to a WebKit project.
	Generator interface {
		Bytes(path string, data []byte, opts ...Option) error
		Template(path string, tpl *template.Template, data any, opts ...Option) error
		JSON(path string, content any, opts ...Option) error
		YAML(path string, content any, opts ...Option) error
	}
	// FileGenerator handles file generation on a given filesystem.
	FileGenerator struct {
		fs afero.Fs
	}
)

// New creates a new FileGenerator with the provided afero.Fs.
func New(fs afero.Fs) *FileGenerator {
	return &FileGenerator{fs: fs}
}

// WriteMode determines how files are written
type WriteMode int

const (
	// ModeGenerate always writes the file, overwriting if it exists
	ModeGenerate WriteMode = iota
	// ModeScaffold only writes if the file doesn't exist
	ModeScaffold
)

// Bytes writes bytes to the filesystem and ensure directories exist.
func (f FileGenerator) Bytes(path string, data []byte, opts ...Option) error {
	options := applyOptions(opts...)

	if f.shouldSkipScaffold(path, options.mode) {
		return nil
	}

	if err := f.fs.MkdirAll(filepath.Dir(path), os.ModePerm); err != nil {
		return fmt.Errorf("creating directories: %w", err)
	}

	exists, _ := afero.Exists(f.fs, path)
	if exists {
		fmt.Println("Updated: " + path)
	}

	if err := afero.WriteFile(f.fs, path, data, os.ModePerm); err != nil {
		return fmt.Errorf("writing file %s: %w", path, err)
	}

	if !exists {
		fmt.Println("Created: " + path)
	}

	return nil
}

// Template writes a template file with the given mode.
func (f FileGenerator) Template(path string, tpl *template.Template, data any, opts ...Option) error {
	buf := &bytes.Buffer{}
	buf.WriteString(noticeForFile(path))

	if err := tpl.Execute(buf, data); err != nil {
		return fmt.Errorf("executing template %s: %w", tpl.Name(), err)
	}

	return f.Bytes(path, buf.Bytes(), opts...)
}

// JSON writes JSON content with the given mode.
func (f FileGenerator) JSON(path string, content any, opts ...Option) error {
	buf := &bytes.Buffer{}

	encoder := json.NewEncoder(buf)
	encoder.SetIndent("", "\t")
	if err := encoder.Encode(content); err != nil {
		return fmt.Errorf("encoding %s: %w", path, err)
	}

	return f.Bytes(path, buf.Bytes(), opts...)
}

// YAML writes YAML content with the given mode.
func (f FileGenerator) YAML(path string, content any, opts ...Option) error {
	buf := &bytes.Buffer{}
	buf.WriteString(noticeForFile(path))

	encoder := yaml.NewEncoder(buf)
	encoder.SetIndent(2)
	if err := encoder.Encode(content); err != nil {
		return fmt.Errorf("encoding %s: %w", path, err)
	}

	return f.Bytes(path, buf.Bytes(), opts...)
}

func (f FileGenerator) shouldSkipScaffold(path string, mode WriteMode) bool {
	if mode != ModeScaffold {
		return false
	}

	exists, _ := afero.Exists(f.fs, path) //nolint
	if !exists {
		return false
	}

	fmt.Println("• skipped scaffolding", path, "- already exists")
	return true
}
```

## File: internal/cmd/secrets.go
```go
package cmd

import (
	"fmt"
	"slices"

	"github.com/urfave/cli/v3"

	"github.com/ainsleydev/webkit/internal/cmd/internal/cmdtools"
	"github.com/ainsleydev/webkit/internal/cmd/internal/operations/secrets"
	"github.com/ainsleydev/webkit/pkg/env"
)

var secretsCmd = &cli.Command{
	Name:        "secrets",
	Usage:       "Manage SOPS-encrypted secret files",
	Description: "Commands for working with secret files defined in app.json",
	Commands: []*cli.Command{
		{
			Name:        "sync",
			Usage:       "Sync secret placeholders from app.json",
			Description: "Reads app.json and adds placeholder entries for all secrets with source: 'sops'",
			Action:      cmdtools.Wrap(secrets.Sync),
		},
		{
			Name:        "validate",
			Usage:       "Validate that all secrets from app.json exist in secret files",
			Description: "Ensures every secret referenced in app.json has a corresponding entry in SOPS files",
			Flags: []cli.Flag{
				&cli.BoolFlag{
					Name:    "check-orphans",
					Usage:   "Report keys in SOPS files not referenced in app.json",
					Aliases: []string{"o"},
				},
				&cli.BoolFlag{
					Name:    "allow-encrypted",
					Usage:   "Attempt to validate encrypted files (requires SOPS/age access)",
					Aliases: []string{"e"},
				},
			},
			Action: cmdtools.Wrap(secrets.Validate),
		},
		{
			Name:        "encrypt",
			Usage:       "Encrypt secret files with SOPS",
			Description: "Encrypts all plaintext secret files in the secrets/ directory using SOPS and age.",
			Action:      cmdtools.Wrap(secrets.EncryptFiles),
		},
		{
			Name:        "decrypt",
			Usage:       "Decrypt secret files with SOPS",
			Description: "Decrypts all encrypted secret files in the secrets/ directory using SOPS and age.",
			Action:      cmdtools.Wrap(secrets.DecryptFiles),
		},
		{
			Name:        "get",
			Usage:       "Retrieve a secret from a specific environment",
			Description: "Fetches the value of a secret from the chosen environment (development, staging, production)",
			Flags: []cli.Flag{
				&cli.StringFlag{
					Name:     "env",
					Usage:    "Environment to fetch the secret from (development, staging, production)",
					Aliases:  []string{"e"},
					Required: true,
					Validator: func(s string) error {
						if !slices.Contains(env.All, s) {
							return fmt.Errorf("invalid environment: %s", s)
						}
						return nil
					},
				},
				&cli.StringFlag{
					Name:     "key",
					Usage:    "The key/name of the secret to retrieve",
					Aliases:  []string{"k"},
					Required: true,
				},
			},
			Action: cmdtools.Wrap(secrets.Get),
		},
	},
}
```

## File: internal/cmd/update.go
```go
package cmd

import (
	"context"

	"github.com/urfave/cli/v3"

	"github.com/ainsleydev/webkit/internal/cmd/internal/cmdtools"
	"github.com/ainsleydev/webkit/internal/cmd/internal/operations"
)

var updateCmd = &cli.Command{
	Name:        "update",
	Usage:       "Update project dependencies from app.json",
	Description: "Rebuilds all generated files based on current app.json configuration",
	Action:      cmdtools.Wrap(update),
}

var updateOps = []cmdtools.RunCommand{
	operations.CreateCodeStyleFiles,
	operations.CreateGitSettings,
	operations.CreatePackageJson,
	operations.CreateCICD,
}

func update(ctx context.Context, input cmdtools.CommandInput) error {
	for _, op := range updateOps {
		err := op(ctx, input)
		if err != nil {
			return err
		}
	}
	return nil
}
```

## File: internal/appdef/definition.go
```go
package appdef

import (
	"errors"
	"fmt"
	"io"

	"github.com/goccy/go-json"
	"github.com/spf13/afero"
)

const (
	// JsonFileName defines the file name of the app manifest,
	// that should appear in the root of each webkit dir.
	JsonFileName = "app.json"
)

type (
	Definition struct {
		WebkitVersion string     `json:"webkit_version"`
		Project       Project    `json:"project"`
		Shared        Shared     `json:"shared"`
		Resources     []Resource `json:"resources"`
		Apps          []App      `json:"apps"`
	}
	Project struct {
		Name        string `json:"name" jsonschema:"required,pattern=^[a-z0-9-]+$,title=Project Name,description=Machine-readable project name (kebab-case),example=my-website"`
		Title       string `json:"title" jsonschema:"required,title=Project Title,description=Human-readable project title,example=My Website"`
		Description string `json:"description" jsonschema:"required,title=Description,description=Brief description of the project"`
		Repo        string `json:"repo" jsonschema:"required,format=uri,title=Repository,description=Git repository URL,example=git@github.com:ainsley/my-website.git"`
	}
	Shared struct {
		Env Environment `json:"env"`
	}
)

func Read(root afero.Fs) (*Definition, error) {
	file, err := root.Open(JsonFileName)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	data, err := io.ReadAll(file)
	if err != nil {
		return nil, err
	}

	// TODO: Apply defaults and return validation errors if the user has fucked it.
	def := &Definition{}
	if err := json.Unmarshal(data, def); err != nil {
		return nil, errors.New("unmarshalling app definition: " + err.Error())
	}

	if err = def.ApplyDefaults(); err != nil {
		return nil, err
	}

	return def, nil
}

// GithubLabels returns the labels that will appear on the
// GitHub repository by looking at the application types.
func (d *Definition) GithubLabels() []string {
	labels := []string{"webkit"}

	for _, v := range d.Apps {
		labels = append(labels, v.Type.String())
	}

	return labels
}

// ApplyDefaults ensures all required defaults are set on the Definition.
// This should be called after unmarshaling and before validation.
func (d *Definition) ApplyDefaults() error {
	for i := range d.Apps {
		if err := d.Apps[i].applyDefaults(); err != nil {
			return fmt.Errorf("applying defaults to app %q: %w", d.Apps[i].Name, err)
		}
	}

	for i := range d.Resources {
		if err := d.Resources[i].applyDefaults(); err != nil {
			return fmt.Errorf("applying defaults to resource %q: %w", d.Resources[i].Name, err)
		}
	}

	return nil
}

/**** Env *****/

// MergeAllEnvironments merges shared environment variables with all apps' environments.
// App-specific values take precedence over shared ones. If multiple apps define the same variable,
// the last app in the list wins.
func (d *Definition) MergeAllEnvironments() Environment {
	merged := d.mergeEnvironments(d.Shared.Env)

	for _, app := range d.Apps {
		merged = d.mergeEnvironments(merged, app.Env)
	}

	return merged
}

// MergeAppEnvironment merges shared environment variables with a single app's environment.
// The app's variables take precedence over the shared ones.
func (d *Definition) MergeAppEnvironment(appName string) (Environment, bool) {
	var app *App
	for i := range d.Apps {
		if d.Apps[i].Name == appName {
			app = &d.Apps[i]
			break
		}
	}

	if app == nil {
		return Environment{}, false
	}

	return d.mergeEnvironments(d.Shared.Env, app.Env), true
}

// mergeEnvironments merges multiple Environment structs left-to-right.
// Later environments override earlier ones.
func (d *Definition) mergeEnvironments(envs ...Environment) Environment {
	merged := Environment{
		Dev:        make(EnvVar),
		Staging:    make(EnvVar),
		Production: make(EnvVar),
	}

	for _, env := range envs {
		merged.Dev = mergeVars(merged.Dev, env.Dev)
		merged.Staging = mergeVars(merged.Staging, env.Staging)
		merged.Production = mergeVars(merged.Production, env.Production)
	}

	return merged
}
```
