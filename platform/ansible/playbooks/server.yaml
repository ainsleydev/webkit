- name: Deploy server with Docker and Nginx (Ansible-native)
  hosts: all
  become: true
  vars:
    # All variables below are required and should be passed via -e flags
    # domain: from app.PrimaryDomain
    # github_user: repository owner
    # docker_image: repo-name-app-name (e.g., my-repo-cms)
    # docker_image_tag: 'sha-abc123'
    # docker_port: from app.Build.Port
    # app_name: from app.Name
    # env_name: environment name (development, staging, production)
    # age_secret_key: AGE private key for SOPS decryption
    # enable_https: from app.Infra.Config.https (defaults to true)
    # admin_email: from app.Infra.Config.admin_email (defaults to hello@ainsley.dev)
    # Path where env file will be generated
    env_file_path: '/opt/{{ app_name }}/.env'
    # Configuration directory for webkit (must match role default)
    webkit_config_dir: '/etc/webkit'

  # TODO (BUG):
  # If the server updates it's packages then reboots,
  # nginx will display a 502 whilst it updates Docker Swam again.
  pre_tasks:
    - name: Update apt package cache
      apt:
        update_cache: yes
        cache_valid_time: 3600

    - name: Upgrade all packages
      apt:
        upgrade: dist
      register: upgrade_result

    - name: Ensure python3-pip is installed
      apt:
        name: python3-pip
        state: present

    - name: Reboot if kernel updated
      reboot:
        msg: 'Reboot initiated by Ansible due to package upgrade'
        reboot_timeout: 600
      when:
        - upgrade_result.changed
        - skip_reboot is not defined or not skip_reboot

  roles:
    - fail2ban
    - tools
    - digitalocean-metrics
    - docker
    - sops
    - webkit
    - nginx
    - ufw

  tasks:
    - name: Login to GitHub Container Registry
      community.docker.docker_login:
        registry_url: ghcr.io
        username: '{{ github_user }}'
        password: '{{ github_token }}'

    - name: Ensure Docker Swarm is initialized
      community.docker.docker_swarm:
        state: present
        advertise_addr: '{{ ansible_default_ipv4.address }}'

    - name: Create app directory for env file
      file:
        path: '/opt/{{ app_name }}'
        state: directory
        mode: '0755'

    - name: Check if app.json exists in webkit config
      stat:
        path: '{{ webkit_config_dir }}/app.json'
      register: app_json_stat

    - name: Display app.json status
      debug:
        msg: 'app.json exists: {{ app_json_stat.stat.exists }}, path: {{ webkit_config_dir }}/app.json'

    - name: Check if secrets directory exists
      stat:
        path: '{{ webkit_config_dir }}/resources/secrets'
      register: secrets_dir_stat

    - name: Display secrets directory status
      debug:
        msg: 'Secrets directory exists: {{ secrets_dir_stat.stat.exists }}, path: {{ webkit_config_dir }}/resources/secrets'

    - name: Remove old env file for sanity
      file:
        path: '{{ env_file_path }}'
        state: absent

    - name: Copy pre-generated env file from CI/CD to VM
      copy:
        src: '{{ env_file_source_path }}'
        dest: '{{ env_file_path }}'
        mode: '0600'
      when: env_file_source_path is defined

    - name: Generate production env file using webkit
      command: >
        /usr/local/bin/webkit env generate
        --app {{ app_name }}
        --environment {{ env_name }}
        --output {{ env_file_path }}
      args:
        chdir: /etc/webkit
      environment:
        SOPS_AGE_KEY: '{{ age_secret_key }}'
      register: env_generate_result
      failed_when: false
      ignore_errors: yes
      no_log: true
      when: env_file_source_path is not defined

    - name: Display env generation error if command failed
      debug:
        msg: 'ERROR generating env file: {{ env_generate_result.stderr }}'
      when:
        - env_file_source_path is not defined
        - env_generate_result.rc != 0

    - name: Fail if env generation failed
      fail:
        msg: 'webkit env generate failed with exit code {{ env_generate_result.rc }}'
      when:
        - env_file_source_path is not defined
        - env_generate_result.rc != 0

    - name: Verify env file was created
      stat:
        path: '{{ env_file_path }}'
      register: env_file_stat

    - name: Fail if env file doesn't exist
      fail:
        msg: 'Environment file was not created at {{ env_file_path }}. Check that app.json and secrets exist in /etc/webkit or that env_file_source_path was provided'
      when: not env_file_stat.stat.exists

    - name: Ensure NODE_ENV is set in env file
      lineinfile:
        path: '{{ env_file_path }}'
        regexp: '^NODE_ENV='
        line: 'NODE_ENV={{ env_name }}'
        create: no
      when: env_name is defined

    - name: Debug image tag
      debug:
        msg: 'Deploying image: ghcr.io/{{ github_user }}/{{ docker_image }}:{{ docker_image_tag }}'

    - name: Deploy/update Docker Swarm service
      community.docker.docker_swarm_service:
        name: '{{ docker_image }}'
        image: 'ghcr.io/{{ github_user }}/{{ docker_image }}:{{ docker_image_tag }}'
        networks:
          - name: host
        env_files:
          - '{{ env_file_path }}'
        mode: replicated
        replicas: 1
        force_update: true # Force update even if no changes require it.
        update_config:
          parallelism: 1
          delay: 10s
          failure_action: rollback
        restart_config:
          condition: on-failure
          delay: 5s
          max_attempts: 3
        publish:
          - target_port: '{{ docker_port | int }}'
            published_port: '{{ docker_port | int }}'
            protocol: tcp
            mode: host
      no_log: true  # Prevent logging of environment variables containing secrets

    - name: Wait for the app to respond on localhost
      block:
        - name: Check if app is responding
          uri:
            url: 'http://localhost:{{ docker_port }}{{ health_check_path | default("/") }}'
            method: GET
            status_code: 200
          register: curl_result
          retries: 60
          delay: 5
          until: curl_result.status == 200

      rescue:
        - name: Capture Docker service logs on failure
          command: docker service logs {{ docker_image }} --tail 100
          register: service_logs
          ignore_errors: yes

        - name: Display Docker service logs
          debug:
            msg: |
              Application failed to start after 5 minutes.
              Docker service logs (last 100 lines):
              {{ service_logs.stdout }}
              {{ service_logs.stderr }}

        - name: Fail deployment with clear error message
          fail:
            msg: |
              Deployment failed: Application did not respond on http://localhost:{{ docker_port }}{{ health_check_path | default("/") }} after 5 minutes.
              This usually indicates:
              - Application crashed during startup
              - Missing or incorrect environment variables
              - Port {{ docker_port }} is not being bound by the application
              - Application is binding to 127.0.0.1 instead of 0.0.0.0
              - Health check path {{ health_check_path | default("/") }} is incorrect or not responding

              Check the Docker service logs above for details.

    - name: Run Certbot to get HTTPS certificate
      include_role:
        name: certbot
      when: enable_https | default(true) | bool

    - name: Deploy SSL Nginx configuration after certificates are obtained
      include_role:
        name: nginx
      vars:
        skip_install: true
      when: enable_https | default(true) | bool
