# WebKit Infrastructure Implementation Plan

## Overview

This document outlines the complete implementation strategy for WebKit's infrastructure provisioning
system. The approach generates Terraform configurations and GitHub Actions workflows from`app.json`,
enabling infrastructure-as-code without requiring the WebKit CLI during CI/CD execution.

## Core Philosophy

**Generate Once, Execute Many Times**

- `webkit update` generates GitHub Actions workflows with embedded Terraform data
- CI/CD clones the webkit infrastructure repository and runs Terraform
- Projects **do not contain** an `infra/` folder - keeps codebases clean
- Changes to `app.json` require re-running `webkit update` to regenerate workflows
- All infrastructure state is managed by Terraform in a central state backend

---

## Architecture

### Data Flow

```
app.json
   ↓
webkit update
   ↓
Generates:
   ├── .github/workflows/terraform-plan.yml (with tfvars embedded)
   └── .github/workflows/terraform-apply.yml (with tfvars embedded)
   ↓
GitHub Actions triggers on PR/merge
   ↓
Workflow clones webkit/infra repository
   ↓
Writes tfvars from embedded workflow data
   ↓
Terraform plan/apply (no WebKit CLI needed)
   ↓
Infrastructure provisioned
```

### Repository Structure

#### Project Repository (Clean)

```
my-website/
├── app.json                          # Source of truth
├── .github/
│   └── workflows/
│       ├── terraform-plan.yml        # Generated by webkit
│       └── terraform-apply.yml       # Generated by webkit
├── apps/                             # Application code
│   └── web/
├── services/                         # Service code
│   └── cms/
└── secrets/                          # SOPS encrypted secrets
    ├── cms.yaml
    └── shared.yaml
```

#### WebKit Infrastructure Repository (Centralized)

```
webkit-infra/                         # Separate repository
├── providers/                        # Provider-specific modules
│   ├── digitalocean/
│   │   ├── droplet/
│   │   │   ├── main.tf
│   │   │   ├── variables.tf
│   │   │   └── outputs.tf
│   │   ├── app/
│   │   ├── postgres/
│   │   └── spaces/
│   └── backblaze/
│       └── bucket/
├── modules/                          # Orchestration modules
│   ├── apps/
│   │   ├── main.tf                  # Routes apps to providers
│   │   ├── variables.tf
│   │   └── outputs.tf
│   └── resources/
│       ├── main.tf                  # Routes resources to providers
│       ├── variables.tf
│       └── outputs.tf
├── main.tf                           # Root orchestration
├── providers.tf                      # Provider configurations
├── backend.tf                        # State backend config
├── variables.tf                      # Variable definitions
├── outputs.tf                        # Root outputs
└── README.md                         # Documentation
```

---

## Implementation Details

### 1. WebKit CLI Generation Command

#### Command: `webkit update`

**What it does:**

1. Reads `app.json` from project root
2. Validates manifest schema
3. Transforms manifest data into Terraform-compatible JSON structure
4. Generates two GitHub Actions workflows with **embedded tfvars data**
5. Workflows reference the centralized webkit-infra repository
6. Adds generation timestamp and webkit version to files

**Example Usage:**

```bash
# In project root
webkit update

# Output:
# ✓ Validated app.json schema
# ✓ Generated .github/workflows/terraform-plan.yml
# ✓ Generated .github/workflows/terraform-apply.yml
# ℹ Commit these files to trigger infrastructure changes
# ℹ Infrastructure code will be cloned from: github.com/webkit/infra
```

**Key Points:**

- No local `infra/` folder needed in projects
- Workflows contain all project-specific data
- Terraform modules are centralized and versioned
- Projects stay clean and focused on application code

---

### 2. Generated GitHub Actions Workflows

#### Workflow 1: `terraform-plan.yml`

**Triggers:** Pull requests to main/staging branches

**Key Steps:**

1. Checkout project repository
2. Clone webkit-infra repository at specific version
3. Write embedded tfvars to infra directory
4. Initialize Terraform with remote backend
5. Run `terraform plan` and capture output
6. Upload plan artifact
7. Post formatted plan diff as PR comment

**Critical Elements:**

```yaml
name: Terraform Plan

on:
	pull_request:
		branches: [ main, staging ]
		paths:
			- 'app.json'
			- '.github/workflows/terraform-plan.yml'

env:
	WEBKIT_INFRA_VERSION: 'v1.2.3'  # Generated by webkit
	WEBKIT_INFRA_REPO: 'https://github.com/webkit/infra.git'

jobs:
	plan:
		name: Plan Infrastructure Changes
		runs-on: ubuntu-latest

		steps:
			-   name: Checkout Project
				uses: actions/checkout@v4

			-   name: Clone WebKit Infrastructure
				run: |
					git clone --depth 1 --branch ${{ env.WEBKIT_INFRA_VERSION }} \
					  ${{ env.WEBKIT_INFRA_REPO }} /tmp/webkit-infra

			-   name: Write Project Configuration
				working-directory: /tmp/webkit-infra
				run: |
					# Embedded JSON generated from app.json
					cat > project.auto.tfvars.json << 'EOF'
					{
					  "project_name": "my-website",
					  "webkit_version": "0.1.0",
					  "apps": [...],
					  "resources": [...]
					}
					EOF

			-   name: Terraform Init
				working-directory: /tmp/webkit-infra
				run: |
					terraform init \
					  -backend-config="key=projects/${{ env.PROJECT_NAME }}/terraform.tfstate"

			-   name: Terraform Plan
				working-directory: /tmp/webkit-infra
				run: terraform plan -out=tfplan

			-   name: Comment Plan on PR
				uses: ./.github/actions/terraform-comment
```

**Why This Works:**

- Project repo has no infra code bloat
- Infra modules are versioned and reusable across all webkit projects
- Each project gets isolated Terraform state
- Easy to update infra modules centrally

#### Workflow 2: `terraform-apply.yml`

**Triggers:** Push to main/staging branches

**Key Steps:**

1. Checkout project repository
2. Clone webkit-infra repository
3. Write embedded tfvars
4. Download plan artifact from PR (if available)
5. Apply Terraform changes
6. Output deployment summary

**Critical Elements:**

```yaml
name: Terraform Apply

on:
	push:
		branches: [ main, staging ]
		paths:
			- 'app.json'
			- '.github/workflows/terraform-apply.yml'

jobs:
	apply:
		name: Apply Infrastructure Changes
		runs-on: ubuntu-latest
		environment: production  # Requires manual approval

		steps:
			-   name: Checkout Project
				uses: actions/checkout@v4

			-   name: Clone WebKit Infrastructure
				run: |
					git clone --depth 1 --branch ${{ env.WEBKIT_INFRA_VERSION }} \
					  ${{ env.WEBKIT_INFRA_REPO }} /tmp/webkit-infra

			-   name: Write Project Configuration
				working-directory: /tmp/webkit-infra
				run: |
					cat > project.auto.tfvars.json << 'EOF'
					{
					  "project_name": "my-website",
					  "apps": [...],
					  "resources": [...]
					}
					EOF

			-   name: Download Plan Artifact
				uses: actions/download-artifact@v4
				continue-on-error: true

			-   name: Terraform Apply
				working-directory: /tmp/webkit-infra
				run: |
					if [ -f tfplan ]; then
					  terraform apply tfplan
					else
					  terraform apply -auto-approve
					fi
```

---

### 3. Terraform Variable Transformation

The transformation from `app.json` to Terraform variables is the core of the system.

#### Input: `app.json`

```json
{
	"project": {
		"name": "my-website"
	},
	"resources": [
		{
			"name": "db",
			"type": "postgres",
			"provider": "digitalocean",
			"config": {
				"size": "db-s-1vcpu-1gb",
				"engine_version": "17",
				"region": "nyc3"
			}
		}
	],
	"apps": [
		{
			"name": "cms",
			"type": "payload",
			"path": "services/cms",
			"infra": {
				"provider": "digitalocean",
				"type": "vm",
				"config": {
					"size": "s-2vcpu-4gb",
					"region": "nyc3"
				}
			},
			"env": {
				"production": [
					{
						"key": "DATABASE_URL",
						"type": "from_resource",
						"from": "resource:db:connection_url"
					}
				]
			}
		}
	]
}
```

#### Output: `project.auto.tfvars.json` (Embedded in Workflow)

```json
{
	"project_name": "my-website",
	"webkit_version": "0.1.0",
	"resources": [
		{
			"name": "db",
			"type": "postgres",
			"provider": "digitalocean",
			"config": {
				"size": "db-s-1vcpu-1gb",
				"engine_version": "17",
				"region": "nyc3"
			},
			"outputs": [
				"connection_url",
				"host",
				"port"
			]
		}
	],
	"apps": [
		{
			"name": "cms",
			"type": "payload",
			"provider": "digitalocean",
			"infrastructure_type": "vm",
			"path": "services/cms",
			"config": {
				"size": "s-2vcpu-4gb",
				"region": "nyc3"
			},
			"environment_variables": {
				"production": [
					{
						"key": "DATABASE_URL",
						"value_type": "resource_reference",
						"value": "db.connection_url"
					}
				]
			}
		}
	]
}
```

**Transformation Rules:**

1. **Flatten Structure**: Move nested `infra` config to top level
2. **Normalize Types**: Convert `infra.type` to `infrastructure_type`
3. **Reference Resolution**: Transform `resource:db:connection_url` to `db.connection_url`
4. **Environment Separation**: Group env vars by environment (dev/staging/production)
5. **Provider Validation**: Ensure provider + type combinations are supported

---

### 4. Centralized Terraform Structure

The webkit-infra repository contains all reusable Terraform code.

#### `main.tf` (Root Orchestrator)

**Purpose:** Coordinates resource and app provisioning

```hcl
# Route to resource provisioning module
module "resources" {
	source = "./modules/resources"

	project_name = var.project_name
	resources = var.resources

	# Provider credentials from GitHub secrets
	digitalocean_token = var.digitalocean_token
}

# Route to app provisioning module
module "apps" {
	source = "./modules/apps"

	project_name     = var.project_name
	apps             = var.apps
	resource_outputs = module.resources.outputs

	depends_on = [module.resources]
}
```

**Key Points:**

- Apps depend on resources (databases created before apps)
- Resource outputs passed to apps for environment variables
- Clean separation of concerns

#### `modules/resources/main.tf` (Resource Router)

**Purpose:** Routes resources to correct provider modules based on type

```hcl
locals {
	# Group resources by provider and type
	digitalocean_postgres = {
		for r in var.resources : r.name => r
		if r.provider == "digitalocean" && r.type == "postgres"
	}

	digitalocean_spaces = {
		for r in var.resources : r.name => r
		if r.provider == "digitalocean" && r.type == "s3"
	}
}

# Provision each postgres database
module "digitalocean_postgres" {
	source   = "../../providers/digitalocean/postgres"
	for_each = local.digitalocean_postgres

	name       = "${var.project_name}-${each.key}"
	size       = each.value.config.size
	pg_version = each.value.config.engine_version
	region     = each.value.config.region
}

# Provision each spaces bucket
module "digitalocean_spaces" {
	source   = "../../providers/digitalocean/spaces"
	for_each = local.digitalocean_spaces

	name   = "${var.project_name}-${each.key}"
	region = each.value.config.region
	acl    = each.value.config.acl
}
```

**Pattern:**

1. Group resources by provider/type using locals
2. Use `for_each` to create multiple instances
3. Pass config directly from tfvars
4. Prefix resources with project name for isolation

#### `modules/apps/main.tf` (App Router)

**Purpose:** Routes apps to correct provider modules and injects environment variables

```hcl
locals {
	digitalocean_vms = {
		for a in var.apps : a.name => a
		if a.provider == "digitalocean" && a.infrastructure_type == "vm"
	}

	digitalocean_app_platform = {
		for a in var.apps : a.name => a
		if a.provider == "digitalocean" && a.infrastructure_type == "app"
	}
}

# Provision VMs (Droplets)
module "digitalocean_droplets" {
	source   = "../../providers/digitalocean/droplet"
	for_each = local.digitalocean_vms

	name           = "${var.project_name}-${each.key}"
	droplet_size   = each.value.config.size
	droplet_region = each.value.config.region
}

# Provision App Platform services
module "digitalocean_apps" {
	source   = "../../providers/digitalocean/app"
	for_each = local.digitalocean_app_platform

	name = "${var.project_name}-${each.key}"

	# Transform environment variables with resource references
	envs = [
		for env in each.value.environment_variables.production : {
			key   = env.key
			value = env.value_type == "resource_reference"
				? var.resource_outputs[split(".", env.value)[0]][split(".", env.value)[1]]
				: env.value
		}
	]
}
```

**Key Features:**

- Resolves resource references (e.g., `db.connection_url` → actual value)
- Handles multiple infrastructure types per provider
- Passes environment variables with proper secret handling

#### `providers/digitalocean/postgres/main.tf` (Leaf Module)

**Purpose:** Actual resource provisioning - already exists in ss-infra.txt

```hcl
resource "digitalocean_database_cluster" "this" {
	name       = var.name
	engine     = "pg"
	version    = var.pg_version
	size       = var.size
	region     = var.region
	node_count = var.node_count
}

# Database, users, connection pools, firewall rules...
```

**No Changes Needed:** Existing modules work as-is

---

### 5. State Management

#### Backend Configuration

**Location:** `webkit-infra/backend.tf`

```hcl
terraform {
	backend "s3" {
		bucket                      = "webkit-terraform-state"
		key                         = "projects/PROJECT_NAME/terraform.tfstate"
		region                      = "us-west-000"
		endpoint                    = "https://s3.us-west-000.backblazeb2.com"
		skip_credentials_validation = true
		skip_metadata_api_check     = true
	}
}
```

**Key Points:**

- Each project gets isolated state file by project name
- State stored in Backblaze B2 (cost-effective)
- State key uses pattern: `projects/{project_name}/terraform.tfstate`
- Credentials passed via workflow secrets

**Initialization in Workflow:**

```yaml
-   name: Terraform Init
	run: |
		terraform init \
		  -backend-config="access_key=${{ secrets.B2_ACCESS_KEY }}" \
		  -backend-config="secret_key=${{ secrets.B2_SECRET_KEY }}" \
		  -backend-config="key=projects/${{ env.PROJECT_NAME }}/terraform.tfstate"
```

---

### 6. Environment Variable Handling

#### Three Types of Environment Variables

1. **Static Values** - Plain strings
2. **Resource References** - Output from provisioned resources
3. **Secrets** - From SOPS or GitHub Secrets

#### Example in `app.json`:

```json
{
	"env": {
		"production": [
			{
				"key": "PUBLIC_API_URL",
				"type": "value",
				"value": "https://api.mysite.com"
			},
			{
				"key": "DATABASE_URL",
				"type": "from_resource",
				"from": "resource:db:connection_url"
			},
			{
				"key": "PAYLOAD_SECRET",
				"type": "secret",
				"from": "sops:secrets/cms.yaml:/PAYLOAD_SECRET"
			}
		]
	}
}
```

#### Transformed for Terraform:

```json
{
	"environment_variables": {
		"production": [
			{
				"key": "PUBLIC_API_URL",
				"value_type": "static",
				"value": "https://api.mysite.com"
			},
			{
				"key": "DATABASE_URL",
				"value_type": "resource_reference",
				"value": "db.connection_url"
			},
			{
				"key": "PAYLOAD_SECRET",
				"value_type": "github_secret",
				"value": "PAYLOAD_SECRET"
			}
		]
	}
}
```

#### Resolution in Terraform:

```hcl
envs = [
	for env in each.value.environment_variables.production : {
		key   = env.key
		value = (
			env.value_type == "resource_reference"
			? var.resource_outputs[split(".", env.value)[0]][split(".", env.value)[1]]
			: env.value_type == "github_secret"
			? var.github_secrets[env.value]
			: env.value
		)
		type = env.value_type == "github_secret" ? "SECRET" : "GENERAL"
	}
]
```

**SOPS Integration:**

- SOPS files decrypted in CI before Terraform runs
- Secrets loaded as Terraform variables
- Never stored in plain text

---

### 7. Testing Strategy

#### Unit Tests (Go)

**Purpose:** Test transformation logic

```go
func TestTransformManifestToTfvars(t *testing.T) {
// Given
manifest := &appdef.Definition{
Project: appdef.Project{Name: "test-project"},
Apps: []appdef.App{{
Name: "cms",
Infra: appdef.Infra{
Provider: "digitalocean",
Type: "vm",
},
}},
}

// When
tfvars := infra.TransformManifest(manifest)

// Then
assert.Equal(t, "test-project", tfvars.ProjectName)
assert.Equal(t, "cms", tfvars.Apps[0].Name)
assert.Equal(t, "vm", tfvars.Apps[0].InfrastructureType)
}
```

**Coverage Areas:**

- app.json validation
- Transformation correctness
- Environment variable resolution
- Resource reference parsing
- Workflow template rendering

#### Integration Tests (Terraform)

**Purpose:** Test actual infrastructure provisioning

```go
// Using Terratest
func TestDigitalOceanPostgres(t *testing.T) {
tfOptions := &terraform.Options{
TerraformDir: "../webkit-infra",
VarFiles: []string{"test-fixtures/simple-project.tfvars.json"},
}

defer terraform.Destroy(t, tfOptions)

terraform.InitAndApply(t, tfOptions)

// Verify outputs
dbUrl := terraform.Output(t, tfOptions, "db_connection_url")
assert.NotEmpty(t, dbUrl)
}
```

**Test Fixtures:**

- Minimal project configurations
- Various provider combinations
- Edge cases (no resources, multiple apps, etc.)

#### Local Development Testing

**Setup:**

```bash
# 1. Clone webkit-infra locally
git clone https://github.com/webkit/infra.git ~/webkit-infra

# 2. Generate tfvars from playground
cd playground
webkit update --local-infra ~/webkit-infra

# 3. Test terraform locally
cd ~/webkit-infra
terraform plan
```

**Benefits:**

- Test infra changes before committing
- Fast feedback loop
- No CI cost during development

#### End-to-End Testing

**Strategy:**

1. Create test project with `app.json`
2. Run `webkit update`
3. Commit generated workflows
4. Open PR and verify plan output
5. Merge and verify apply succeeds
6. Validate provisioned resources
7. Clean up with `terraform destroy`

---

### 8. Reusable GitHub Actions Components

#### Composite Action: `terraform-comment`

**Location:** `.github/actions/terraform-comment/action.yml`

**Purpose:** Format and post Terraform plan to PR

**Features:**

- Include graphical representation of changes in PR comments:
	- Count of resources added/changed/destroyed
	- Risk scoring based on number/type of changes
	- Collapsible diffs with emojis for visual clarity
- Updates existing comment instead of creating new ones
- Links to documentation

**Usage:**

```yaml
-   name: Comment Plan
	uses: ./.github/actions/terraform-comment
	with:
		plan-file: plan_output.txt
		github-token: ${{ secrets.GITHUB_TOKEN }}
```

#### Composite Action: `clone-webkit-infra`

**Purpose:** Standardize infra repository cloning

```yaml
inputs:
	version:
		description: 'WebKit infra version to clone'
		required: true
	destination:
		description: 'Where to clone the repo'
		default: '/tmp/webkit-infra'

runs:
	using: 'composite'
	steps:
		-   name: Clone Infrastructure
			shell: bash
			run: |
				git clone --depth 1 \
				  --branch ${{ inputs.version }} \
				  https://github.com/webkit/infra.git \
				  ${{ inputs.destination }}
```
---

### 9. Workflow Versioning and Updates

#### Version Pinning

**In Generated Workflows:**

```yaml
env:
	WEBKIT_INFRA_VERSION: 'v1.2.3'  # Generated by webkit CLI
```

**Why:**

- Reproducible infrastructure changes
- Safe rollbacks
- Gradual migration to new infra versions

#### Updating Infra Version

**Process:**

1. Update webkit CLI version
2. Run `webkit update` to regenerate workflows
3. New workflows reference updated infra version
4. Test in PR before merging

**Migration Path:**

```bash
# Current state
WEBKIT_INFRA_VERSION: 'v1.0.0'

# Update webkit CLI
brew upgrade webkit

# Regenerate workflows
webkit update
# Output: Updated to infra v1.2.0

# Commit and test
git add .github/workflows/
git commit -m "Update webkit infra to v1.2.0"
```

---

### 10. Security Considerations

#### Secrets Management

**GitHub Secrets (Per Project):**

- `DIGITALOCEAN_TOKEN`
- `DO_SPACES_ACCESS_KEY`
- `DO_SPACES_SECRET_KEY`
- `B2_ACCESS_KEY`
- `B2_SECRET_KEY`
- Application-specific secrets (e.g., `PAYLOAD_SECRET`)

**SOPS Encrypted Files:**

- Stored in project repo: `secrets/*.yaml`
- Decrypted in CI using age or PGP
- Never committed in plain text

**Workflow Security:**

```yaml
jobs:
	apply:
		environment: production  # Requires manual approval
		permissions:
			contents: read  # Minimal permissions
```

#### State File Security

**Best Practices:**

- State backend uses encryption at rest
- Access keys rotated regularly
- State file contains sensitive data (marked as sensitive in outputs)
- No state files committed to git

---

### 11. Error Handling and Rollback

#### Plan Failures

**Scenario:** Terraform plan fails in PR

**Workflow Behavior:**

1. Post error message to PR comment
2. Mark check as failed
3. Prevent merge until resolved

**Developer Action:**

- Fix `app.json`
- Run `webkit update`
- Push changes
- Plan re-runs automatically

#### Apply Failures

**Scenario:** Terraform apply fails after merge

**Workflow Behavior:**

1. Terraform partial state saved
2. Notification sent (Slack/email)
3. Manual intervention required

**Recovery Options:**

1. Fix issue and re-run workflow
2. Revert PR and re-apply previous state
3. Manual terraform commands in emergency

#### Rollback Strategy

**Option 1: Git Revert**

```bash
# Revert the merge commit
git revert HEAD
git push

# Triggers new apply with previous config
```

**Option 2: Manual State Manipulation**

```bash
# Clone infra repo
git clone https://github.com/webkit/infra.git

# Init with project state
terraform init -backend-config="key=projects/my-website/terraform.tfstate"

# Import or remove resources manually
terraform import ...
```

---

### 12. Monitoring and Observability

#### Deployment Tracking

**Terraform Outputs:**

```hcl
output "deployment_summary" {
	value = {
		project = var.project_name
		timestamp = timestamp()
		apps_count = length(module.apps.outputs)
		resources_count = length(module.resources.outputs)
	}
}
```

**Posted to:**

- PR comments (for plans)
- Slack notifications (for applies)
- Deployment tracking system

#### Infrastructure Drift Detection

**Scheduled Workflow:** `terraform-drift-check.yml`

```yaml
on:
	schedule:
		-   cron: '0 0 * * *'  # Daily

jobs:
	drift:
		steps:
			-   name: Terraform Plan (Drift Check)
				run: terraform plan -detailed-exitcode

			-   name: Notify on Drift
				if: failure()
				run: |
					# Post to Slack that drift detected
```

---

### 13. CLI Command Reference

#### `webkit update`

**Generates:** GitHub Actions workflows and local tfvars

```bash
webkit update # Standard generation
```

- Generates workflows and tfvars based on app.json
- Does not apply infrastructure
- Keeps project repositories clean

#### `webkit infra validate`

**Purpose:** Validate app.json before generating workflows

#### `webkit infra validate`

**Purpose:** Validate app.json before generating workflows

```bash
webkit infra validate
# Output:
# ✓ Schema valid
# ✓ All resource references resolve
# ✓ Provider/type combinations supported
# ✗ Missing required config: apps[0].infra.config.region
```

#### `webkit infra plan`

**Purpose:** Plan infrastructure changes locally without CI/CD

```bash
webkit infra plan --environment production
# Clones infra repo
# Generates tfvars
# Runs terraform plan locally
```

**Options:**

- `--local-infra [path]` →  Use local infra repo instead of remote (for testing)
- `--dry-run` → Generate `tfvars` and render workflows locally, no cloud API calls
- `--infra-version <v>` → Pin specific infra repo version

---

## Ansible / VM Provisioning

**Current Status**:

- Ansible will still be required, but only for VMs.
- Cloud-init will handle the rest.
- Timeline: Ansible integration comes after core infra is running.

---

## Implementation Checklist

- [ ] Create webkit-infra repository
- [ ] Port existing provider modules
- [ ] Create orchestration modules (apps/resources)
- [ ] Define root Terraform files
- [ ] Build transformation logic in webkit CLI
- [ ] Create workflow templates
- [ ] Implement GitHub Actions helpers
- [ ] Write unit tests
- [ ] Write integration tests
- [ ] Document for end users
- [ ] Create example projects

---

## Questions to Resolve

1. **Infra Repo Ownership**
	- Who maintains webkit-infra repository?
	- Public or private?
	- Contribution process?

2. **Provider Support**
	- Start with DigitalOcean + Backblaze
	- Add AWS/GCP later?
	- Plugin system for custom providers?

3. **State Backend**
	- Use Backblaze B2 for all projects?
	- Option to use Terraform Cloud?
	- Self-hosted option?

4. **SOPS vs GitHub Secrets**
	- When to use each?
	- Can we unify?

5. **Ansible Integration**
	- Still needed for VMs?
	- Generate Ansible playbooks too?
	- Or move to cloud-init only?

---

*This plan provides a comprehensive foundation for implementing WebKit's infrastructure system. Next
steps: prioritize implementation phases and begin building.*


```pgsql
             +----------------+
             |   app.json     |  <- Source of truth
             +----------------+
                     |
                     v
             +----------------+
             | webkit update  |  <- Generates GitHub workflows
             +----------------+
                     |
                     v
  +------------------------------------------+
  | .github/workflows/terraform-*.yml       |
  | - terraform-plan.yml                     |
  | - terraform-apply.yml                    |
  +------------------------------------------+
                     |
                     v
             +----------------+
             | GitHub Actions |  <- CI/CD triggers
             +----------------+
                     |
          -----------------------
          |                     |
          v                     v
+----------------+       +--------------------+
| Clone webkit-  |       | Load secrets via   |
| infra repo     |       | SOPS / GitHub      |
+----------------+       +--------------------+
          |                     |
          -----------------------
                     |
                     v
            +-------------------+
            | Terraform Modules |
            | - Apps Router     |
            | - Resources Router|
            | - Provider Modules|
            +-------------------+
                     |
                     v
             +----------------+
             | Provisioned    |
             | Infrastructure |
             +----------------+
```
