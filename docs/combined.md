This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2025-10-01T16:26:01.716Z

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Info

For more information about Repopack, visit: https://github.com/yamadashy/repopack

# Repository Structure
```
cli/
  temp.md
implementation/
  build-and-deploy.md
  terraform.md
manifest/
  apps.md
  environment-variables.md
  overview.md
  project.md
  resources.md
  versioning.md
index.md
intro.md
notes.md
WhitePaper.md
```

# Repository Files

## File: cli/temp.md
```markdown
## CLI Design

Below defines the primary commands for webkit. They will never be destructive by default and users are not allowed to
overwrite webkit changes with commands like `--force`.

- `webkit init` — Interactive creation of app.json.
- `webkit new [path]` — Scaffold new project from templates.
- `webkit update` — Refresh generated files; safe and idempotent by default.
- `webkit validate` — Validate app.json against schema.
- `webkit generate` — Generate files from templates.
- `webkit encrypt` & `webkit decrypt` — Manage secrets via SOPS`
- `webkit infra plan|apply` — Optional infra provisioning hooks (TBC)

## Templates and Generated Files

WebKit ships with a set of templates to generate standardised project files. This makes it easier for engineers to focus
on business problems instead of editor configuration, linting and formatting standards.

- Static files (like .editorconfig) can be copied directly.
- Templated files (like GitHub workflows) use Go’s text/template engine + Sprig helpers (only if needed).

**Files WebKit should generate:**

- `.editorconfig`
- `.prettierrc`
- `.prettierignore`
- `.dockerignore`
- `.github/workflows/*`
- `.github/dependabot`
- `.github/settings.yml` (repo config)
- `README.md`
```

## File: implementation/build-and-deploy.md
```markdown
# Build Process

## Image Building

All Docker images are built in GitHub Actions CI. WebKit generates
workflows that:

1. Build on push to main/staging branches
2. Tag images with git commit SHA: `ghcr.io/{org}/{app}:{git-sha}`
3. Push to GitHub Container Registry
4. Deploy to configured infrastructure

### Image Naming Convention

**Format:** `ghcr.io/{project.name}/{app.name}:{tag}`

**Example:**
- Project: `my-website`
- App: `cms`
- Commit: `abc123f`
- **Result:** `ghcr.io/my-website/cms:abc123f`

### Monorepo Build Context

For monorepos, the build context is the app's `path`:
```json
{
  "name": "cms",
  "path": "services/cms"  // Docker build context
}
```

## File: implementation/terraform.md
```markdown
# Terraform

Introduction and details needed.

## State Management

WebKit uses Backblaze B2 for Terraform state storage.

### Initial Setup

Before running `webkit infra apply`, configure your state backend:
```bash
webkit init --configure-state
```

## File: manifest/apps.md
```markdown
# Apps

An app, refers to a service that will exist both locally and in the cloud, this is the backbone of the application.
Every app defines a Dockerfile so it can be ran in many different environments.

## Attributes

| Key           | Description                                         | Required | Notes                                       |
|---------------|-----------------------------------------------------|----------|---------------------------------------------|
| `name`        | App machine-readable name                           | Yes      | kebab-case                                  |
| `type`        | The type of app                                     | Yes      | Supported: `payload`, `sveltekit`, `go`     |
| `description` | Description of the app                              | No       |                                             |
| `path`        | The relative path of where the application resides  | Yes      |                                             |
| `build`       | Instructions for compilation                        | No       |                                             |
| `infra`       | Infrastructure and provisioning details for the app | Yes      |                                             |
| `env`         | Per-environment variables                           | No       | [Ref](/manifest/environment-variables.html) |

## Example

```json
{
    "apps": [
        {
            "name": "cms",
            "type": "payload",
            "description": "Payload CMS for managing content.",
            "path": "services/cms",
            "build": {
                "dockerfile": "Dockerfile"
            },
            "infra": {
                "provider": "digitalocean",
                "type": "vm",
                "config": {
                    "size": "s-2vcpu-4gb",
                    "region": "ams3",
                    "domain": "cms.my-website.com",
                    "ssh_keys": [
                        "your-ssh-key-id"
                    ]
                }
            },
            "env": {
                "dev": [
                    {
                        "key": "DATABASE_URL",
                        "type": "from_resource",
                        "from": "resource:db:connection_url"
                    },
                    {
                        "key": "PAYLOAD_SECRET",
                        "type": "secret",
                        "from": "sops:secrets/cms.yaml:/PAYLOAD_SECRET"
                    }
                ],
                "staging": [
                    {
                        "key": "DATABASE_URL",
                        "type": "from_resource",
                        "from": "resource:db:connection_url"
                    }
                ],
                "production": [
                    {
                        "key": "DATABASE_URL",
                        "type": "from_resource",
                        "from": "resource:db:connection_url"
                    },
                    {
                        "key": "PAYLOAD_SECRET",
                        "type": "secret",
                        "from": "github-secrets:PAYLOAD_SECRET"
                    }
                ]
            },
            "depends_on": [
                "db"
            ]
        },
        {
            "name": "web",
            "type": "sveltekit",
            "path": "apps/web",
            "build": {
                "dockerfile": "Dockerfile"
            },
            "infra": {
                "provider": "digitalocean",
                "type": "app",
                "config": {
                    "region": "fra1",
                    "domain": "www.my-website.com",
                    "instance_count": 2,
                    "env_from_shared": true
                }
            },
            "env": {
                "dev": [
                    {
                        "key": "PUBLIC_API_URL",
                        "type": "value",
                        "value": "http://localhost:3000"
                    }
                ],
                "production": [
                    {
                        "key": "PUBLIC_API_URL",
                        "type": "value",
                        "value": "https://api.my-website.com"
                    },
                    {
                        "key": "ASSETS_BUCKET",
                        "type": "from_resource",
                        "from": "resource:object-store:bucket"
                    }
                ]
            }
        }
    ]
}
```

## Infrastructure

The `infrastructure` block defines how the application will be provisioned in cloud environments. It is similar to the
resources block but focuses on the runtime environment, compute instances, and cloud provider configurations required to
deploy the app.

### Attributes

| Key           | Description                                                  | Required | Notes                           |
|---------------|--------------------------------------------------------------|----------|---------------------------------|
| `type`        | Type of infrastructure or deployment unit                    | Yes      | Supported values below          |
| `provider`    | Cloud provider where the infrastructure is provisioned       | Yes      | Supported: `digitalocean`, `b2` |
| `config`      | Terraform input configuration based on the type and provider | Yes      |                                 |
| `description` | Description of the resource                                  | No       |                                 |

### Types

WebKit uses generic type names. The CLI maps these to provider-specific resources automatically.

| Type         | Description                | DigitalOcean | 
|--------------|----------------------------|--------------|
| `vm`         | Virtual machine            | Droplet      | 
| `container`  | Managed container platform | App Platform |
| `serverless` | Function-as-a-service      | Functions    |

### Depends On

Controls startup order in local development (Docker Compose). In production, Terraform automatically handles
provisioning order through environment variable references. You don't need to explicitly declare
dependencies—referencing a resource's output creates the dependency.

**When to use:**
Only needed if your app requires a dependency for local development that isn't referenced in environment variables.

### Example

```json
{
    "infra": {
        "provider": "digitalocean",
        "type": "vm",
        "config": {
            "size": "s-2vcpu-4gb",
            "region": "ams3",
            "domain": "cms.my-website.com",
            "ssh_keys": [
                "your-ssh-key-id"
            ]
        }
    }
}
```

## Build

The `build` block defines how each app app is compiled and packaged. All apps must include a `Dockerfile` in their root
path. It's assumed that every app will define its own Dockerfile so it can be executed and ran on cloud environments.
Dockerfile paths can be overridden with the `dockerfile` key.

Arguments can be passed in to each dockerfile using the `args` parameter as a key value pair.

### Example

```json
{
    "build": {
        "dockerfile": "Dockerfile.custom",
        "args": {
            "NODE_VERSION": "20",
            "BUILD_ENV": "production"
        }
    }
}
```

### Attributes

| Key          | Description                     | Required | Default      | Notes |
|--------------|---------------------------------|----------|--------------|-------|
| `dockerfile` | Custom Dockerfile name          | No       | `Dockerfile` |       |
| `args`       | Build-time arguments for Docker | No       | `{}`         |       |

### Notes

- Every app must have a `Dockerfile` at `{app.path}/Dockerfile`
- Build args are passed to Docker with `--build-arg`
- For advanced Docker features (multi-stage builds, BuildKit), modify your Dockerfile directly.
```

## File: manifest/environment-variables.md
```markdown
# Environment Variables

Variables can either be defined within the `shared` section of the app manifest, or defined per service.

Variables can be configured for these environments:

- `dev`
- `staging`
- `production`

## Canonical object form (recommended)

Each entry is a small object with a `key`, a `source` object that describes where the value comes from, and optional metadata such as `sensitive`.

Supported `source.type` values:
- `value` — literal value (local or public value)
- `resource` — an output from a defined resource in the manifest
- `sops` — a secret stored in a SOPS-encrypted file

## Example:

```json
{
    "env": {
        "production": [
            {
                "key": "DATABASE_URL",
                "type": "resource",
                "resource": "db-primary",
                "output": "connection_url",
                "sensitive": true
            },
            {
                "key": "REDIS_HOST",
                "type": "resource",
                "resource": "cache",
                "output": "host"
            },
            {
                "key": "S3_BUCKET",
                "source": { "type": "resource", "name": "object-store", "output": "bucket_name" }
            },
            {
                "key": "PAYLOAD_SECRET",
                "type": "sops",
                "file": "secrets/prod.yaml",
                "path": "PAYLOAD_SECRET",
                "sensitive": true
            },
            {
                "key": "PUBLIC_API_URL",
                "type": "value",
                "value": "https://api.my-website.com"
            }
        ]
    }
}
```

OR

```json
{
    "env": {
        "production": {
            "DATABASE_URL": { "type": "resource", "resource": "db-primary", "output": "connection_url", "sensitive": true },
            "REDIS_HOST": { "type": "resource", "resource": "cache", "output": "host" },
            "PAYLOAD_SECRET": { "type": "sops", "file": "secrets/prod.yaml", "path": "PAYLOAD_SECRET" },
            "PUBLIC_API_URL": { "type": "value", "value": "https://api.my-website.com" }
        }
    }
}
```
```

## File: manifest/overview.md
```markdown
# The Manifest (`app.json`)

The manifest is the single source of truth. All generated code, infrastructure and configuration derive from this
document. Every project should define an `app.json` file within its root directory, even if it doesn't have any apps.
This will in turn, help with managing the formatting of files and templates.

## Description

- **Format**: JSON, validated against a published JSON Schema.
- **Schema Reference**: `$schema` points to a remote or versioned schema definition.
- **Versioning**: A webkit_version field is automatically added to the schema during CLI generation. When running webkit
  update, the tool will update this version to match the installed CLI version, ensuring consistency between your
  manifest and the WebKit tooling. This allows the CLI to detect version drift and apply necessary migrations or warn
  about incompatible changes.

## Example

Below is an example of a fully fledged `app.json` manifest.

```json
{
    "$schema": "https://raw.githubusercontent.com/ainsley/webkit-schema/v1.0.0/schema.json",
    "webkit_version": "0.1.0",
    "project": {
        "name": "my-website",
        "title": "My Website",
        "description": "My website is a bespoke sales platform for developers and designers.",
        "repo": "git@github.com:ainsley/my-website.git"
    },
    "shared": {
        "env": {
            "dev": [
                {
                    "key": "FRONTEND_URL",
                    "type": "value",
                    "value": "http://localhost:3000"
                }
            ],
            "staging": [
                {
                    "key": "FRONTEND_URL",
                    "type": "value",
                    "value": "https://staging.my-website.com"
                }
            ],
            "production": [
                {
                    "key": "SENTRY_DSN",
                    "type": "secret",
                    "from": "sops:secrets/shared.yaml:/SENTRY_DSN"
                },
                {
                    "key": "FRONTEND_URL",
                    "type": "value",
                    "value": "https://my-website.com"
                }
            ]
        }
    },
    "resources": [
        {
            "name": "db",
            "type": "postgres",
            "provider": "digitalocean",
            "config": {
                "size": "db-s-1vcpu-1gb",
                "engine_version": "17",
                "region": "ams3"
            },
            "outputs": [
                "connection_url",
                "host",
                "port",
                "database"
            ]
        },
        {
            "name": "store",
            "type": "s3",
            "provider": "digitalocean",
            "config": {
                "region": "ams3",
                "acl": "public-read"
            },
            "outputs": [
                "bucket_name",
                "endpoint",
                "region"
            ]
        }
    ],
    "apps": [
        {
            "name": "cms",
            "type": "payload",
            "description": "Payload CMS for managing content.",
            "path": "services/cms",
            "build": {
                "dockerfile": "Dockerfile"
            },
            "infra": {
                "provider": "digitalocean",
                "type": "vm",
                "config": {
                    "size": "s-2vcpu-4gb",
                    "region": "ams3",
                    "domain": "cms.my-website.com",
                    "ssh_keys": [
                        "your-ssh-key-id"
                    ]
                }
            },
            "env": {
                "dev": [
                    {
                        "key": "DATABASE_URL",
                        "type": "from_resource",
                        "from": "resource:db:connection_url"
                    },
                    {
                        "key": "PAYLOAD_SECRET",
                        "type": "secret",
                        "from": "sops:secrets/cms.yaml:/PAYLOAD_SECRET"
                    }
                ],
                "staging": [
                    {
                        "key": "DATABASE_URL",
                        "type": "from_resource",
                        "from": "resource:db:connection_url"
                    }
                ],
                "production": [
                    {
                        "key": "DATABASE_URL",
                        "type": "from_resource",
                        "from": "resource:db:connection_url"
                    },
                    {
                        "key": "PAYLOAD_SECRET",
                        "type": "secret",
                        "from": "github-secrets:PAYLOAD_SECRET"
                    }
                ]
            },
            "depends_on": [
                "db"
            ]
        },
        {
            "name": "web",
            "type": "sveltekit",
            "path": "apps/web",
            "build": {
                "dockerfile": "Dockerfile"
            },
            "infra": {
                "provider": "digitalocean",
                "type": "app",
                "config": {
                    "region": "fra1",
                    "domain": "www.my-website.com",
                    "instance_count": 2,
                    "env_from_shared": true
                }
            },
            "env": {
                "dev": [
                    {
                        "key": "PUBLIC_API_URL",
                        "type": "value",
                        "value": "http://localhost:3000"
                    }
                ],
                "production": [
                    {
                        "key": "PUBLIC_API_URL",
                        "type": "value",
                        "value": "https://api.my-website.com"
                    },
                    {
                        "key": "ASSETS_BUCKET",
                        "type": "from_resource",
                        "from": "resource:object-store:bucket"
                    }
                ]
            }
        }
    ]
}
```
```

## File: manifest/project.md
```markdown
# Project

Defines project identity and source repository. This object is used for outputting metadata and prefixing resources.

## Attributes

| Key           | Description                        | Required | Notes      |
|---------------|------------------------------------|----------|------------|
| `name`        | Project machine-readable name      | Yes      | kebab-case |
| `title`       | Human-readable project title       | Yes      | Title Case |
| `description` | Description of the project         | Yes      |            |
| `repo`        | Github repository link (HTTPs URL) | Yes      |            |


## Example

```json
{
    "project": {
        "name": "my-website",
        "title": "My Website",
        "description": "My website is a bespoke sales platform for developers and designers.",
        "repo": "git@github.com:ainsley/my-website.git"
    }
}
```
```

## File: manifest/resources.md
```markdown
# Resources

Resources define infrastructure components that applications depend on. They act as declarative specifications of
services such as databases, caches and storage buckets that apps can use.

## Attributes

| Key           | Description                                                  | Required | Notes                           |
|---------------|--------------------------------------------------------------|----------|---------------------------------|
| `name`        | Project machine-readable name                                | Yes      | kebab-case                      |
| `type`        | Type of infrastructure or deployment unit                    | Yes      | Supported: `s3`, `postgres`     |
| `provider`    | Cloud provider where the infrastructure is provisioned       | Yes      | Supported: `digitalocean`, `b2` |
| `description` | Description of the resource                                  | No       |                                 |
| `config`      | Terraform input configuration based on the type and provider | Yes      |                                 |
| `outputs`     | Terraform outputs based on the type and provider             | No       |                                 |

::: warning
Each provider variable and output needs to be documented according to each module. To be confirmed how this should be
done.
:::

## Example

 ```json
{
    "resources": [
        {
            "name": "db",
            "type": "postgres",
            "provider": "digitalocean",
            "config": {
                "size": "db-s-1vcpu-1gb",
                "engine_version": "17",
                "region": "ams3"
            },
            "outputs": [
                "connection_url",
                "host",
                "port",
                "database"
            ]
        },
        {
            "name": "store",
            "type": "s3",
            "provider": "digitalocean",
            "config": {
                "region": "ams3",
                "acl": "public-read"
            },
            "outputs": [
                "bucket_name",
                "endpoint",
                "region"
            ]
        }
    ]
}
```

## Config

The `config` key directly relates to the Terraform configuration for a provider. Each provider has a subset of variables
that are exposed in each module. For example, a `digitalocean`, `postgres` resource exposes `name`, `pg_version` etc.

::: info
More resources can be added at a later date such as Redis and other components.
:::

## Outputs

**How Outputs Work:**

Resources expose outputs that can be referenced by apps and other resources. Outputs must be explicitly declared in the
`outputs` block of each resource definition.

**Output Declaration:**

Each resource declares which outputs are available. The values come from Terraform outputs after provisioning.

**How This Maps to Terraform:**

WebKit generates Terraform modules for each resource. The `outputs` array in `app.json` corresponds directly to
Terraform outputs:

```terraform
# Generated: terraform/modules/db/outputs.tf
output "connection_url" {
  value     = digitalocean_database_cluster.primary.uri
  sensitive = true
}

output "host" {
  value = digitalocean_database_cluster.primary.host
}

output "port" {
  value = digitalocean_database_cluster.primary.port
}

output "database" {
  value = digitalocean_database_cluster.primary.database
}
```
```

## File: manifest/versioning.md
```markdown
# Versioning

TODO
```

## File: index.md
```markdown
---
# https://vitepress.dev/reference/default-theme-home-page
layout: home

hero:
  name: "WebKit"
  text: "Documentation for WebKit"
  tagline: My great project tagline
  actions:
    - theme: brand
      text: Get Started
      link: /intro
    - theme: alt
      text: Visit ainsley.dev
      link: https://ainsley.dev

features:
  - title: Feature A
    details: Lorem ipsum dolor sit amet, consectetur adipiscing elit
  - title: Feature B
    details: Lorem ipsum dolor sit amet, consectetur adipiscing elit
  - title: Feature C
    details: Lorem ipsum dolor sit amet, consectetur adipiscing elit
---
```

## File: intro.md
```markdown
## Introduction

WebKit is a Go-based CLI tool designed to streamline the lifecycle of web projects. It centralises configuration in a
single manifest file (`app.json`) and generates all surrounding infrastructure, CI/CD pipelines, and environment
scaffolding automatically.

The objective is to reduce repetitive setup work when creating new projects, improve consistency across deployments, and
provide a reliable foundation for infrastructure management.

WebKit is opinionated about conventions but extensible enough to support evolving use cases.
```

## File: notes.md
```markdown
# Notes & Questions

## Questions

- For environment variables, how will they be injected into each component? We have SOPS files, but how would a
  component under `cms` load this for example? Each component always usually has a `.env` file.
- Do we want to define a repo link? Why would we need it? We can reference `github.com/ainsleydev/{project_name}`

## Notes

- See: https://devcenter.heroku.com/articles/config-vars
-
```

## File: WhitePaper.md
```markdown
# WebKit


## Secrets and Environment Strategy

This whole section is to be considered and not confirmed.

- Secrets are not inlined in `app.json` Instead: They are referenced via a from field (`sops:`, `github-secrets:`,
  `vault:`).
- SOPS is the default backend: plaintext YAML → encrypted YAML checked into secrets. `webkit encrypt` and
  `webkit decrypt` manage the lifecycle.
- GitHub Action hook ensures no plaintext secrets are committed.

## Implementation Conventions

- Language: Go.
- Templates: Embedded via embed.FS, overridable by local templates/.
- Template context: includes Project, Apps, Resources, Env, Shared.
- Testing: `webkit validate` ensures manifests conform to schema.
- Generated file tracking: internally tracked by WebKit, not exposed in manifest.

---
```
